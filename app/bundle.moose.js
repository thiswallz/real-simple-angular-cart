(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        var angular = require("angular");
        require("angular-ui-router");
        require("angular-animate");
        require("angular-resource");
        require("angular-translate");
        require("angular-translate-loader-static-files");
        require("ngstorage");
        angular.module("moose", [ "ngAnimate", "ngResource", "ngStorage", "ui.router", "pascalprecht.translate", "moose.configuration", "moose.dashboard", "moose.shopping", "moose.header", "moose.sidebar" ]).config([ "$httpProvider", "$urlRouterProvider", "$stateProvider", "$translateProvider", function($httpProvider, $urlRouterProvider, $stateProvider, $translateProvider) {
            $translateProvider.useStaticFilesLoader({
                prefix: "assets/dist/languages/lang.",
                suffix: ".json"
            }).useSanitizeValueStrategy("escape").registerAvailableLanguageKeys([ "en", "de" ], {
                en_US: "en",
                en_UK: "en",
                de_DE: "de",
                de_CH: "de",
                de_AT: "de"
            }).determinePreferredLanguage();
            $urlRouterProvider.otherwise("/");
            $stateProvider.state("app", {
                title: "Moose",
                views: {
                    "": {
                        templateUrl: "app/templates/main.html"
                    },
                    "sidebar@app": "mooseSidebar",
                    "header@app": "mooseHeader"
                }
            });
        } ]).run([ "$rootScope", "$state", "$translate", "$transitions", function($rootScope, $state, $translate, $transitions) {
            $transitions.onSuccess({}, function(transition) {
                $rootScope.pageName = transition.$to().class;
                $translate("Pages." + transition.$to().title + ".Title").then(function(translation) {
                    $rootScope.pageTitle = translation;
                }).catch(function() {
                    $rootScope.pageTitle = transition.$to().title;
                });
            });
        } ]);
        require("./moose.component");
        require("./configurations");
        require("./directives");
        require("./modules");
        require("./services");
    }, {
        "./configurations": 3,
        "./directives": 4,
        "./modules": 8,
        "./moose.component": 13,
        "./services": 14,
        angular: 108,
        "angular-animate": 88,
        "angular-resource": 90,
        "angular-translate": 92,
        "angular-translate-loader-static-files": 91,
        "angular-ui-router": 96,
        ngstorage: 109
    } ],
    2: [ function(require, module, exports) {
        angular.module("moose.configuration", []).value("CONFIGURATION", {
            api: "https://api.efood.real.de/api/v2/real",
            oauth: "https://api.efood.real.de/authorizationserver/oauth/token",
            images: "https://www.real.de/lebensmittelshop/images"
        });
    }, {} ],
    3: [ function(require, module, exports) {
        require("./endpoints");
    }, {
        "./endpoints": 2
    } ],
    4: [ function(require, module, exports) {}, {} ],
    5: [ function(require, module, exports) {
        angular.module("moose.dashboard").component("mooseDashboard", {
            controller: DashboardController,
            templateUrl: "app/modules/dashboard/dashboard.component.html"
        });
        function DashboardController() {
            var ctrl = this;
            ctrl.$onInit = function() {
                ctrl.user = {
                    fullName: "Hallo Welt"
                };
            };
        }
    }, {} ],
    6: [ function(require, module, exports) {
        angular.module("moose.dashboard", []).config([ "$stateProvider", function LoginConfiguration($stateProvider) {
            $stateProvider.state({
                name: "app.dashboard",
                title: "Dashboard",
                class: "app-dashboard",
                url: "/",
                component: "mooseDashboard",
                restricted: true
            });
        } ]);
    }, {} ],
    7: [ function(require, module, exports) {
        angular.module("moose.header", []).component("mooseHeader", {
            controller: HeaderController,
            templateUrl: "app/modules/header/header.component.html"
        });
        function HeaderController() {
            var ctrl = this;
            ctrl.$onInit = function() {
                ctrl.currentDate = new Date();
            };
        }
    }, {} ],
    8: [ function(require, module, exports) {
        require("./dashboard/dashboard.module");
        require("./dashboard/dashboard.component");
        require("./shopping/shopping.module");
        require("./shopping/shopping.component");
        require("./shopping/list/shopping.list.component");
        require("./header/header.component");
        require("./sidebar/sidebar.component");
    }, {
        "./dashboard/dashboard.component": 5,
        "./dashboard/dashboard.module": 6,
        "./header/header.component": 7,
        "./shopping/list/shopping.list.component": 9,
        "./shopping/shopping.component": 10,
        "./shopping/shopping.module": 11,
        "./sidebar/sidebar.component": 12
    } ],
    9: [ function(require, module, exports) {
        angular.module("moose.shopping").component("mooseShoppingList", {
            controller: ShoppingListController,
            templateUrl: "app/modules/shopping/list/shopping.list.component.html"
        });
        function ShoppingListController() {
            var ctrl = this;
            ctrl.$onInit = function() {
                ctrl.user = {
                    fullName: "Hallo Welt"
                };
            };
        }
    }, {} ],
    10: [ function(require, module, exports) {
        angular.module("moose.shopping").component("mooseShopping", {
            controller: ShoppingController,
            templateUrl: "app/modules/shopping/shopping.component.html"
        });
        function ShoppingController() {
            var ctrl = this;
            ctrl.$onInit = function() {
                ctrl.user = {
                    fullName: "Hallo Welt"
                };
            };
        }
    }, {} ],
    11: [ function(require, module, exports) {
        angular.module("moose.shopping", []).config([ "$stateProvider", function LoginConfiguration($stateProvider) {
            $stateProvider.state({
                abstract: true,
                name: "app.shopping",
                title: "Shopping",
                class: "app-shopping",
                url: "/shopping",
                component: "mooseShopping",
                restricted: true
            }).state("app.shopping.list", {
                url: "/list",
                component: "mooseShoppingList"
            });
        } ]);
    }, {} ],
    12: [ function(require, module, exports) {
        angular.module("moose.sidebar", []).component("mooseSidebar", {
            controller: HeaderController,
            templateUrl: "app/modules/sidebar/sidebar.component.html"
        });
        function HeaderController() {
            var ctrl = this;
        }
    }, {} ],
    13: [ function(require, module, exports) {
        angular.module("moose").component("mooseApp", {
            controller: MooseController,
            templateUrl: "app/moose.component.html"
        });
        function MooseController() {
            var ctrl = this;
            ctrl.$onInit = function() {};
        }
    }, {} ],
    14: [ function(require, module, exports) {}, {} ],
    15: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var predicates_1 = require("./predicates");
        var hof_1 = require("./hof");
        var coreservices_1 = require("./coreservices");
        var w = typeof window === "undefined" ? {} : window;
        var angular = w.angular || {};
        exports.fromJson = angular.fromJson || JSON.parse.bind(JSON);
        exports.toJson = angular.toJson || JSON.stringify.bind(JSON);
        exports.copy = angular.copy || _copy;
        exports.forEach = angular.forEach || _forEach;
        exports.extend = Object.assign || _extend;
        exports.equals = angular.equals || _equals;
        function identity(x) {
            return x;
        }
        exports.identity = identity;
        function noop() {}
        exports.noop = noop;
        function createProxyFunctions(source, target, bind, fnNames, latebind) {
            if (latebind === void 0) {
                latebind = false;
            }
            var bindFunction = function(fnName) {
                return source()[fnName].bind(bind());
            };
            var makeLateRebindFn = function(fnName) {
                return function lateRebindFunction() {
                    target[fnName] = bindFunction(fnName);
                    return target[fnName].apply(null, arguments);
                };
            };
            fnNames = fnNames || Object.keys(source());
            return fnNames.reduce(function(acc, name) {
                acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);
                return acc;
            }, target);
        }
        exports.createProxyFunctions = createProxyFunctions;
        exports.inherit = function(parent, extra) {
            return exports.extend(Object.create(parent), extra);
        };
        var restArgs = function(args, idx) {
            if (idx === void 0) {
                idx = 0;
            }
            return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));
        };
        exports.inArray = hof_1.curry(_inArray);
        function _inArray(array, obj) {
            return array.indexOf(obj) !== -1;
        }
        exports._inArray = _inArray;
        exports.removeFrom = hof_1.curry(_removeFrom);
        function _removeFrom(array, obj) {
            var idx = array.indexOf(obj);
            if (idx >= 0) array.splice(idx, 1);
            return array;
        }
        exports._removeFrom = _removeFrom;
        exports.pushTo = hof_1.curry(_pushTo);
        function _pushTo(arr, val) {
            return arr.push(val), val;
        }
        exports._pushTo = _pushTo;
        exports.deregAll = function(functions) {
            return functions.slice().forEach(function(fn) {
                typeof fn === "function" && fn();
                exports.removeFrom(functions, fn);
            });
        };
        function defaults(opts) {
            var defaultsList = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                defaultsList[_i - 1] = arguments[_i];
            }
            var _defaultsList = defaultsList.concat({}).reverse();
            var defaultVals = exports.extend.apply(null, _defaultsList);
            return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));
        }
        exports.defaults = defaults;
        exports.mergeR = function(memo, item) {
            return exports.extend(memo, item);
        };
        function ancestors(first, second) {
            var path = [];
            for (var n in first.path) {
                if (first.path[n] !== second.path[n]) break;
                path.push(first.path[n]);
            }
            return path;
        }
        exports.ancestors = ancestors;
        function pick(obj, propNames) {
            var objCopy = {};
            for (var prop_1 in obj) {
                if (propNames.indexOf(prop_1) !== -1) {
                    objCopy[prop_1] = obj[prop_1];
                }
            }
            return objCopy;
        }
        exports.pick = pick;
        function omit(obj, propNames) {
            return Object.keys(obj).filter(hof_1.not(exports.inArray(propNames))).reduce(function(acc, key) {
                return acc[key] = obj[key], acc;
            }, {});
        }
        exports.omit = omit;
        function pluck(collection, propName) {
            return map(collection, hof_1.prop(propName));
        }
        exports.pluck = pluck;
        function filter(collection, callback) {
            var arr = predicates_1.isArray(collection), result = arr ? [] : {};
            var accept = arr ? function(x) {
                return result.push(x);
            } : function(x, key) {
                return result[key] = x;
            };
            exports.forEach(collection, function(item, i) {
                if (callback(item, i)) accept(item, i);
            });
            return result;
        }
        exports.filter = filter;
        function find(collection, callback) {
            var result;
            exports.forEach(collection, function(item, i) {
                if (result) return;
                if (callback(item, i)) result = item;
            });
            return result;
        }
        exports.find = find;
        exports.mapObj = map;
        function map(collection, callback) {
            var result = predicates_1.isArray(collection) ? [] : {};
            exports.forEach(collection, function(item, i) {
                return result[i] = callback(item, i);
            });
            return result;
        }
        exports.map = map;
        exports.values = function(obj) {
            return Object.keys(obj).map(function(key) {
                return obj[key];
            });
        };
        exports.allTrueR = function(memo, elem) {
            return memo && elem;
        };
        exports.anyTrueR = function(memo, elem) {
            return memo || elem;
        };
        exports.unnestR = function(memo, elem) {
            return memo.concat(elem);
        };
        exports.flattenR = function(memo, elem) {
            return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);
        };
        function pushR(arr, obj) {
            arr.push(obj);
            return arr;
        }
        exports.pushR = pushR;
        exports.uniqR = function(acc, token) {
            return exports.inArray(acc, token) ? acc : pushR(acc, token);
        };
        exports.unnest = function(arr) {
            return arr.reduce(exports.unnestR, []);
        };
        exports.flatten = function(arr) {
            return arr.reduce(exports.flattenR, []);
        };
        exports.assertPredicate = assertFn;
        exports.assertMap = assertFn;
        function assertFn(predicateOrMap, errMsg) {
            if (errMsg === void 0) {
                errMsg = "assert failure";
            }
            return function(obj) {
                var result = predicateOrMap(obj);
                if (!result) {
                    throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);
                }
                return result;
            };
        }
        exports.assertFn = assertFn;
        exports.pairs = function(obj) {
            return Object.keys(obj).map(function(key) {
                return [ key, obj[key] ];
            });
        };
        function arrayTuples() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0) return [];
            var maxArrayLen = args.reduce(function(min, arr) {
                return Math.min(arr.length, min);
            }, 9007199254740991);
            var i, result = [];
            for (i = 0; i < maxArrayLen; i++) {
                switch (args.length) {
                  case 1:
                    result.push([ args[0][i] ]);
                    break;

                  case 2:
                    result.push([ args[0][i], args[1][i] ]);
                    break;

                  case 3:
                    result.push([ args[0][i], args[1][i], args[2][i] ]);
                    break;

                  case 4:
                    result.push([ args[0][i], args[1][i], args[2][i], args[3][i] ]);
                    break;

                  default:
                    result.push(args.map(function(array) {
                        return array[i];
                    }));
                    break;
                }
            }
            return result;
        }
        exports.arrayTuples = arrayTuples;
        function applyPairs(memo, keyValTuple) {
            var key, value;
            if (predicates_1.isArray(keyValTuple)) key = keyValTuple[0], value = keyValTuple[1];
            if (!predicates_1.isString(key)) throw new Error("invalid parameters to applyPairs");
            memo[key] = value;
            return memo;
        }
        exports.applyPairs = applyPairs;
        function tail(arr) {
            return arr.length && arr[arr.length - 1] || undefined;
        }
        exports.tail = tail;
        function _copy(src, dest) {
            if (dest) Object.keys(dest).forEach(function(key) {
                return delete dest[key];
            });
            if (!dest) dest = {};
            return exports.extend(dest, src);
        }
        function _forEach(obj, cb, _this) {
            if (predicates_1.isArray(obj)) return obj.forEach(cb, _this);
            Object.keys(obj).forEach(function(key) {
                return cb(obj[key], key);
            });
        }
        function _extend(toObj) {
            for (var i = 1; i < arguments.length; i++) {
                var obj = arguments[i];
                if (!obj) continue;
                var keys = Object.keys(obj);
                for (var j = 0; j < keys.length; j++) {
                    toObj[keys[j]] = obj[keys[j]];
                }
            }
            return toObj;
        }
        exports._extend = _extend;
        function _equals(o1, o2) {
            if (o1 === o2) return true;
            if (o1 === null || o2 === null) return false;
            if (o1 !== o1 && o2 !== o2) return true;
            var t1 = typeof o1, t2 = typeof o2;
            if (t1 !== t2 || t1 !== "object") return false;
            var tup = [ o1, o2 ];
            if (hof_1.all(predicates_1.isArray)(tup)) return _arraysEq(o1, o2);
            if (hof_1.all(predicates_1.isDate)(tup)) return o1.getTime() === o2.getTime();
            if (hof_1.all(predicates_1.isRegExp)(tup)) return o1.toString() === o2.toString();
            if (hof_1.all(predicates_1.isFunction)(tup)) return true;
            var predicates = [ predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp ];
            if (predicates.map(hof_1.any).reduce(function(b, fn) {
                return b || !!fn(tup);
            }, false)) return false;
            var key, keys = {};
            for (key in o1) {
                if (!_equals(o1[key], o2[key])) return false;
                keys[key] = true;
            }
            for (key in o2) {
                if (!keys[key]) return false;
            }
            return true;
        }
        function _arraysEq(a1, a2) {
            if (a1.length !== a2.length) return false;
            return arrayTuples(a1, a2).reduce(function(b, t) {
                return b && _equals(t[0], t[1]);
            }, true);
        }
        exports.sortBy = function(propFn, checkFn) {
            if (checkFn === void 0) {
                checkFn = hof_1.val(true);
            }
            return function(a, b) {
                return checkFn(a) && checkFn(b) ? propFn(a) - propFn(b) : 0;
            };
        };
        exports.composeSort = function() {
            var sortFns = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                sortFns[_i] = arguments[_i];
            }
            return function composedSort(a, b) {
                return sortFns.reduce(function(prev, fn) {
                    return prev || fn(a, b);
                }, 0);
            };
        };
        exports.silenceUncaughtInPromise = function(promise) {
            return promise.catch(function(e) {
                return 0;
            }) && promise;
        };
        exports.silentRejection = function(error) {
            return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));
        };
    }, {
        "./coreservices": 16,
        "./hof": 18,
        "./predicates": 20
    } ],
    16: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.notImplemented = function(fnname) {
            return function() {
                throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");
            };
        };
        var services = {
            $q: undefined,
            $injector: undefined
        };
        exports.services = services;
    }, {} ],
    17: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var Glob = function() {
            function Glob(text) {
                this.text = text;
                this.glob = text.split(".");
                var regexpString = this.text.split(".").map(function(seg) {
                    if (seg === "**") return "(?:|(?:\\.[^.]*)*)";
                    if (seg === "*") return "\\.[^.]*";
                    return "\\." + seg;
                }).join("");
                this.regexp = new RegExp("^" + regexpString + "$");
            }
            Glob.prototype.matches = function(name) {
                return this.regexp.test("." + name);
            };
            Glob.is = function(text) {
                return !!/[!,*]+/.exec(text);
            };
            Glob.fromString = function(text) {
                return Glob.is(text) ? new Glob(text) : null;
            };
            return Glob;
        }();
        exports.Glob = Glob;
    }, {} ],
    18: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function curry(fn) {
            var initial_args = [].slice.apply(arguments, [ 1 ]);
            var func_args_length = fn.length;
            function curried(args) {
                if (args.length >= func_args_length) return fn.apply(null, args);
                return function() {
                    return curried(args.concat([].slice.apply(arguments)));
                };
            }
            return curried(initial_args);
        }
        exports.curry = curry;
        function compose() {
            var args = arguments;
            var start = args.length - 1;
            return function() {
                var i = start, result = args[start].apply(this, arguments);
                while (i--) result = args[i].call(this, result);
                return result;
            };
        }
        exports.compose = compose;
        function pipe() {
            var funcs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                funcs[_i] = arguments[_i];
            }
            return compose.apply(null, [].slice.call(arguments).reverse());
        }
        exports.pipe = pipe;
        exports.prop = function(name) {
            return function(obj) {
                return obj && obj[name];
            };
        };
        exports.propEq = curry(function(name, val, obj) {
            return obj && obj[name] === val;
        });
        exports.parse = function(name) {
            return pipe.apply(null, name.split(".").map(exports.prop));
        };
        exports.not = function(fn) {
            return function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return !fn.apply(null, args);
            };
        };
        function and(fn1, fn2) {
            return function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return fn1.apply(null, args) && fn2.apply(null, args);
            };
        }
        exports.and = and;
        function or(fn1, fn2) {
            return function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return fn1.apply(null, args) || fn2.apply(null, args);
            };
        }
        exports.or = or;
        exports.all = function(fn1) {
            return function(arr) {
                return arr.reduce(function(b, x) {
                    return b && !!fn1(x);
                }, true);
            };
        };
        exports.any = function(fn1) {
            return function(arr) {
                return arr.reduce(function(b, x) {
                    return b || !!fn1(x);
                }, false);
            };
        };
        exports.is = function(ctor) {
            return function(obj) {
                return obj != null && obj.constructor === ctor || obj instanceof ctor;
            };
        };
        exports.eq = function(val) {
            return function(other) {
                return val === other;
            };
        };
        exports.val = function(v) {
            return function() {
                return v;
            };
        };
        function invoke(fnName, args) {
            return function(obj) {
                return obj[fnName].apply(obj, args);
            };
        }
        exports.invoke = invoke;
        function pattern(struct) {
            return function(x) {
                for (var i = 0; i < struct.length; i++) {
                    if (struct[i][0](x)) return struct[i][1](x);
                }
            };
        }
        exports.pattern = pattern;
    }, {} ],
    19: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./common"));
        __export(require("./coreservices"));
        __export(require("./glob"));
        __export(require("./hof"));
        __export(require("./predicates"));
        __export(require("./queue"));
        __export(require("./strings"));
        __export(require("./trace"));
    }, {
        "./common": 15,
        "./coreservices": 16,
        "./glob": 17,
        "./hof": 18,
        "./predicates": 20,
        "./queue": 21,
        "./strings": 22,
        "./trace": 23
    } ],
    20: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var hof_1 = require("./hof");
        var stateObject_1 = require("../state/stateObject");
        var toStr = Object.prototype.toString;
        var tis = function(t) {
            return function(x) {
                return typeof x === t;
            };
        };
        exports.isUndefined = tis("undefined");
        exports.isDefined = hof_1.not(exports.isUndefined);
        exports.isNull = function(o) {
            return o === null;
        };
        exports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);
        exports.isFunction = tis("function");
        exports.isNumber = tis("number");
        exports.isString = tis("string");
        exports.isObject = function(x) {
            return x !== null && typeof x === "object";
        };
        exports.isArray = Array.isArray;
        exports.isDate = function(x) {
            return toStr.call(x) === "[object Date]";
        };
        exports.isRegExp = function(x) {
            return toStr.call(x) === "[object RegExp]";
        };
        exports.isState = stateObject_1.StateObject.isState;
        function isInjectable(val) {
            if (exports.isArray(val) && val.length) {
                var head = val.slice(0, -1), tail = val.slice(-1);
                return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);
            }
            return exports.isFunction(val);
        }
        exports.isInjectable = isInjectable;
        exports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop("then"), exports.isFunction));
    }, {
        "../state/stateObject": 53,
        "./hof": 18
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var Queue = function() {
            function Queue(_items, _limit) {
                if (_items === void 0) {
                    _items = [];
                }
                if (_limit === void 0) {
                    _limit = null;
                }
                this._items = _items;
                this._limit = _limit;
            }
            Queue.prototype.enqueue = function(item) {
                var items = this._items;
                items.push(item);
                if (this._limit && items.length > this._limit) items.shift();
                return item;
            };
            Queue.prototype.dequeue = function() {
                if (this.size()) return this._items.splice(0, 1)[0];
            };
            Queue.prototype.clear = function() {
                var current = this._items;
                this._items = [];
                return current;
            };
            Queue.prototype.size = function() {
                return this._items.length;
            };
            Queue.prototype.remove = function(item) {
                var idx = this._items.indexOf(item);
                return idx > -1 && this._items.splice(idx, 1)[0];
            };
            Queue.prototype.peekTail = function() {
                return this._items[this._items.length - 1];
            };
            Queue.prototype.peekHead = function() {
                if (this.size()) return this._items[0];
            };
            return Queue;
        }();
        exports.Queue = Queue;
    }, {} ],
    22: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var predicates_1 = require("./predicates");
        var rejectFactory_1 = require("../transition/rejectFactory");
        var common_1 = require("./common");
        var hof_1 = require("./hof");
        var transition_1 = require("../transition/transition");
        var resolvable_1 = require("../resolve/resolvable");
        function maxLength(max, str) {
            if (str.length <= max) return str;
            return str.substr(0, max - 3) + "...";
        }
        exports.maxLength = maxLength;
        function padString(length, str) {
            while (str.length < length) str += " ";
            return str;
        }
        exports.padString = padString;
        function kebobString(camelCase) {
            return camelCase.replace(/^([A-Z])/, function($1) {
                return $1.toLowerCase();
            }).replace(/([A-Z])/g, function($1) {
                return "-" + $1.toLowerCase();
            });
        }
        exports.kebobString = kebobString;
        function _toJson(obj) {
            return JSON.stringify(obj);
        }
        function _fromJson(json) {
            return predicates_1.isString(json) ? JSON.parse(json) : json;
        }
        function promiseToString(p) {
            return "Promise(" + JSON.stringify(p) + ")";
        }
        function functionToString(fn) {
            var fnStr = fnToString(fn);
            var namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);
            var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;
            var fnName = fn["name"] || "";
            if (fnName && toStr.match(/function \(/)) {
                return "function " + fnName + toStr.substr(9);
            }
            return toStr;
        }
        exports.functionToString = functionToString;
        function fnToString(fn) {
            var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;
            return _fn && _fn.toString() || "undefined";
        }
        exports.fnToString = fnToString;
        var stringifyPatternFn = null;
        var stringifyPattern = function(value) {
            var isRejection = rejectFactory_1.Rejection.isRejectionPromise;
            stringifyPatternFn = stringifyPatternFn || hof_1.pattern([ [ hof_1.not(predicates_1.isDefined), hof_1.val("undefined") ], [ predicates_1.isNull, hof_1.val("null") ], [ predicates_1.isPromise, hof_1.val("[Promise]") ], [ isRejection, function(x) {
                return x._transitionRejection.toString();
            } ], [ hof_1.is(rejectFactory_1.Rejection), hof_1.invoke("toString") ], [ hof_1.is(transition_1.Transition), hof_1.invoke("toString") ], [ hof_1.is(resolvable_1.Resolvable), hof_1.invoke("toString") ], [ predicates_1.isInjectable, functionToString ], [ hof_1.val(true), common_1.identity ] ]);
            return stringifyPatternFn(value);
        };
        function stringify(o) {
            var seen = [];
            function format(val) {
                if (predicates_1.isObject(val)) {
                    if (seen.indexOf(val) !== -1) return "[circular ref]";
                    seen.push(val);
                }
                return stringifyPattern(val);
            }
            return JSON.stringify(o, function(key, val) {
                return format(val);
            }).replace(/\\"/g, '"');
        }
        exports.stringify = stringify;
        exports.beforeAfterSubstr = function(char) {
            return function(str) {
                if (!str) return [ "", "" ];
                var idx = str.indexOf(char);
                if (idx === -1) return [ str, "" ];
                return [ str.substr(0, idx), str.substr(idx + 1) ];
            };
        };
        function splitOnDelim(delim) {
            var re = new RegExp("(" + delim + ")", "g");
            return function(str) {
                return str.split(re).filter(common_1.identity);
            };
        }
        exports.splitOnDelim = splitOnDelim;
        function joinNeighborsR(acc, x) {
            if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x)) return acc.slice(0, -1).concat(common_1.tail(acc) + x);
            return common_1.pushR(acc, x);
        }
        exports.joinNeighborsR = joinNeighborsR;
    }, {
        "../resolve/resolvable": 47,
        "../transition/rejectFactory": 62,
        "../transition/transition": 63,
        "./common": 15,
        "./hof": 18,
        "./predicates": 20
    } ],
    23: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var hof_1 = require("../common/hof");
        var predicates_1 = require("../common/predicates");
        var strings_1 = require("./strings");
        function uiViewString(viewData) {
            if (!viewData) return "ui-view (defunct)";
            return "[ui-view#" + viewData.id + " tag " + ("in template from '" + (viewData.creationContext && viewData.creationContext.name || "(root)") + "' state]: ") + ("fqn: '" + viewData.fqn + "', ") + ("name: '" + viewData.name + "@" + viewData.creationContext + "')");
        }
        var viewConfigString = function(viewConfig) {
            return "[ViewConfig#" + viewConfig.$id + " from '" + (viewConfig.viewDecl.$context.name || "(root)") + "' state]: target ui-view: '" + viewConfig.viewDecl.$uiViewName + "@" + viewConfig.viewDecl.$uiViewContextAnchor + "'";
        };
        function normalizedCat(input) {
            return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];
        }
        var Category;
        (function(Category) {
            Category[Category["RESOLVE"] = 0] = "RESOLVE";
            Category[Category["TRANSITION"] = 1] = "TRANSITION";
            Category[Category["HOOK"] = 2] = "HOOK";
            Category[Category["UIVIEW"] = 3] = "UIVIEW";
            Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";
        })(Category = exports.Category || (exports.Category = {}));
        var _tid = hof_1.parse("$id");
        var _rid = hof_1.parse("router.$id");
        var transLbl = function(trans) {
            return "Transition #" + _tid(trans) + "-" + _rid(trans);
        };
        var Trace = function() {
            function Trace() {
                this._enabled = {};
                this.approximateDigests = 0;
            }
            Trace.prototype._set = function(enabled, categories) {
                var _this = this;
                if (!categories.length) {
                    categories = Object.keys(Category).map(function(k) {
                        return parseInt(k, 10);
                    }).filter(function(k) {
                        return !isNaN(k);
                    }).map(function(key) {
                        return Category[key];
                    });
                }
                categories.map(normalizedCat).forEach(function(category) {
                    return _this._enabled[category] = enabled;
                });
            };
            Trace.prototype.enable = function() {
                var categories = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    categories[_i] = arguments[_i];
                }
                this._set(true, categories);
            };
            Trace.prototype.disable = function() {
                var categories = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    categories[_i] = arguments[_i];
                }
                this._set(false, categories);
            };
            Trace.prototype.enabled = function(category) {
                return !!this._enabled[normalizedCat(category)];
            };
            Trace.prototype.traceTransitionStart = function(trans) {
                if (!this.enabled(Category.TRANSITION)) return;
                console.log(transLbl(trans) + ": Started  -> " + strings_1.stringify(trans));
            };
            Trace.prototype.traceTransitionIgnored = function(trans) {
                if (!this.enabled(Category.TRANSITION)) return;
                console.log(transLbl(trans) + ": Ignored  <> " + strings_1.stringify(trans));
            };
            Trace.prototype.traceHookInvocation = function(step, trans, options) {
                if (!this.enabled(Category.HOOK)) return;
                var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.functionToString(step.registeredHook.callback);
                console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + strings_1.maxLength(200, name));
            };
            Trace.prototype.traceHookResult = function(hookResult, trans, transitionOptions) {
                if (!this.enabled(Category.HOOK)) return;
                console.log(transLbl(trans) + ":   <- Hook returned: " + strings_1.maxLength(200, strings_1.stringify(hookResult)));
            };
            Trace.prototype.traceResolvePath = function(path, when, trans) {
                if (!this.enabled(Category.RESOLVE)) return;
                console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
            };
            Trace.prototype.traceResolvableResolved = function(resolvable, trans) {
                if (!this.enabled(Category.RESOLVE)) return;
                console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));
            };
            Trace.prototype.traceError = function(reason, trans) {
                if (!this.enabled(Category.TRANSITION)) return;
                console.log(transLbl(trans) + ": <- Rejected " + strings_1.stringify(trans) + ", reason: " + reason);
            };
            Trace.prototype.traceSuccess = function(finalState, trans) {
                if (!this.enabled(Category.TRANSITION)) return;
                console.log(transLbl(trans) + ": <- Success  " + strings_1.stringify(trans) + ", final state: " + finalState.name);
            };
            Trace.prototype.traceUIViewEvent = function(event, viewData, extra) {
                if (extra === void 0) {
                    extra = "";
                }
                if (!this.enabled(Category.UIVIEW)) return;
                console.log("ui-view: " + strings_1.padString(30, event) + " " + uiViewString(viewData) + extra);
            };
            Trace.prototype.traceUIViewConfigUpdated = function(viewData, context) {
                if (!this.enabled(Category.UIVIEW)) return;
                this.traceUIViewEvent("Updating", viewData, " with ViewConfig from context='" + context + "'");
            };
            Trace.prototype.traceUIViewFill = function(viewData, html) {
                if (!this.enabled(Category.UIVIEW)) return;
                this.traceUIViewEvent("Fill", viewData, " with: " + strings_1.maxLength(200, html));
            };
            Trace.prototype.traceViewServiceEvent = function(event, viewConfig) {
                if (!this.enabled(Category.VIEWCONFIG)) return;
                console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
            };
            Trace.prototype.traceViewServiceUIViewEvent = function(event, viewData) {
                if (!this.enabled(Category.VIEWCONFIG)) return;
                console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
            };
            return Trace;
        }();
        exports.Trace = Trace;
        var trace = new Trace();
        exports.trace = trace;
    }, {
        "../common/hof": 18,
        "../common/predicates": 20,
        "./strings": 22
    } ],
    24: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var stateParams_1 = require("./params/stateParams");
        var queue_1 = require("./common/queue");
        var UIRouterGlobals = function() {
            function UIRouterGlobals() {
                this.params = new stateParams_1.StateParams();
                this.lastStartedTransitionId = -1;
                this.transitionHistory = new queue_1.Queue([], 1);
                this.successfulTransitions = new queue_1.Queue([], 1);
            }
            UIRouterGlobals.prototype.dispose = function() {
                this.transitionHistory.clear();
                this.successfulTransitions.clear();
                this.transition = null;
            };
            return UIRouterGlobals;
        }();
        exports.UIRouterGlobals = UIRouterGlobals;
    }, {
        "./common/queue": 21,
        "./params/stateParams": 41
    } ],
    25: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var transition_1 = require("../transition/transition");
        var router_1 = require("../router");
        function addCoreResolvables(trans) {
            trans.addResolvable({
                token: router_1.UIRouter,
                deps: [],
                resolveFn: function() {
                    return trans.router;
                },
                data: trans.router
            }, "");
            trans.addResolvable({
                token: transition_1.Transition,
                deps: [],
                resolveFn: function() {
                    return trans;
                },
                data: trans
            }, "");
            trans.addResolvable({
                token: "$transition$",
                deps: [],
                resolveFn: function() {
                    return trans;
                },
                data: trans
            }, "");
            trans.addResolvable({
                token: "$stateParams",
                deps: [],
                resolveFn: function() {
                    return trans.params();
                },
                data: trans.params()
            }, "");
            trans.entering().forEach(function(state) {
                trans.addResolvable({
                    token: "$state$",
                    deps: [],
                    resolveFn: function() {
                        return state;
                    },
                    data: state
                }, state);
            });
        }
        exports.registerAddCoreResolvables = function(transitionService) {
            return transitionService.onCreate({}, addCoreResolvables);
        };
    }, {
        "../router": 49,
        "../transition/transition": 63
    } ],
    26: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var trace_1 = require("../common/trace");
        var rejectFactory_1 = require("../transition/rejectFactory");
        function ignoredHook(trans) {
            var ignoredReason = trans._ignoredReason();
            if (!ignoredReason) return;
            trace_1.trace.traceTransitionIgnored(trans);
            var pending = trans.router.globals.transition;
            if (ignoredReason === "SameAsCurrent" && pending) {
                pending.abort();
            }
            return rejectFactory_1.Rejection.ignored().toPromise();
        }
        exports.registerIgnoredTransitionHook = function(transitionService) {
            return transitionService.onBefore({}, ignoredHook, {
                priority: -9999
            });
        };
    }, {
        "../common/trace": 23,
        "../transition/rejectFactory": 62
    } ],
    27: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function invalidTransitionHook(trans) {
            if (!trans.valid()) {
                throw new Error(trans.error());
            }
        }
        exports.registerInvalidTransitionHook = function(transitionService) {
            return transitionService.onBefore({}, invalidTransitionHook, {
                priority: -1e4
            });
        };
    }, {} ],
    28: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var coreservices_1 = require("../common/coreservices");
        var lazyLoadHook = function(transition) {
            var router = transition.router;
            function retryTransition() {
                if (transition.originalTransition().options().source !== "url") {
                    var orig = transition.targetState();
                    return router.stateService.target(orig.identifier(), orig.params(), orig.options());
                }
                var $url = router.urlService;
                var result = $url.match($url.parts());
                var rule = result && result.rule;
                if (rule && rule.type === "STATE") {
                    var state = rule.state;
                    var params = result.match;
                    return router.stateService.target(state, params, transition.options());
                }
                router.urlService.sync();
            }
            var promises = transition.entering().filter(function(state) {
                return !!state.$$state().lazyLoad;
            }).map(function(state) {
                return lazyLoadState(transition, state);
            });
            return coreservices_1.services.$q.all(promises).then(retryTransition);
        };
        exports.registerLazyLoadHook = function(transitionService) {
            return transitionService.onBefore({
                entering: function(state) {
                    return !!state.lazyLoad;
                }
            }, lazyLoadHook);
        };
        function lazyLoadState(transition, state) {
            var lazyLoadFn = state.$$state().lazyLoad;
            var promise = lazyLoadFn["_promise"];
            if (!promise) {
                var success = function(result) {
                    delete state.lazyLoad;
                    delete state.$$state().lazyLoad;
                    delete lazyLoadFn["_promise"];
                    return result;
                };
                var error = function(err) {
                    delete lazyLoadFn["_promise"];
                    return coreservices_1.services.$q.reject(err);
                };
                promise = lazyLoadFn["_promise"] = coreservices_1.services.$q.when(lazyLoadFn(transition, state)).then(updateStateRegistry).then(success, error);
            }
            function updateStateRegistry(result) {
                if (result && Array.isArray(result.states)) {
                    result.states.forEach(function(state) {
                        return transition.router.stateRegistry.register(state);
                    });
                }
                return result;
            }
            return promise;
        }
        exports.lazyLoadState = lazyLoadState;
    }, {
        "../common/coreservices": 16
    } ],
    29: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function makeEnterExitRetainHook(hookName) {
            return function(transition, state) {
                var _state = state.$$state();
                var hookFn = _state[hookName];
                return hookFn(transition, state);
            };
        }
        var onExitHook = makeEnterExitRetainHook("onExit");
        exports.registerOnExitHook = function(transitionService) {
            return transitionService.onExit({
                exiting: function(state) {
                    return !!state.onExit;
                }
            }, onExitHook);
        };
        var onRetainHook = makeEnterExitRetainHook("onRetain");
        exports.registerOnRetainHook = function(transitionService) {
            return transitionService.onRetain({
                retained: function(state) {
                    return !!state.onRetain;
                }
            }, onRetainHook);
        };
        var onEnterHook = makeEnterExitRetainHook("onEnter");
        exports.registerOnEnterHook = function(transitionService) {
            return transitionService.onEnter({
                entering: function(state) {
                    return !!state.onEnter;
                }
            }, onEnterHook);
        };
    }, {} ],
    30: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var predicates_1 = require("../common/predicates");
        var coreservices_1 = require("../common/coreservices");
        var targetState_1 = require("../state/targetState");
        var redirectToHook = function(trans) {
            var redirect = trans.to().redirectTo;
            if (!redirect) return;
            var $state = trans.router.stateService;
            function handleResult(result) {
                if (!result) return;
                if (result instanceof targetState_1.TargetState) return result;
                if (predicates_1.isString(result)) return $state.target(result, trans.params(), trans.options());
                if (result["state"] || result["params"]) return $state.target(result["state"] || trans.to(), result["params"] || trans.params(), trans.options());
            }
            if (predicates_1.isFunction(redirect)) {
                return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);
            }
            return handleResult(redirect);
        };
        exports.registerRedirectToHook = function(transitionService) {
            return transitionService.onStart({
                to: function(state) {
                    return !!state.redirectTo;
                }
            }, redirectToHook);
        };
    }, {
        "../common/coreservices": 16,
        "../common/predicates": 20,
        "../state/targetState": 57
    } ],
    31: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var resolveContext_1 = require("../resolve/resolveContext");
        var hof_1 = require("../common/hof");
        var eagerResolvePath = function(trans) {
            return new resolveContext_1.ResolveContext(trans.treeChanges().to).resolvePath("EAGER", trans).then(common_1.noop);
        };
        exports.registerEagerResolvePath = function(transitionService) {
            return transitionService.onStart({}, eagerResolvePath, {
                priority: 1e3
            });
        };
        var lazyResolveState = function(trans, state) {
            return new resolveContext_1.ResolveContext(trans.treeChanges().to).subContext(state.$$state()).resolvePath("LAZY", trans).then(common_1.noop);
        };
        exports.registerLazyResolveState = function(transitionService) {
            return transitionService.onEnter({
                entering: hof_1.val(true)
            }, lazyResolveState, {
                priority: 1e3
            });
        };
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../resolve/resolveContext": 48
    } ],
    32: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var updateGlobalState = function(trans) {
            var globals = trans.router.globals;
            var transitionSuccessful = function() {
                globals.successfulTransitions.enqueue(trans);
                globals.$current = trans.$to();
                globals.current = globals.$current.self;
                common_1.copy(trans.params(), globals.params);
            };
            var clearCurrentTransition = function() {
                if (globals.transition === trans) globals.transition = null;
            };
            trans.onSuccess({}, transitionSuccessful, {
                priority: 1e4
            });
            trans.promise.then(clearCurrentTransition, clearCurrentTransition);
        };
        exports.registerUpdateGlobalState = function(transitionService) {
            return transitionService.onCreate({}, updateGlobalState);
        };
    }, {
        "../common/common": 15
    } ],
    33: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var updateUrl = function(transition) {
            var options = transition.options();
            var $state = transition.router.stateService;
            var $urlRouter = transition.router.urlRouter;
            if (options.source !== "url" && options.location && $state.$current.navigable) {
                var urlOptions = {
                    replace: options.location === "replace"
                };
                $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
            }
            $urlRouter.update(true);
        };
        exports.registerUpdateUrl = function(transitionService) {
            return transitionService.onSuccess({}, updateUrl, {
                priority: 9999
            });
        };
    }, {} ],
    34: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var coreservices_1 = require("../common/coreservices");
        var loadEnteringViews = function(transition) {
            var $q = coreservices_1.services.$q;
            var enteringViews = transition.views("entering");
            if (!enteringViews.length) return;
            return $q.all(enteringViews.map(function(view) {
                return $q.when(view.load());
            })).then(common_1.noop);
        };
        exports.registerLoadEnteringViews = function(transitionService) {
            return transitionService.onFinish({}, loadEnteringViews);
        };
        var activateViews = function(transition) {
            var enteringViews = transition.views("entering");
            var exitingViews = transition.views("exiting");
            if (!enteringViews.length && !exitingViews.length) return;
            var $view = transition.router.viewService;
            exitingViews.forEach(function(vc) {
                return $view.deactivateViewConfig(vc);
            });
            enteringViews.forEach(function(vc) {
                return $view.activateViewConfig(vc);
            });
            $view.sync();
        };
        exports.registerActivateViews = function(transitionService) {
            return transitionService.onSuccess({}, activateViews);
        };
    }, {
        "../common/common": 15,
        "../common/coreservices": 16
    } ],
    35: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./common/index"));
        __export(require("./params/index"));
        __export(require("./path/index"));
        __export(require("./resolve/index"));
        __export(require("./state/index"));
        __export(require("./transition/index"));
        __export(require("./url/index"));
        __export(require("./view/index"));
        __export(require("./globals"));
        __export(require("./router"));
        __export(require("./vanilla"));
        __export(require("./interface"));
    }, {
        "./common/index": 19,
        "./globals": 24,
        "./interface": 36,
        "./params/index": 37,
        "./path/index": 42,
        "./resolve/index": 45,
        "./router": 49,
        "./state/index": 50,
        "./transition/index": 60,
        "./url/index": 67,
        "./vanilla": 73,
        "./view/index": 85
    } ],
    36: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var UIRouterPluginBase = function() {
            function UIRouterPluginBase() {}
            UIRouterPluginBase.prototype.dispose = function(router) {};
            return UIRouterPluginBase;
        }();
        exports.UIRouterPluginBase = UIRouterPluginBase;
    }, {} ],
    37: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./param"));
        __export(require("./paramTypes"));
        __export(require("./stateParams"));
        __export(require("./paramType"));
    }, {
        "./param": 38,
        "./paramType": 39,
        "./paramTypes": 40,
        "./stateParams": 41
    } ],
    38: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var predicates_1 = require("../common/predicates");
        var coreservices_1 = require("../common/coreservices");
        var paramType_1 = require("./paramType");
        var hasOwn = Object.prototype.hasOwnProperty;
        var isShorthand = function(cfg) {
            return [ "value", "type", "squash", "array", "dynamic" ].filter(hasOwn.bind(cfg || {})).length === 0;
        };
        var DefType;
        (function(DefType) {
            DefType[DefType["PATH"] = 0] = "PATH";
            DefType[DefType["SEARCH"] = 1] = "SEARCH";
            DefType[DefType["CONFIG"] = 2] = "CONFIG";
        })(DefType = exports.DefType || (exports.DefType = {}));
        function unwrapShorthand(cfg) {
            cfg = isShorthand(cfg) && {
                value: cfg
            } || cfg;
            getStaticDefaultValue["__cacheable"] = true;
            function getStaticDefaultValue() {
                return cfg.value;
            }
            return common_1.extend(cfg, {
                $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue
            });
        }
        function getType(cfg, urlType, location, id, paramTypes) {
            if (cfg.type && urlType && urlType.name !== "string") throw new Error("Param '" + id + "' has two type configurations.");
            if (cfg.type && urlType && urlType.name === "string" && paramTypes.type(cfg.type)) return paramTypes.type(cfg.type);
            if (urlType) return urlType;
            if (!cfg.type) {
                var type = location === DefType.CONFIG ? "any" : location === DefType.PATH ? "path" : location === DefType.SEARCH ? "query" : "string";
                return paramTypes.type(type);
            }
            return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);
        }
        function getSquashPolicy(config, isOptional, defaultPolicy) {
            var squash = config.squash;
            if (!isOptional || squash === false) return false;
            if (!predicates_1.isDefined(squash) || squash == null) return defaultPolicy;
            if (squash === true || predicates_1.isString(squash)) return squash;
            throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
        }
        function getReplace(config, arrayMode, isOptional, squash) {
            var replace, configuredKeys, defaultPolicy = [ {
                from: "",
                to: isOptional || arrayMode ? undefined : ""
            }, {
                from: null,
                to: isOptional || arrayMode ? undefined : ""
            } ];
            replace = predicates_1.isArray(config.replace) ? config.replace : [];
            if (predicates_1.isString(squash)) replace.push({
                from: squash,
                to: undefined
            });
            configuredKeys = common_1.map(replace, hof_1.prop("from"));
            return common_1.filter(defaultPolicy, function(item) {
                return configuredKeys.indexOf(item.from) === -1;
            }).concat(replace);
        }
        var Param = function() {
            function Param(id, type, config, location, urlMatcherFactory) {
                config = unwrapShorthand(config);
                type = getType(config, type, location, id, urlMatcherFactory.paramTypes);
                var arrayMode = getArrayMode();
                type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
                var isOptional = config.value !== undefined || location === DefType.SEARCH;
                var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;
                var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;
                var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());
                var replace = getReplace(config, arrayMode, isOptional, squash);
                var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
                function getArrayMode() {
                    var arrayDefaults = {
                        array: location === DefType.SEARCH ? "auto" : false
                    };
                    var arrayParamNomenclature = id.match(/\[\]$/) ? {
                        array: true
                    } : {};
                    return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;
                }
                common_1.extend(this, {
                    id: id,
                    type: type,
                    location: location,
                    isOptional: isOptional,
                    dynamic: dynamic,
                    raw: raw,
                    squash: squash,
                    replace: replace,
                    inherit: inherit,
                    array: arrayMode,
                    config: config
                });
            }
            Param.prototype.isDefaultValue = function(value) {
                return this.isOptional && this.type.equals(this.value(), value);
            };
            Param.prototype.value = function(value) {
                var _this = this;
                var getDefaultValue = function() {
                    if (_this._defaultValueCache) return _this._defaultValueCache.defaultValue;
                    if (!coreservices_1.services.$injector) throw new Error("Injectable functions cannot be called at configuration time");
                    var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);
                    if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
                    if (_this.config.$$fn["__cacheable"]) {
                        _this._defaultValueCache = {
                            defaultValue: defaultValue
                        };
                    }
                    return defaultValue;
                };
                var replaceSpecialValues = function(val) {
                    for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                        var tuple = _a[_i];
                        if (tuple.from === val) return tuple.to;
                    }
                    return val;
                };
                value = replaceSpecialValues(value);
                return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
            };
            Param.prototype.isSearch = function() {
                return this.location === DefType.SEARCH;
            };
            Param.prototype.validates = function(value) {
                if ((predicates_1.isUndefined(value) || value === null) && this.isOptional) return true;
                var normalized = this.type.$normalize(value);
                if (!this.type.is(normalized)) return false;
                var encoded = this.type.encode(normalized);
                return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));
            };
            Param.prototype.toString = function() {
                return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
            };
            Param.values = function(params, values) {
                if (values === void 0) {
                    values = {};
                }
                var paramValues = {};
                for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                    var param = params_1[_i];
                    paramValues[param.id] = param.value(values[param.id]);
                }
                return paramValues;
            };
            Param.changed = function(params, values1, values2) {
                if (values1 === void 0) {
                    values1 = {};
                }
                if (values2 === void 0) {
                    values2 = {};
                }
                return params.filter(function(param) {
                    return !param.type.equals(values1[param.id], values2[param.id]);
                });
            };
            Param.equals = function(params, values1, values2) {
                if (values1 === void 0) {
                    values1 = {};
                }
                if (values2 === void 0) {
                    values2 = {};
                }
                return Param.changed(params, values1, values2).length === 0;
            };
            Param.validates = function(params, values) {
                if (values === void 0) {
                    values = {};
                }
                return params.map(function(param) {
                    return param.validates(values[param.id]);
                }).reduce(common_1.allTrueR, true);
            };
            return Param;
        }();
        exports.Param = Param;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/hof": 18,
        "../common/predicates": 20,
        "./paramType": 39
    } ],
    39: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var ParamType = function() {
            function ParamType(def) {
                this.pattern = /.*/;
                this.inherit = true;
                common_1.extend(this, def);
            }
            ParamType.prototype.is = function(val, key) {
                return true;
            };
            ParamType.prototype.encode = function(val, key) {
                return val;
            };
            ParamType.prototype.decode = function(val, key) {
                return val;
            };
            ParamType.prototype.equals = function(a, b) {
                return a == b;
            };
            ParamType.prototype.$subPattern = function() {
                var sub = this.pattern.toString();
                return sub.substr(1, sub.length - 2);
            };
            ParamType.prototype.toString = function() {
                return "{ParamType:" + this.name + "}";
            };
            ParamType.prototype.$normalize = function(val) {
                return this.is(val) ? val : this.decode(val);
            };
            ParamType.prototype.$asArray = function(mode, isSearch) {
                if (!mode) return this;
                if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
                return new ArrayType(this, mode);
            };
            return ParamType;
        }();
        exports.ParamType = ParamType;
        function ArrayType(type, mode) {
            var _this = this;
            function arrayWrap(val) {
                return predicates_1.isArray(val) ? val : predicates_1.isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return mode === "auto" ? val[0] : val;

                  default:
                    return val;
                }
            }
            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    if (predicates_1.isArray(val) && val.length === 0) return val;
                    var arr = arrayWrap(val);
                    var result = common_1.map(arr, callback);
                    return allTruthyMode === true ? common_1.filter(result, function(x) {
                        return !x;
                    }).length === 0 : arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return false;
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i])) return false;
                    }
                    return true;
                };
            }
            [ "encode", "decode", "equals", "$normalize" ].forEach(function(name) {
                var paramTypeFn = type[name].bind(type);
                var wrapperFn = name === "equals" ? arrayEqualsHandler : arrayHandler;
                _this[name] = wrapperFn(paramTypeFn);
            });
            common_1.extend(this, {
                dynamic: type.dynamic,
                name: type.name,
                pattern: type.pattern,
                inherit: type.inherit,
                is: arrayHandler(type.is.bind(type), true),
                $arrayMode: mode
            });
        }
    }, {
        "../common/common": 15,
        "../common/predicates": 20
    } ],
    40: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var hof_1 = require("../common/hof");
        var coreservices_1 = require("../common/coreservices");
        var paramType_1 = require("./paramType");
        var ParamTypes = function() {
            function ParamTypes() {
                this.enqueue = true;
                this.typeQueue = [];
                this.defaultTypes = common_1.pick(ParamTypes.prototype, [ "hash", "string", "query", "path", "int", "bool", "date", "json", "any" ]);
                var makeType = function(definition, name) {
                    return new paramType_1.ParamType(common_1.extend({
                        name: name
                    }, definition));
                };
                this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});
            }
            ParamTypes.prototype.dispose = function() {
                this.types = {};
            };
            ParamTypes.prototype.type = function(name, definition, definitionFn) {
                if (!predicates_1.isDefined(definition)) return this.types[name];
                if (this.types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
                this.types[name] = new paramType_1.ParamType(common_1.extend({
                    name: name
                }, definition));
                if (definitionFn) {
                    this.typeQueue.push({
                        name: name,
                        def: definitionFn
                    });
                    if (!this.enqueue) this._flushTypeQueue();
                }
                return this;
            };
            ParamTypes.prototype._flushTypeQueue = function() {
                while (this.typeQueue.length) {
                    var type = this.typeQueue.shift();
                    if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                    common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));
                }
            };
            return ParamTypes;
        }();
        exports.ParamTypes = ParamTypes;
        function initDefaultTypes() {
            var makeDefaultType = function(def) {
                var valToString = function(val) {
                    return val != null ? val.toString() : val;
                };
                var defaultTypeBase = {
                    encode: valToString,
                    decode: valToString,
                    is: hof_1.is(String),
                    pattern: /.*/,
                    equals: function(a, b) {
                        return a == b;
                    }
                };
                return common_1.extend({}, defaultTypeBase, def);
            };
            common_1.extend(ParamTypes.prototype, {
                string: makeDefaultType({}),
                path: makeDefaultType({
                    pattern: /[^\/]*/
                }),
                query: makeDefaultType({}),
                hash: makeDefaultType({
                    inherit: false
                }),
                int: makeDefaultType({
                    decode: function(val) {
                        return parseInt(val, 10);
                    },
                    is: function(val) {
                        return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;
                    },
                    pattern: /-?\d+/
                }),
                bool: makeDefaultType({
                    encode: function(val) {
                        return val && 1 || 0;
                    },
                    decode: function(val) {
                        return parseInt(val, 10) !== 0;
                    },
                    is: hof_1.is(Boolean),
                    pattern: /0|1/
                }),
                date: makeDefaultType({
                    encode: function(val) {
                        return !this.is(val) ? undefined : [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-");
                    },
                    decode: function(val) {
                        if (this.is(val)) return val;
                        var match = this.capture.exec(val);
                        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                    },
                    is: function(val) {
                        return val instanceof Date && !isNaN(val.valueOf());
                    },
                    equals: function(l, r) {
                        return [ "getFullYear", "getMonth", "getDate" ].reduce(function(acc, fn) {
                            return acc && l[fn]() === r[fn]();
                        }, true);
                    },
                    pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                    capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
                }),
                json: makeDefaultType({
                    encode: common_1.toJson,
                    decode: common_1.fromJson,
                    is: hof_1.is(Object),
                    equals: common_1.equals,
                    pattern: /[^\/]*/
                }),
                any: makeDefaultType({
                    encode: common_1.identity,
                    decode: common_1.identity,
                    is: function() {
                        return true;
                    },
                    equals: common_1.equals
                })
            });
        }
        initDefaultTypes();
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/hof": 18,
        "../common/predicates": 20,
        "./paramType": 39
    } ],
    41: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var StateParams = function() {
            function StateParams(params) {
                if (params === void 0) {
                    params = {};
                }
                common_1.extend(this, params);
            }
            StateParams.prototype.$inherit = function(newParams, $current, $to) {
                var parents = common_1.ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
                for (var i in parents) {
                    if (!parents[i] || !parents[i].params) continue;
                    parentParams = Object.keys(parents[i].params);
                    if (!parentParams.length) continue;
                    for (var j in parentParams) {
                        if (inheritList.indexOf(parentParams[j]) >= 0) continue;
                        inheritList.push(parentParams[j]);
                        inherited[parentParams[j]] = this[parentParams[j]];
                    }
                }
                return common_1.extend({}, inherited, newParams);
            };
            return StateParams;
        }();
        exports.StateParams = StateParams;
    }, {
        "../common/common": 15
    } ],
    42: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./pathNode"));
        __export(require("./pathFactory"));
    }, {
        "./pathFactory": 43,
        "./pathNode": 44
    } ],
    43: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var targetState_1 = require("../state/targetState");
        var pathNode_1 = require("./pathNode");
        var PathUtils = function() {
            function PathUtils() {}
            PathUtils.makeTargetState = function(path) {
                var state = common_1.tail(path).state;
                return new targetState_1.TargetState(state, state, path.map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}));
            };
            PathUtils.buildPath = function(targetState) {
                var toParams = targetState.params();
                return targetState.$state().path.map(function(state) {
                    return new pathNode_1.PathNode(state).applyRawParams(toParams);
                });
            };
            PathUtils.buildToPath = function(fromPath, targetState) {
                var toPath = PathUtils.buildPath(targetState);
                if (targetState.options().inherit) {
                    return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));
                }
                return toPath;
            };
            PathUtils.applyViewConfigs = function($view, path, states) {
                path.filter(function(node) {
                    return common_1.inArray(states, node.state);
                }).forEach(function(node) {
                    var viewDecls = common_1.values(node.state.views || {});
                    var subPath = PathUtils.subPath(path, function(n) {
                        return n === node;
                    });
                    var viewConfigs = viewDecls.map(function(view) {
                        return $view.createViewConfig(subPath, view);
                    });
                    node.views = viewConfigs.reduce(common_1.unnestR, []);
                });
            };
            PathUtils.inheritParams = function(fromPath, toPath, toKeys) {
                if (toKeys === void 0) {
                    toKeys = [];
                }
                function nodeParamVals(path, state) {
                    var node = common_1.find(path, hof_1.propEq("state", state));
                    return common_1.extend({}, node && node.paramValues);
                }
                var noInherit = fromPath.map(function(node) {
                    return node.paramSchema;
                }).reduce(common_1.unnestR, []).filter(function(param) {
                    return !param.inherit;
                }).map(hof_1.prop("id"));
                function makeInheritedParamsNode(toNode) {
                    var toParamVals = common_1.extend({}, toNode && toNode.paramValues);
                    var incomingParamVals = common_1.pick(toParamVals, toKeys);
                    toParamVals = common_1.omit(toParamVals, toKeys);
                    var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);
                    var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);
                    return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);
                }
                return toPath.map(makeInheritedParamsNode);
            };
            PathUtils.treeChanges = function(fromPath, toPath, reloadState) {
                var keep = 0, max = Math.min(fromPath.length, toPath.length);
                var nodesMatch = function(node1, node2) {
                    return node1.equals(node2, PathUtils.nonDynamicParams);
                };
                while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {
                    keep++;
                }
                function applyToParams(retainedNode, idx) {
                    var cloned = pathNode_1.PathNode.clone(retainedNode);
                    cloned.paramValues = toPath[idx].paramValues;
                    return cloned;
                }
                var from, retained, exiting, entering, to;
                from = fromPath;
                retained = from.slice(0, keep);
                exiting = from.slice(keep);
                var retainedWithToParams = retained.map(applyToParams);
                entering = toPath.slice(keep);
                to = retainedWithToParams.concat(entering);
                return {
                    from: from,
                    to: to,
                    retained: retained,
                    exiting: exiting,
                    entering: entering
                };
            };
            PathUtils.matching = function(pathA, pathB, paramsFn) {
                var done = false;
                var tuples = common_1.arrayTuples(pathA, pathB);
                return tuples.reduce(function(matching, _a) {
                    var nodeA = _a[0], nodeB = _a[1];
                    done = done || !nodeA.equals(nodeB, paramsFn);
                    return done ? matching : matching.concat(nodeA);
                }, []);
            };
            PathUtils.equals = function(pathA, pathB, paramsFn) {
                return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
            };
            PathUtils.subPath = function(path, predicate) {
                var node = common_1.find(path, predicate);
                var elementIdx = path.indexOf(node);
                return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
            };
            return PathUtils;
        }();
        PathUtils.nonDynamicParams = function(node) {
            return node.state.parameters({
                inherit: false
            }).filter(function(param) {
                return !param.dynamic;
            });
        };
        PathUtils.paramValues = function(path) {
            return path.reduce(function(acc, node) {
                return common_1.extend(acc, node.paramValues);
            }, {});
        };
        exports.PathUtils = PathUtils;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../state/targetState": 57,
        "./pathNode": 44
    } ],
    44: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var param_1 = require("../params/param");
        var PathNode = function() {
            function PathNode(stateOrNode) {
                if (stateOrNode instanceof PathNode) {
                    var node = stateOrNode;
                    this.state = node.state;
                    this.paramSchema = node.paramSchema.slice();
                    this.paramValues = common_1.extend({}, node.paramValues);
                    this.resolvables = node.resolvables.slice();
                    this.views = node.views && node.views.slice();
                } else {
                    var state = stateOrNode;
                    this.state = state;
                    this.paramSchema = state.parameters({
                        inherit: false
                    });
                    this.paramValues = {};
                    this.resolvables = state.resolvables.map(function(res) {
                        return res.clone();
                    });
                }
            }
            PathNode.prototype.applyRawParams = function(params) {
                var getParamVal = function(paramDef) {
                    return [ paramDef.id, paramDef.value(params[paramDef.id]) ];
                };
                this.paramValues = this.paramSchema.reduce(function(memo, pDef) {
                    return common_1.applyPairs(memo, getParamVal(pDef));
                }, {});
                return this;
            };
            PathNode.prototype.parameter = function(name) {
                return common_1.find(this.paramSchema, hof_1.propEq("id", name));
            };
            PathNode.prototype.equals = function(node, paramsFn) {
                var diff = this.diff(node, paramsFn);
                return diff && diff.length === 0;
            };
            PathNode.prototype.diff = function(node, paramsFn) {
                if (this.state !== node.state) return false;
                var params = paramsFn ? paramsFn(this) : this.paramSchema;
                return param_1.Param.changed(params, this.paramValues, node.paramValues);
            };
            PathNode.clone = function(node) {
                return new PathNode(node);
            };
            return PathNode;
        }();
        exports.PathNode = PathNode;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../params/param": 38
    } ],
    45: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./interface"));
        __export(require("./resolvable"));
        __export(require("./resolveContext"));
    }, {
        "./interface": 46,
        "./resolvable": 47,
        "./resolveContext": 48
    } ],
    46: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.resolvePolicies = {
            when: {
                LAZY: "LAZY",
                EAGER: "EAGER"
            },
            async: {
                WAIT: "WAIT",
                NOWAIT: "NOWAIT",
                RXWAIT: "RXWAIT"
            }
        };
    }, {} ],
    47: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var coreservices_1 = require("../common/coreservices");
        var trace_1 = require("../common/trace");
        var strings_1 = require("../common/strings");
        var predicates_1 = require("../common/predicates");
        exports.defaultResolvePolicy = {
            when: "LAZY",
            async: "WAIT"
        };
        var Resolvable = function() {
            function Resolvable(arg1, resolveFn, deps, policy, data) {
                this.resolved = false;
                this.promise = undefined;
                if (arg1 instanceof Resolvable) {
                    common_1.extend(this, arg1);
                } else if (predicates_1.isFunction(resolveFn)) {
                    if (arg1 == null || arg1 == undefined) throw new Error("new Resolvable(): token argument is required");
                    if (!predicates_1.isFunction(resolveFn)) throw new Error("new Resolvable(): resolveFn argument must be a function");
                    this.token = arg1;
                    this.policy = policy;
                    this.resolveFn = resolveFn;
                    this.deps = deps || [];
                    this.data = data;
                    this.resolved = data !== undefined;
                    this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;
                } else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {
                    var literal = arg1;
                    return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
                }
            }
            Resolvable.prototype.getPolicy = function(state) {
                var thisPolicy = this.policy || {};
                var statePolicy = state && state.resolvePolicy || {};
                return {
                    when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,
                    async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async
                };
            };
            Resolvable.prototype.resolve = function(resolveContext, trans) {
                var _this = this;
                var $q = coreservices_1.services.$q;
                var getResolvableDependencies = function() {
                    return $q.all(resolveContext.getDependencies(_this).map(function(resolvable) {
                        return resolvable.get(resolveContext, trans);
                    }));
                };
                var invokeResolveFn = function(resolvedDeps) {
                    return _this.resolveFn.apply(null, resolvedDeps);
                };
                var waitForRx = function(observable$) {
                    var cached = observable$.cache(1);
                    return cached.take(1).toPromise().then(function() {
                        return cached;
                    });
                };
                var node = resolveContext.findNode(this);
                var state = node && node.state;
                var maybeWaitForRx = this.getPolicy(state).async === "RXWAIT" ? waitForRx : common_1.identity;
                var applyResolvedValue = function(resolvedValue) {
                    _this.data = resolvedValue;
                    _this.resolved = true;
                    trace_1.trace.traceResolvableResolved(_this, trans);
                    return _this.data;
                };
                return this.promise = $q.when().then(getResolvableDependencies).then(invokeResolveFn).then(maybeWaitForRx).then(applyResolvedValue);
            };
            Resolvable.prototype.get = function(resolveContext, trans) {
                return this.promise || this.resolve(resolveContext, trans);
            };
            Resolvable.prototype.toString = function() {
                return "Resolvable(token: " + strings_1.stringify(this.token) + ", requires: [" + this.deps.map(strings_1.stringify) + "])";
            };
            Resolvable.prototype.clone = function() {
                return new Resolvable(this);
            };
            return Resolvable;
        }();
        Resolvable.fromData = function(token, data) {
            return new Resolvable(token, function() {
                return data;
            }, null, null, data);
        };
        exports.Resolvable = Resolvable;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/predicates": 20,
        "../common/strings": 22,
        "../common/trace": 23
    } ],
    48: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var trace_1 = require("../common/trace");
        var coreservices_1 = require("../common/coreservices");
        var interface_1 = require("./interface");
        var resolvable_1 = require("./resolvable");
        var pathFactory_1 = require("../path/pathFactory");
        var strings_1 = require("../common/strings");
        var when = interface_1.resolvePolicies.when;
        var ALL_WHENS = [ when.EAGER, when.LAZY ];
        var EAGER_WHENS = [ when.EAGER ];
        exports.NATIVE_INJECTOR_TOKEN = "Native Injector";
        var ResolveContext = function() {
            function ResolveContext(_path) {
                this._path = _path;
            }
            ResolveContext.prototype.getTokens = function() {
                return this._path.reduce(function(acc, node) {
                    return acc.concat(node.resolvables.map(function(r) {
                        return r.token;
                    }));
                }, []).reduce(common_1.uniqR, []);
            };
            ResolveContext.prototype.getResolvable = function(token) {
                var matching = this._path.map(function(node) {
                    return node.resolvables;
                }).reduce(common_1.unnestR, []).filter(function(r) {
                    return r.token === token;
                });
                return common_1.tail(matching);
            };
            ResolveContext.prototype.getPolicy = function(resolvable) {
                var node = this.findNode(resolvable);
                return resolvable.getPolicy(node.state);
            };
            ResolveContext.prototype.subContext = function(state) {
                return new ResolveContext(pathFactory_1.PathUtils.subPath(this._path, function(node) {
                    return node.state === state;
                }));
            };
            ResolveContext.prototype.addResolvables = function(newResolvables, state) {
                var node = common_1.find(this._path, hof_1.propEq("state", state));
                var keys = newResolvables.map(function(r) {
                    return r.token;
                });
                node.resolvables = node.resolvables.filter(function(r) {
                    return keys.indexOf(r.token) === -1;
                }).concat(newResolvables);
            };
            ResolveContext.prototype.resolvePath = function(when, trans) {
                var _this = this;
                if (when === void 0) {
                    when = "LAZY";
                }
                var whenOption = common_1.inArray(ALL_WHENS, when) ? when : "LAZY";
                var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
                trace_1.trace.traceResolvePath(this._path, when, trans);
                var matchesPolicy = function(acceptedVals, whenOrAsync) {
                    return function(resolvable) {
                        return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
                    };
                };
                var promises = this._path.reduce(function(acc, node) {
                    var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, "when"));
                    var nowait = nodeResolvables.filter(matchesPolicy([ "NOWAIT" ], "async"));
                    var wait = nodeResolvables.filter(hof_1.not(matchesPolicy([ "NOWAIT" ], "async")));
                    var subContext = _this.subContext(node.state);
                    var getResult = function(r) {
                        return r.get(subContext, trans).then(function(value) {
                            return {
                                token: r.token,
                                value: value
                            };
                        });
                    };
                    nowait.forEach(getResult);
                    return acc.concat(wait.map(getResult));
                }, []);
                return coreservices_1.services.$q.all(promises);
            };
            ResolveContext.prototype.injector = function() {
                return this._injector || (this._injector = new UIInjectorImpl(this));
            };
            ResolveContext.prototype.findNode = function(resolvable) {
                return common_1.find(this._path, function(node) {
                    return common_1.inArray(node.resolvables, resolvable);
                });
            };
            ResolveContext.prototype.getDependencies = function(resolvable) {
                var _this = this;
                var node = this.findNode(resolvable);
                var subPath = pathFactory_1.PathUtils.subPath(this._path, function(x) {
                    return x === node;
                }) || this._path;
                var availableResolvables = subPath.reduce(function(acc, node) {
                    return acc.concat(node.resolvables);
                }, []).filter(function(res) {
                    return res !== resolvable;
                });
                var getDependency = function(token) {
                    var matching = availableResolvables.filter(function(r) {
                        return r.token === token;
                    });
                    if (matching.length) return common_1.tail(matching);
                    var fromInjector = _this.injector().getNative(token);
                    if (!fromInjector) {
                        throw new Error("Could not find Dependency Injection token: " + strings_1.stringify(token));
                    }
                    return new resolvable_1.Resolvable(token, function() {
                        return fromInjector;
                    }, [], fromInjector);
                };
                return resolvable.deps.map(getDependency);
            };
            return ResolveContext;
        }();
        exports.ResolveContext = ResolveContext;
        var UIInjectorImpl = function() {
            function UIInjectorImpl(context) {
                this.context = context;
                this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;
            }
            UIInjectorImpl.prototype.get = function(token) {
                var resolvable = this.context.getResolvable(token);
                if (resolvable) {
                    if (this.context.getPolicy(resolvable).async === "NOWAIT") {
                        return resolvable.get(this.context);
                    }
                    if (!resolvable.resolved) {
                        throw new Error("Resolvable async .get() not complete:" + strings_1.stringify(resolvable.token));
                    }
                    return resolvable.data;
                }
                return this.native && this.native.get(token);
            };
            UIInjectorImpl.prototype.getAsync = function(token) {
                var resolvable = this.context.getResolvable(token);
                if (resolvable) return resolvable.get(this.context);
                return coreservices_1.services.$q.when(this.native.get(token));
            };
            UIInjectorImpl.prototype.getNative = function(token) {
                return this.native && this.native.get(token);
            };
            return UIInjectorImpl;
        }();
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/hof": 18,
        "../common/strings": 22,
        "../common/trace": 23,
        "../path/pathFactory": 43,
        "./interface": 46,
        "./resolvable": 47
    } ],
    49: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var urlMatcherFactory_1 = require("./url/urlMatcherFactory");
        var urlRouter_1 = require("./url/urlRouter");
        var transitionService_1 = require("./transition/transitionService");
        var view_1 = require("./view/view");
        var stateRegistry_1 = require("./state/stateRegistry");
        var stateService_1 = require("./state/stateService");
        var globals_1 = require("./globals");
        var common_1 = require("./common/common");
        var predicates_1 = require("./common/predicates");
        var urlService_1 = require("./url/urlService");
        var trace_1 = require("./common/trace");
        var _routerInstance = 0;
        var UIRouter = function() {
            function UIRouter(locationService, locationConfig) {
                if (locationService === void 0) {
                    locationService = urlService_1.UrlService.locationServiceStub;
                }
                if (locationConfig === void 0) {
                    locationConfig = urlService_1.UrlService.locationConfigStub;
                }
                this.locationService = locationService;
                this.locationConfig = locationConfig;
                this.$id = _routerInstance++;
                this._disposed = false;
                this._disposables = [];
                this.trace = trace_1.trace;
                this.viewService = new view_1.ViewService();
                this.transitionService = new transitionService_1.TransitionService(this);
                this.globals = new globals_1.UIRouterGlobals();
                this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();
                this.urlRouter = new urlRouter_1.UrlRouter(this);
                this.stateRegistry = new stateRegistry_1.StateRegistry(this);
                this.stateService = new stateService_1.StateService(this);
                this.urlService = new urlService_1.UrlService(this);
                this._plugins = {};
                this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());
                this.globals.$current = this.stateRegistry.root();
                this.globals.current = this.globals.$current.self;
                this.disposable(this.globals);
                this.disposable(this.stateService);
                this.disposable(this.stateRegistry);
                this.disposable(this.transitionService);
                this.disposable(this.urlRouter);
                this.disposable(locationService);
                this.disposable(locationConfig);
            }
            UIRouter.prototype.disposable = function(disposable) {
                this._disposables.push(disposable);
            };
            UIRouter.prototype.dispose = function(disposable) {
                var _this = this;
                if (disposable && predicates_1.isFunction(disposable.dispose)) {
                    disposable.dispose(this);
                    return undefined;
                }
                this._disposed = true;
                this._disposables.slice().forEach(function(d) {
                    try {
                        typeof d.dispose === "function" && d.dispose(_this);
                        common_1.removeFrom(_this._disposables, d);
                    } catch (ignored) {}
                });
            };
            UIRouter.prototype.plugin = function(plugin, options) {
                if (options === void 0) {
                    options = {};
                }
                var pluginInstance = new plugin(this, options);
                if (!pluginInstance.name) throw new Error("Required property `name` missing on plugin: " + pluginInstance);
                this._disposables.push(pluginInstance);
                return this._plugins[pluginInstance.name] = pluginInstance;
            };
            UIRouter.prototype.getPlugin = function(pluginName) {
                return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);
            };
            return UIRouter;
        }();
        exports.UIRouter = UIRouter;
    }, {
        "./common/common": 15,
        "./common/predicates": 20,
        "./common/trace": 23,
        "./globals": 24,
        "./state/stateRegistry": 55,
        "./state/stateService": 56,
        "./transition/transitionService": 66,
        "./url/urlMatcherFactory": 69,
        "./url/urlRouter": 70,
        "./url/urlService": 72,
        "./view/view": 86
    } ],
    50: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./stateBuilder"));
        __export(require("./stateObject"));
        __export(require("./stateMatcher"));
        __export(require("./stateQueueManager"));
        __export(require("./stateRegistry"));
        __export(require("./stateService"));
        __export(require("./targetState"));
    }, {
        "./stateBuilder": 51,
        "./stateMatcher": 52,
        "./stateObject": 53,
        "./stateQueueManager": 54,
        "./stateRegistry": 55,
        "./stateService": 56,
        "./targetState": 57
    } ],
    51: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var strings_1 = require("../common/strings");
        var hof_1 = require("../common/hof");
        var resolvable_1 = require("../resolve/resolvable");
        var coreservices_1 = require("../common/coreservices");
        var parseUrl = function(url) {
            if (!predicates_1.isString(url)) return false;
            var root = url.charAt(0) === "^";
            return {
                val: root ? url.substring(1) : url,
                root: root
            };
        };
        function nameBuilder(state) {
            return state.name;
        }
        function selfBuilder(state) {
            state.self.$$state = function() {
                return state;
            };
            return state.self;
        }
        function dataBuilder(state) {
            if (state.parent && state.parent.data) {
                state.data = state.self.data = common_1.inherit(state.parent.data, state.data);
            }
            return state.data;
        }
        var getUrlBuilder = function($urlMatcherFactoryProvider, root) {
            return function urlBuilder(state) {
                var stateDec = state;
                if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
                    stateDec.url += "{remainder:any}";
                }
                var parsed = parseUrl(stateDec.url), parent = state.parent;
                var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {
                    params: state.params || {},
                    paramMap: function(paramConfig, isSearch) {
                        if (stateDec.reloadOnSearch === false && isSearch) paramConfig = common_1.extend(paramConfig || {}, {
                            dynamic: true
                        });
                        return paramConfig;
                    }
                });
                if (!url) return null;
                if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error("Invalid url '" + url + "' in state '" + state + "'");
                return parsed && parsed.root ? url : (parent && parent.navigable || root()).url.append(url);
            };
        };
        var getNavigableBuilder = function(isRoot) {
            return function navigableBuilder(state) {
                return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;
            };
        };
        var getParamsBuilder = function(paramFactory) {
            return function paramsBuilder(state) {
                var makeConfigParam = function(config, id) {
                    return paramFactory.fromConfig(id, null, config);
                };
                var urlParams = state.url && state.url.parameters({
                    inherit: false
                }) || [];
                var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop("id"))), makeConfigParam));
                return urlParams.concat(nonUrlParams).map(function(p) {
                    return [ p.id, p ];
                }).reduce(common_1.applyPairs, {});
            };
        };
        function pathBuilder(state) {
            return state.parent ? state.parent.path.concat(state) : [ state ];
        }
        function includesBuilder(state) {
            var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};
            includes[state.name] = true;
            return includes;
        }
        function resolvablesBuilder(state) {
            var objects2Tuples = function(resolveObj, resolvePolicies) {
                return Object.keys(resolveObj || {}).map(function(token) {
                    return {
                        token: token,
                        val: resolveObj[token],
                        deps: undefined,
                        policy: resolvePolicies[token]
                    };
                });
            };
            var annotate = function(fn) {
                var $injector = coreservices_1.services.$injector;
                return fn["$inject"] || $injector && $injector.annotate(fn, $injector.strictDi) || "deferred";
            };
            var isResolveLiteral = function(obj) {
                return !!(obj.token && obj.resolveFn);
            };
            var isLikeNg2Provider = function(obj) {
                return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));
            };
            var isTupleFromObj = function(obj) {
                return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val)));
            };
            var token = function(p) {
                return p.provide || p.token;
            };
            var literal2Resolvable = hof_1.pattern([ [ hof_1.prop("resolveFn"), function(p) {
                return new resolvable_1.Resolvable(token(p), p.resolveFn, p.deps, p.policy);
            } ], [ hof_1.prop("useFactory"), function(p) {
                return new resolvable_1.Resolvable(token(p), p.useFactory, p.deps || p.dependencies, p.policy);
            } ], [ hof_1.prop("useClass"), function(p) {
                return new resolvable_1.Resolvable(token(p), function() {
                    return new p.useClass();
                }, [], p.policy);
            } ], [ hof_1.prop("useValue"), function(p) {
                return new resolvable_1.Resolvable(token(p), function() {
                    return p.useValue;
                }, [], p.policy, p.useValue);
            } ], [ hof_1.prop("useExisting"), function(p) {
                return new resolvable_1.Resolvable(token(p), common_1.identity, [ p.useExisting ], p.policy);
            } ] ]);
            var tuple2Resolvable = hof_1.pattern([ [ hof_1.pipe(hof_1.prop("val"), predicates_1.isString), function(tuple) {
                return new resolvable_1.Resolvable(tuple.token, common_1.identity, [ tuple.val ], tuple.policy);
            } ], [ hof_1.pipe(hof_1.prop("val"), predicates_1.isArray), function(tuple) {
                return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy);
            } ], [ hof_1.pipe(hof_1.prop("val"), predicates_1.isFunction), function(tuple) {
                return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy);
            } ] ]);
            var item2Resolvable = hof_1.pattern([ [ hof_1.is(resolvable_1.Resolvable), function(r) {
                return r;
            } ], [ isResolveLiteral, literal2Resolvable ], [ isLikeNg2Provider, literal2Resolvable ], [ isTupleFromObj, tuple2Resolvable ], [ hof_1.val(true), function(obj) {
                throw new Error("Invalid resolve value: " + strings_1.stringify(obj));
            } ] ]);
            var decl = state.resolve;
            var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
            return items.map(item2Resolvable);
        }
        exports.resolvablesBuilder = resolvablesBuilder;
        var StateBuilder = function() {
            function StateBuilder(matcher, urlMatcherFactory) {
                this.matcher = matcher;
                var self = this;
                var root = function() {
                    return matcher.find("");
                };
                var isRoot = function(state) {
                    return state.name === "";
                };
                function parentBuilder(state) {
                    if (isRoot(state)) return null;
                    return matcher.find(self.parentName(state)) || root();
                }
                this.builders = {
                    name: [ nameBuilder ],
                    self: [ selfBuilder ],
                    parent: [ parentBuilder ],
                    data: [ dataBuilder ],
                    url: [ getUrlBuilder(urlMatcherFactory, root) ],
                    navigable: [ getNavigableBuilder(isRoot) ],
                    params: [ getParamsBuilder(urlMatcherFactory.paramFactory) ],
                    views: [],
                    path: [ pathBuilder ],
                    includes: [ includesBuilder ],
                    resolvables: [ resolvablesBuilder ]
                };
            }
            StateBuilder.prototype.builder = function(name, fn) {
                var builders = this.builders;
                var array = builders[name] || [];
                if (predicates_1.isString(name) && !predicates_1.isDefined(fn)) return array.length > 1 ? array : array[0];
                if (!predicates_1.isString(name) || !predicates_1.isFunction(fn)) return;
                builders[name] = array;
                builders[name].push(fn);
                return function() {
                    return builders[name].splice(builders[name].indexOf(fn, 1)) && null;
                };
            };
            StateBuilder.prototype.build = function(state) {
                var _a = this, matcher = _a.matcher, builders = _a.builders;
                var parent = this.parentName(state);
                if (parent && !matcher.find(parent, undefined, false)) {
                    return null;
                }
                for (var key in builders) {
                    if (!builders.hasOwnProperty(key)) continue;
                    var chain = builders[key].reduce(function(parentFn, step) {
                        return function(_state) {
                            return step(_state, parentFn);
                        };
                    }, common_1.noop);
                    state[key] = chain(state);
                }
                return state;
            };
            StateBuilder.prototype.parentName = function(state) {
                var name = state.name || "";
                var segments = name.split(".");
                if (segments.length > 1) {
                    if (state.parent) {
                        throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
                    }
                    var lastSegment = segments.pop();
                    if (lastSegment === "**") segments.pop();
                    return segments.join(".");
                }
                if (!state.parent) return "";
                return predicates_1.isString(state.parent) ? state.parent : state.parent.name;
            };
            StateBuilder.prototype.name = function(state) {
                var name = state.name;
                if (name.indexOf(".") !== -1 || !state.parent) return name;
                var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;
                return parentName ? parentName + "." + name : name;
            };
            return StateBuilder;
        }();
        exports.StateBuilder = StateBuilder;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../common/strings": 22,
        "../resolve/resolvable": 47
    } ],
    52: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var predicates_1 = require("../common/predicates");
        var common_1 = require("../common/common");
        var StateMatcher = function() {
            function StateMatcher(_states) {
                this._states = _states;
            }
            StateMatcher.prototype.isRelative = function(stateName) {
                stateName = stateName || "";
                return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
            };
            StateMatcher.prototype.find = function(stateOrName, base, matchGlob) {
                if (matchGlob === void 0) {
                    matchGlob = true;
                }
                if (!stateOrName && stateOrName !== "") return undefined;
                var isStr = predicates_1.isString(stateOrName);
                var name = isStr ? stateOrName : stateOrName.name;
                if (this.isRelative(name)) name = this.resolvePath(name, base);
                var state = this._states[name];
                if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                    return state;
                } else if (isStr && matchGlob) {
                    var _states = common_1.values(this._states);
                    var matches = _states.filter(function(state) {
                        return state.__stateObjectCache.nameGlob && state.__stateObjectCache.nameGlob.matches(name);
                    });
                    if (matches.length > 1) {
                        console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function(match) {
                            return match.name;
                        }));
                    }
                    return matches[0];
                }
                return undefined;
            };
            StateMatcher.prototype.resolvePath = function(name, base) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                var baseState = this.find(base);
                var splitName = name.split("."), i = 0, pathLength = splitName.length, current = baseState;
                for (;i < pathLength; i++) {
                    if (splitName[i] === "" && i === 0) {
                        current = baseState;
                        continue;
                    }
                    if (splitName[i] === "^") {
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                        current = current.parent;
                        continue;
                    }
                    break;
                }
                var relName = splitName.slice(i).join(".");
                return current.name + (current.name && relName ? "." : "") + relName;
            };
            return StateMatcher;
        }();
        exports.StateMatcher = StateMatcher;
    }, {
        "../common/common": 15,
        "../common/predicates": 20
    } ],
    53: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var glob_1 = require("../common/glob");
        var predicates_1 = require("../common/predicates");
        var StateObject = function() {
            function StateObject(config) {
                return StateObject.create(config || {});
            }
            StateObject.create = function(stateDecl) {
                stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
                var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));
                stateDecl.$$state = function() {
                    return state;
                };
                state.self = stateDecl;
                state.__stateObjectCache = {
                    nameGlob: glob_1.Glob.fromString(state.name)
                };
                return state;
            };
            StateObject.prototype.is = function(ref) {
                return this === ref || this.self === ref || this.fqn() === ref;
            };
            StateObject.prototype.fqn = function() {
                if (!this.parent || !(this.parent instanceof this.constructor)) return this.name;
                var name = this.parent.fqn();
                return name ? name + "." + this.name : this.name;
            };
            StateObject.prototype.root = function() {
                return this.parent && this.parent.root() || this;
            };
            StateObject.prototype.parameters = function(opts) {
                opts = common_1.defaults(opts, {
                    inherit: true,
                    matchingKeys: null
                });
                var inherited = opts.inherit && this.parent && this.parent.parameters() || [];
                return inherited.concat(common_1.values(this.params)).filter(function(param) {
                    return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id);
                });
            };
            StateObject.prototype.parameter = function(id, opts) {
                if (opts === void 0) {
                    opts = {};
                }
                return this.url && this.url.parameter(id, opts) || common_1.find(common_1.values(this.params), hof_1.propEq("id", id)) || opts.inherit && this.parent && this.parent.parameter(id);
            };
            StateObject.prototype.toString = function() {
                return this.fqn();
            };
            return StateObject;
        }();
        StateObject.isStateClass = function(stateDecl) {
            return predicates_1.isFunction(stateDecl) && stateDecl["__uiRouterState"] === true;
        };
        StateObject.isState = function(obj) {
            return predicates_1.isObject(obj["__stateObjectCache"]);
        };
        exports.StateObject = StateObject;
    }, {
        "../common/common": 15,
        "../common/glob": 17,
        "../common/hof": 18,
        "../common/predicates": 20
    } ],
    54: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var stateObject_1 = require("./stateObject");
        var hof_1 = require("../common/hof");
        var StateQueueManager = function() {
            function StateQueueManager($registry, $urlRouter, states, builder, listeners) {
                this.$registry = $registry;
                this.$urlRouter = $urlRouter;
                this.states = states;
                this.builder = builder;
                this.listeners = listeners;
                this.queue = [];
                this.matcher = $registry.matcher;
            }
            StateQueueManager.prototype.dispose = function() {
                this.queue = [];
            };
            StateQueueManager.prototype.register = function(stateDecl) {
                var queue = this.queue;
                var state = stateObject_1.StateObject.create(stateDecl);
                var name = state.name;
                if (!predicates_1.isString(name)) throw new Error("State must have a valid name");
                if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop("name")), name)) throw new Error("State '" + name + "' is already defined");
                queue.push(state);
                this.flush();
                return state;
            };
            StateQueueManager.prototype.flush = function() {
                var _this = this;
                var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;
                var registered = [], orphans = [], previousQueueLength = {};
                var getState = function(name) {
                    return _this.states.hasOwnProperty(name) && _this.states[name];
                };
                while (queue.length > 0) {
                    var state = queue.shift();
                    var name_1 = state.name;
                    var result = builder.build(state);
                    var orphanIdx = orphans.indexOf(state);
                    if (result) {
                        var existingState = getState(name_1);
                        if (existingState && existingState.name === name_1) {
                            throw new Error("State '" + name_1 + "' is already defined");
                        }
                        var existingFutureState = getState(name_1 + ".**");
                        if (existingFutureState) {
                            this.$registry.deregister(existingFutureState);
                        }
                        states[name_1] = state;
                        this.attachRoute(state);
                        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);
                        registered.push(state);
                        continue;
                    }
                    var prev = previousQueueLength[name_1];
                    previousQueueLength[name_1] = queue.length;
                    if (orphanIdx >= 0 && prev === queue.length) {
                        queue.push(state);
                        return states;
                    } else if (orphanIdx < 0) {
                        orphans.push(state);
                    }
                    queue.push(state);
                }
                if (registered.length) {
                    this.listeners.forEach(function(listener) {
                        return listener("registered", registered.map(function(s) {
                            return s.self;
                        }));
                    });
                }
                return states;
            };
            StateQueueManager.prototype.attachRoute = function(state) {
                if (state.abstract || !state.url) return;
                this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));
            };
            return StateQueueManager;
        }();
        exports.StateQueueManager = StateQueueManager;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/predicates": 20,
        "./stateObject": 53
    } ],
    55: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var stateMatcher_1 = require("./stateMatcher");
        var stateBuilder_1 = require("./stateBuilder");
        var stateQueueManager_1 = require("./stateQueueManager");
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var StateRegistry = function() {
            function StateRegistry(_router) {
                this._router = _router;
                this.states = {};
                this.listeners = [];
                this.matcher = new stateMatcher_1.StateMatcher(this.states);
                this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);
                this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);
                this._registerRoot();
            }
            StateRegistry.prototype._registerRoot = function() {
                var rootStateDef = {
                    name: "",
                    url: "^",
                    views: null,
                    params: {
                        "#": {
                            value: null,
                            type: "hash",
                            dynamic: true
                        }
                    },
                    abstract: true
                };
                var _root = this._root = this.stateQueue.register(rootStateDef);
                _root.navigable = null;
            };
            StateRegistry.prototype.dispose = function() {
                var _this = this;
                this.stateQueue.dispose();
                this.listeners = [];
                this.get().forEach(function(state) {
                    return _this.get(state) && _this.deregister(state);
                });
            };
            StateRegistry.prototype.onStatesChanged = function(listener) {
                this.listeners.push(listener);
                return function deregisterListener() {
                    common_1.removeFrom(this.listeners)(listener);
                }.bind(this);
            };
            StateRegistry.prototype.root = function() {
                return this._root;
            };
            StateRegistry.prototype.register = function(stateDefinition) {
                return this.stateQueue.register(stateDefinition);
            };
            StateRegistry.prototype._deregisterTree = function(state) {
                var _this = this;
                var all = this.get().map(function(s) {
                    return s.$$state();
                });
                var getChildren = function(states) {
                    var children = all.filter(function(s) {
                        return states.indexOf(s.parent) !== -1;
                    });
                    return children.length === 0 ? children : children.concat(getChildren(children));
                };
                var children = getChildren([ state ]);
                var deregistered = [ state ].concat(children).reverse();
                deregistered.forEach(function(state) {
                    var $ur = _this._router.urlRouter;
                    $ur.rules().filter(hof_1.propEq("state", state)).forEach($ur.removeRule.bind($ur));
                    delete _this.states[state.name];
                });
                return deregistered;
            };
            StateRegistry.prototype.deregister = function(stateOrName) {
                var _state = this.get(stateOrName);
                if (!_state) throw new Error("Can't deregister state; not found: " + stateOrName);
                var deregisteredStates = this._deregisterTree(_state.$$state());
                this.listeners.forEach(function(listener) {
                    return listener("deregistered", deregisteredStates.map(function(s) {
                        return s.self;
                    }));
                });
                return deregisteredStates;
            };
            StateRegistry.prototype.get = function(stateOrName, base) {
                var _this = this;
                if (arguments.length === 0) return Object.keys(this.states).map(function(name) {
                    return _this.states[name].self;
                });
                var found = this.matcher.find(stateOrName, base);
                return found && found.self || null;
            };
            StateRegistry.prototype.decorator = function(name, func) {
                return this.builder.builder(name, func);
            };
            return StateRegistry;
        }();
        exports.StateRegistry = StateRegistry;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "./stateBuilder": 51,
        "./stateMatcher": 52,
        "./stateQueueManager": 54
    } ],
    56: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var queue_1 = require("../common/queue");
        var coreservices_1 = require("../common/coreservices");
        var pathFactory_1 = require("../path/pathFactory");
        var pathNode_1 = require("../path/pathNode");
        var transitionService_1 = require("../transition/transitionService");
        var rejectFactory_1 = require("../transition/rejectFactory");
        var targetState_1 = require("./targetState");
        var param_1 = require("../params/param");
        var glob_1 = require("../common/glob");
        var resolveContext_1 = require("../resolve/resolveContext");
        var lazyLoad_1 = require("../hooks/lazyLoad");
        var hof_1 = require("../common/hof");
        var StateService = function() {
            function StateService(router) {
                this.router = router;
                this.invalidCallbacks = [];
                this._defaultErrorHandler = function $defaultErrorHandler($error$) {
                    if ($error$ instanceof Error && $error$.stack) {
                        console.error($error$);
                        console.error($error$.stack);
                    } else if ($error$ instanceof rejectFactory_1.Rejection) {
                        console.error($error$.toString());
                        if ($error$.detail && $error$.detail.stack) console.error($error$.detail.stack);
                    } else {
                        console.error($error$);
                    }
                };
                var getters = [ "current", "$current", "params", "transition" ];
                var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));
                common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);
            }
            Object.defineProperty(StateService.prototype, "transition", {
                get: function() {
                    return this.router.globals.transition;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(StateService.prototype, "params", {
                get: function() {
                    return this.router.globals.params;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(StateService.prototype, "current", {
                get: function() {
                    return this.router.globals.current;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(StateService.prototype, "$current", {
                get: function() {
                    return this.router.globals.$current;
                },
                enumerable: true,
                configurable: true
            });
            StateService.prototype.dispose = function() {
                this.defaultErrorHandler(common_1.noop);
                this.invalidCallbacks = [];
            };
            StateService.prototype._handleInvalidTargetState = function(fromPath, toState) {
                var _this = this;
                var fromState = pathFactory_1.PathUtils.makeTargetState(fromPath);
                var globals = this.router.globals;
                var latestThing = function() {
                    return globals.transitionHistory.peekTail();
                };
                var latest = latestThing();
                var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());
                var injector = new resolveContext_1.ResolveContext(fromPath).injector();
                var checkForRedirect = function(result) {
                    if (!(result instanceof targetState_1.TargetState)) {
                        return;
                    }
                    var target = result;
                    target = _this.target(target.identifier(), target.params(), target.options());
                    if (!target.valid()) {
                        return rejectFactory_1.Rejection.invalid(target.error()).toPromise();
                    }
                    if (latestThing() !== latest) {
                        return rejectFactory_1.Rejection.superseded().toPromise();
                    }
                    return _this.transitionTo(target.identifier(), target.params(), target.options());
                };
                function invokeNextCallback() {
                    var nextCallback = callbackQueue.dequeue();
                    if (nextCallback === undefined) return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();
                    var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));
                    return callbackResult.then(checkForRedirect).then(function(result) {
                        return result || invokeNextCallback();
                    });
                }
                return invokeNextCallback();
            };
            StateService.prototype.onInvalid = function(callback) {
                this.invalidCallbacks.push(callback);
                return function deregisterListener() {
                    common_1.removeFrom(this.invalidCallbacks)(callback);
                }.bind(this);
            };
            StateService.prototype.reload = function(reloadState) {
                return this.transitionTo(this.current, this.params, {
                    reload: predicates_1.isDefined(reloadState) ? reloadState : true,
                    inherit: false,
                    notify: false
                });
            };
            StateService.prototype.go = function(to, params, options) {
                var defautGoOpts = {
                    relative: this.$current,
                    inherit: true
                };
                var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);
                return this.transitionTo(to, params, transOpts);
            };
            StateService.prototype.target = function(identifier, params, options) {
                if (options === void 0) {
                    options = {};
                }
                if (predicates_1.isObject(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
                var reg = this.router.stateRegistry;
                options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);
                if (options.reload && !options.reloadState) throw new Error("No such reload state '" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + "'");
                var stateDefinition = reg.matcher.find(identifier, options.relative);
                return new targetState_1.TargetState(identifier, stateDefinition, params, options);
            };
            StateService.prototype.getCurrentPath = function() {
                var _this = this;
                var globals = this.router.globals;
                var latestSuccess = globals.successfulTransitions.peekTail();
                var rootPath = function() {
                    return [ new pathNode_1.PathNode(_this.router.stateRegistry.root()) ];
                };
                return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
            };
            StateService.prototype.transitionTo = function(to, toParams, options) {
                var _this = this;
                if (toParams === void 0) {
                    toParams = {};
                }
                if (options === void 0) {
                    options = {};
                }
                var router = this.router;
                var globals = router.globals;
                options = common_1.defaults(options, transitionService_1.defaultTransOpts);
                var getCurrent = function() {
                    return globals.transition;
                };
                options = common_1.extend(options, {
                    current: getCurrent
                });
                var ref = this.target(to, toParams, options);
                var currentPath = this.getCurrentPath();
                if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);
                if (!ref.valid()) return common_1.silentRejection(ref.error());
                var rejectedTransitionHandler = function(transition) {
                    return function(error) {
                        if (error instanceof rejectFactory_1.Rejection) {
                            var isLatest = router.globals.lastStartedTransitionId === transition.$id;
                            if (error.type === rejectFactory_1.RejectType.IGNORED) {
                                isLatest && router.urlRouter.update();
                                return coreservices_1.services.$q.when(globals.current);
                            }
                            var detail = error.detail;
                            if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {
                                var redirect = transition.redirect(detail);
                                return redirect.run().catch(rejectedTransitionHandler(redirect));
                            }
                            if (error.type === rejectFactory_1.RejectType.ABORTED) {
                                isLatest && router.urlRouter.update();
                                return coreservices_1.services.$q.reject(error);
                            }
                        }
                        var errorHandler = _this.defaultErrorHandler();
                        errorHandler(error);
                        return coreservices_1.services.$q.reject(error);
                    };
                };
                var transition = this.router.transitionService.create(currentPath, ref);
                var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
                common_1.silenceUncaughtInPromise(transitionToPromise);
                return common_1.extend(transitionToPromise, {
                    transition: transition
                });
            };
            StateService.prototype.is = function(stateOrName, params, options) {
                options = common_1.defaults(options, {
                    relative: this.$current
                });
                var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
                if (!predicates_1.isDefined(state)) return undefined;
                if (this.$current !== state) return false;
                if (!params) return true;
                var schema = state.parameters({
                    inherit: true,
                    matchingKeys: params
                });
                return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
            };
            StateService.prototype.includes = function(stateOrName, params, options) {
                options = common_1.defaults(options, {
                    relative: this.$current
                });
                var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);
                if (glob) {
                    if (!glob.matches(this.$current.name)) return false;
                    stateOrName = this.$current.name;
                }
                var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
                if (!predicates_1.isDefined(state)) return undefined;
                if (!predicates_1.isDefined(include[state.name])) return false;
                if (!params) return true;
                var schema = state.parameters({
                    inherit: true,
                    matchingKeys: params
                });
                return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);
            };
            StateService.prototype.href = function(stateOrName, params, options) {
                var defaultHrefOpts = {
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: this.$current
                };
                options = common_1.defaults(options, defaultHrefOpts);
                params = params || {};
                var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
                if (!predicates_1.isDefined(state)) return null;
                if (options.inherit) params = this.params.$inherit(params, this.$current, state);
                var nav = state && options.lossy ? state.navigable : state;
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null;
                }
                return this.router.urlRouter.href(nav.url, params, {
                    absolute: options.absolute
                });
            };
            StateService.prototype.defaultErrorHandler = function(handler) {
                return this._defaultErrorHandler = handler || this._defaultErrorHandler;
            };
            StateService.prototype.get = function(stateOrName, base) {
                var reg = this.router.stateRegistry;
                if (arguments.length === 0) return reg.get();
                return reg.get(stateOrName, base || this.$current);
            };
            StateService.prototype.lazyLoad = function(stateOrName, transition) {
                var state = this.get(stateOrName);
                if (!state || !state.lazyLoad) throw new Error("Can not lazy load " + stateOrName);
                var currentPath = this.getCurrentPath();
                var target = pathFactory_1.PathUtils.makeTargetState(currentPath);
                transition = transition || this.router.transitionService.create(currentPath, target);
                return lazyLoad_1.lazyLoadState(transition, state);
            };
            return StateService;
        }();
        exports.StateService = StateService;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/glob": 17,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../common/queue": 21,
        "../hooks/lazyLoad": 28,
        "../params/param": 38,
        "../path/pathFactory": 43,
        "../path/pathNode": 44,
        "../resolve/resolveContext": 48,
        "../transition/rejectFactory": 62,
        "../transition/transitionService": 66,
        "./targetState": 57
    } ],
    57: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var TargetState = function() {
            function TargetState(_identifier, _definition, _params, _options) {
                if (_options === void 0) {
                    _options = {};
                }
                this._identifier = _identifier;
                this._definition = _definition;
                this._options = _options;
                this._params = _params || {};
            }
            TargetState.prototype.name = function() {
                return this._definition && this._definition.name || this._identifier;
            };
            TargetState.prototype.identifier = function() {
                return this._identifier;
            };
            TargetState.prototype.params = function() {
                return this._params;
            };
            TargetState.prototype.$state = function() {
                return this._definition;
            };
            TargetState.prototype.state = function() {
                return this._definition && this._definition.self;
            };
            TargetState.prototype.options = function() {
                return this._options;
            };
            TargetState.prototype.exists = function() {
                return !!(this._definition && this._definition.self);
            };
            TargetState.prototype.valid = function() {
                return !this.error();
            };
            TargetState.prototype.error = function() {
                var base = this.options().relative;
                if (!this._definition && !!base) {
                    var stateName = base.name ? base.name : base;
                    return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
                }
                if (!this._definition) return "No such state '" + this.name() + "'";
                if (!this._definition.self) return "State '" + this.name() + "' has an invalid definition";
            };
            TargetState.prototype.toString = function() {
                return "'" + this.name() + "'" + common_1.toJson(this.params());
            };
            return TargetState;
        }();
        TargetState.isDef = function(obj) {
            return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));
        };
        exports.TargetState = TargetState;
    }, {
        "../common/common": 15,
        "../common/predicates": 20
    } ],
    58: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var interface_1 = require("./interface");
        var transitionHook_1 = require("./transitionHook");
        var HookBuilder = function() {
            function HookBuilder(transition) {
                this.transition = transition;
            }
            HookBuilder.prototype.buildHooksForPhase = function(phase) {
                var _this = this;
                var $transitions = this.transition.router.transitionService;
                return $transitions._pluginapi._getEvents(phase).map(function(type) {
                    return _this.buildHooks(type);
                }).reduce(common_1.unnestR, []).filter(common_1.identity);
            };
            HookBuilder.prototype.buildHooks = function(hookType) {
                var transition = this.transition;
                var treeChanges = transition.treeChanges();
                var matchingHooks = this.getMatchingHooks(hookType, treeChanges);
                if (!matchingHooks) return [];
                var baseHookOptions = {
                    transition: transition,
                    current: transition.options().current
                };
                var makeTransitionHooks = function(hook) {
                    var matches = hook.matches(treeChanges);
                    var matchingNodes = matches[hookType.criteriaMatchPath.name];
                    return matchingNodes.map(function(node) {
                        var _options = common_1.extend({
                            bind: hook.bind,
                            traceData: {
                                hookType: hookType.name,
                                context: node
                            }
                        }, baseHookOptions);
                        var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;
                        var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);
                        return {
                            hook: hook,
                            node: node,
                            transitionHook: transitionHook
                        };
                    });
                };
                return matchingHooks.map(makeTransitionHooks).reduce(common_1.unnestR, []).sort(tupleSort(hookType.reverseSort)).map(function(tuple) {
                    return tuple.transitionHook;
                });
            };
            HookBuilder.prototype.getMatchingHooks = function(hookType, treeChanges) {
                var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;
                var $transitions = this.transition.router.transitionService;
                var registries = isCreate ? [ $transitions ] : [ this.transition, $transitions ];
                return registries.map(function(reg) {
                    return reg.getHooks(hookType.name);
                }).filter(common_1.assertPredicate(predicates_1.isArray, "broken event named: " + hookType.name)).reduce(common_1.unnestR, []).filter(function(hook) {
                    return hook.matches(treeChanges);
                });
            };
            return HookBuilder;
        }();
        exports.HookBuilder = HookBuilder;
        function tupleSort(reverseDepthSort) {
            if (reverseDepthSort === void 0) {
                reverseDepthSort = false;
            }
            return function nodeDepthThenPriority(l, r) {
                var factor = reverseDepthSort ? -1 : 1;
                var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
                return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;
            };
        }
    }, {
        "../common/common": 15,
        "../common/predicates": 20,
        "./interface": 61,
        "./transitionHook": 65
    } ],
    59: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var interface_1 = require("./interface");
        var glob_1 = require("../common/glob");
        function matchState(state, criterion) {
            var toMatch = predicates_1.isString(criterion) ? [ criterion ] : criterion;
            function matchGlobs(_state) {
                var globStrings = toMatch;
                for (var i = 0; i < globStrings.length; i++) {
                    var glob = new glob_1.Glob(globStrings[i]);
                    if (glob && glob.matches(_state.name) || !glob && globStrings[i] === _state.name) {
                        return true;
                    }
                }
                return false;
            }
            var matchFn = predicates_1.isFunction(toMatch) ? toMatch : matchGlobs;
            return !!matchFn(state);
        }
        exports.matchState = matchState;
        var RegisteredHook = function() {
            function RegisteredHook(tranSvc, eventType, callback, matchCriteria, options) {
                if (options === void 0) {
                    options = {};
                }
                this.tranSvc = tranSvc;
                this.eventType = eventType;
                this.callback = callback;
                this.matchCriteria = matchCriteria;
                this.priority = options.priority || 0;
                this.bind = options.bind || null;
                this._deregistered = false;
            }
            RegisteredHook.prototype._matchingNodes = function(nodes, criterion) {
                if (criterion === true) return nodes;
                var matching = nodes.filter(function(node) {
                    return matchState(node.state, criterion);
                });
                return matching.length ? matching : null;
            };
            RegisteredHook.prototype._getDefaultMatchCriteria = function() {
                return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function() {
                    return true;
                });
            };
            RegisteredHook.prototype._getMatchingNodes = function(treeChanges) {
                var _this = this;
                var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);
                var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());
                return paths.reduce(function(mn, pathtype) {
                    var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;
                    var path = treeChanges[pathtype.name] || [];
                    var nodes = isStateHook ? path : [ common_1.tail(path) ];
                    mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);
                    return mn;
                }, {});
            };
            RegisteredHook.prototype.matches = function(treeChanges) {
                var matches = this._getMatchingNodes(treeChanges);
                var allMatched = common_1.values(matches).every(common_1.identity);
                return allMatched ? matches : null;
            };
            return RegisteredHook;
        }();
        exports.RegisteredHook = RegisteredHook;
        function makeEvent(registry, transitionService, eventType) {
            var _registeredHooks = registry._registeredHooks = registry._registeredHooks || {};
            var hooks = _registeredHooks[eventType.name] = [];
            registry[eventType.name] = hookRegistrationFn;
            function hookRegistrationFn(matchObject, callback, options) {
                if (options === void 0) {
                    options = {};
                }
                var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, options);
                hooks.push(registeredHook);
                return function deregisterEventHook() {
                    registeredHook._deregistered = true;
                    common_1.removeFrom(hooks)(registeredHook);
                };
            }
            return hookRegistrationFn;
        }
        exports.makeEvent = makeEvent;
    }, {
        "../common/common": 15,
        "../common/glob": 17,
        "../common/predicates": 20,
        "./interface": 61
    } ],
    60: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./interface"));
        __export(require("./hookBuilder"));
        __export(require("./hookRegistry"));
        __export(require("./rejectFactory"));
        __export(require("./transition"));
        __export(require("./transitionHook"));
        __export(require("./transitionEventType"));
        __export(require("./transitionService"));
    }, {
        "./hookBuilder": 58,
        "./hookRegistry": 59,
        "./interface": 61,
        "./rejectFactory": 62,
        "./transition": 63,
        "./transitionEventType": 64,
        "./transitionHook": 65,
        "./transitionService": 66
    } ],
    61: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var TransitionHookPhase;
        (function(TransitionHookPhase) {
            TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";
            TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";
            TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";
            TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";
            TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";
        })(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));
        var TransitionHookScope;
        (function(TransitionHookScope) {
            TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";
            TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";
        })(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));
    }, {} ],
    62: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var strings_1 = require("../common/strings");
        var hof_1 = require("../common/hof");
        var RejectType;
        (function(RejectType) {
            RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";
            RejectType[RejectType["ABORTED"] = 3] = "ABORTED";
            RejectType[RejectType["INVALID"] = 4] = "INVALID";
            RejectType[RejectType["IGNORED"] = 5] = "IGNORED";
            RejectType[RejectType["ERROR"] = 6] = "ERROR";
        })(RejectType = exports.RejectType || (exports.RejectType = {}));
        var id = 0;
        var Rejection = function() {
            function Rejection(type, message, detail) {
                this.$id = id++;
                this.type = type;
                this.message = message;
                this.detail = detail;
            }
            Rejection.prototype.toString = function() {
                var detailString = function(d) {
                    return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);
                };
                var detail = detailString(this.detail);
                var _a = this, $id = _a.$id, type = _a.type, message = _a.message;
                return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
            };
            Rejection.prototype.toPromise = function() {
                return common_1.extend(common_1.silentRejection(this), {
                    _transitionRejection: this
                });
            };
            Rejection.isRejectionPromise = function(obj) {
                return obj && typeof obj.then === "function" && hof_1.is(Rejection)(obj._transitionRejection);
            };
            Rejection.superseded = function(detail, options) {
                var message = "The transition has been superseded by a different transition";
                var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);
                if (options && options.redirected) {
                    rejection.redirected = true;
                }
                return rejection;
            };
            Rejection.redirected = function(detail) {
                return Rejection.superseded(detail, {
                    redirected: true
                });
            };
            Rejection.invalid = function(detail) {
                var message = "This transition is invalid";
                return new Rejection(RejectType.INVALID, message, detail);
            };
            Rejection.ignored = function(detail) {
                var message = "The transition was ignored";
                return new Rejection(RejectType.IGNORED, message, detail);
            };
            Rejection.aborted = function(detail) {
                var message = "The transition has been aborted";
                return new Rejection(RejectType.ABORTED, message, detail);
            };
            Rejection.errored = function(detail) {
                var message = "The transition errored";
                return new Rejection(RejectType.ERROR, message, detail);
            };
            Rejection.normalize = function(detail) {
                return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);
            };
            return Rejection;
        }();
        exports.Rejection = Rejection;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/strings": 22
    } ],
    63: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var trace_1 = require("../common/trace");
        var coreservices_1 = require("../common/coreservices");
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var hof_1 = require("../common/hof");
        var interface_1 = require("./interface");
        var transitionHook_1 = require("./transitionHook");
        var hookRegistry_1 = require("./hookRegistry");
        var hookBuilder_1 = require("./hookBuilder");
        var pathFactory_1 = require("../path/pathFactory");
        var targetState_1 = require("../state/targetState");
        var param_1 = require("../params/param");
        var resolvable_1 = require("../resolve/resolvable");
        var resolveContext_1 = require("../resolve/resolveContext");
        var stateSelf = hof_1.prop("self");
        var Transition = function() {
            function Transition(fromPath, targetState, router) {
                var _this = this;
                this._deferred = coreservices_1.services.$q.defer();
                this.promise = this._deferred.promise;
                this._registeredHooks = {};
                this._hookBuilder = new hookBuilder_1.HookBuilder(this);
                this.isActive = function() {
                    return _this.router.globals.transition === _this;
                };
                this.router = router;
                this._targetState = targetState;
                if (!targetState.valid()) {
                    throw new Error(targetState.error());
                }
                this._options = common_1.extend({
                    current: hof_1.val(this)
                }, targetState.options());
                this.$id = router.transitionService._transitionCount++;
                var toPath = pathFactory_1.PathUtils.buildToPath(fromPath, targetState);
                this._treeChanges = pathFactory_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);
                this.createTransitionHookRegFns();
                var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);
                transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function() {
                    return null;
                });
                this.applyViewConfigs(router);
            }
            Transition.prototype.onBefore = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onStart = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onExit = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onRetain = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onEnter = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onFinish = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onSuccess = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.onError = function(criteria, callback, options) {
                return;
            };
            Transition.prototype.createTransitionHookRegFns = function() {
                var _this = this;
                this.router.transitionService._pluginapi._getEvents().filter(function(type) {
                    return type.hookPhase !== interface_1.TransitionHookPhase.CREATE;
                }).forEach(function(type) {
                    return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type);
                });
            };
            Transition.prototype.getHooks = function(hookName) {
                return this._registeredHooks[hookName];
            };
            Transition.prototype.applyViewConfigs = function(router) {
                var enteringStates = this._treeChanges.entering.map(function(node) {
                    return node.state;
                });
                pathFactory_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
            };
            Transition.prototype.$from = function() {
                return common_1.tail(this._treeChanges.from).state;
            };
            Transition.prototype.$to = function() {
                return common_1.tail(this._treeChanges.to).state;
            };
            Transition.prototype.from = function() {
                return this.$from().self;
            };
            Transition.prototype.to = function() {
                return this.$to().self;
            };
            Transition.prototype.targetState = function() {
                return this._targetState;
            };
            Transition.prototype.is = function(compare) {
                if (compare instanceof Transition) {
                    return this.is({
                        to: compare.$to().name,
                        from: compare.$from().name
                    });
                }
                return !(compare.to && !hookRegistry_1.matchState(this.$to(), compare.to) || compare.from && !hookRegistry_1.matchState(this.$from(), compare.from));
            };
            Transition.prototype.params = function(pathname) {
                if (pathname === void 0) {
                    pathname = "to";
                }
                return Object.freeze(this._treeChanges[pathname].map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}));
            };
            Transition.prototype.injector = function(state, pathName) {
                if (pathName === void 0) {
                    pathName = "to";
                }
                var path = this._treeChanges[pathName];
                if (state) path = pathFactory_1.PathUtils.subPath(path, function(node) {
                    return node.state === state || node.state.name === state;
                });
                return new resolveContext_1.ResolveContext(path).injector();
            };
            Transition.prototype.getResolveTokens = function(pathname) {
                if (pathname === void 0) {
                    pathname = "to";
                }
                return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();
            };
            Transition.prototype.addResolvable = function(resolvable, state) {
                if (state === void 0) {
                    state = "";
                }
                resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);
                var stateName = typeof state === "string" ? state : state.name;
                var topath = this._treeChanges.to;
                var targetNode = common_1.find(topath, function(node) {
                    return node.state.name === stateName;
                });
                var resolveContext = new resolveContext_1.ResolveContext(topath);
                resolveContext.addResolvables([ resolvable ], targetNode.state);
            };
            Transition.prototype.redirectedFrom = function() {
                return this._options.redirectedFrom || null;
            };
            Transition.prototype.originalTransition = function() {
                var rf = this.redirectedFrom();
                return rf && rf.originalTransition() || this;
            };
            Transition.prototype.options = function() {
                return this._options;
            };
            Transition.prototype.entering = function() {
                return common_1.map(this._treeChanges.entering, hof_1.prop("state")).map(stateSelf);
            };
            Transition.prototype.exiting = function() {
                return common_1.map(this._treeChanges.exiting, hof_1.prop("state")).map(stateSelf).reverse();
            };
            Transition.prototype.retained = function() {
                return common_1.map(this._treeChanges.retained, hof_1.prop("state")).map(stateSelf);
            };
            Transition.prototype.views = function(pathname, state) {
                if (pathname === void 0) {
                    pathname = "entering";
                }
                var path = this._treeChanges[pathname];
                path = !state ? path : path.filter(hof_1.propEq("state", state));
                return path.map(hof_1.prop("views")).filter(common_1.identity).reduce(common_1.unnestR, []);
            };
            Transition.prototype.treeChanges = function(pathname) {
                return pathname ? this._treeChanges[pathname] : this._treeChanges;
            };
            Transition.prototype.redirect = function(targetState) {
                var redirects = 1, trans = this;
                while ((trans = trans.redirectedFrom()) != null) {
                    if (++redirects > 20) throw new Error("Too many consecutive Transition redirects (20+)");
                }
                var redirectOpts = {
                    redirectedFrom: this,
                    source: "redirect"
                };
                if (this.options().source === "url" && targetState.options().location !== false) {
                    redirectOpts.location = "replace";
                }
                var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);
                targetState = new targetState_1.TargetState(targetState.identifier(), targetState.$state(), targetState.params(), newOptions);
                var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);
                var originalEnteringNodes = this._treeChanges.entering;
                var redirectEnteringNodes = newTransition._treeChanges.entering;
                var nodeIsReloading = function(reloadState) {
                    return function(node) {
                        return reloadState && node.state.includes[reloadState.name];
                    };
                };
                var matchingEnteringNodes = pathFactory_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathFactory_1.PathUtils.nonDynamicParams).filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));
                matchingEnteringNodes.forEach(function(node, idx) {
                    node.resolvables = originalEnteringNodes[idx].resolvables;
                });
                return newTransition;
            };
            Transition.prototype._changedParams = function() {
                var tc = this._treeChanges;
                if (this._options.reload) return undefined;
                if (tc.exiting.length || tc.entering.length) return undefined;
                if (tc.to.length !== tc.from.length) return undefined;
                var pathsDiffer = common_1.arrayTuples(tc.to, tc.from).map(function(tuple) {
                    return tuple[0].state !== tuple[1].state;
                }).reduce(common_1.anyTrueR, false);
                if (pathsDiffer) return undefined;
                var nodeSchemas = tc.to.map(function(node) {
                    return node.paramSchema;
                });
                var _a = [ tc.to, tc.from ].map(function(path) {
                    return path.map(function(x) {
                        return x.paramValues;
                    });
                }), toValues = _a[0], fromValues = _a[1];
                var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);
                return tuples.map(function(_a) {
                    var schema = _a[0], toVals = _a[1], fromVals = _a[2];
                    return param_1.Param.changed(schema, toVals, fromVals);
                }).reduce(common_1.unnestR, []);
            };
            Transition.prototype.dynamic = function() {
                var changes = this._changedParams();
                return !changes ? false : changes.map(function(x) {
                    return x.dynamic;
                }).reduce(common_1.anyTrueR, false);
            };
            Transition.prototype.ignored = function() {
                return !!this._ignoredReason();
            };
            Transition.prototype._ignoredReason = function() {
                var pending = this.router.globals.transition;
                var reloadState = this._options.reloadState;
                var same = function(pathA, pathB) {
                    if (pathA.length !== pathB.length) return false;
                    var matching = pathFactory_1.PathUtils.matching(pathA, pathB);
                    return pathA.length === matching.filter(function(node) {
                        return !reloadState || !node.state.includes[reloadState.name];
                    }).length;
                };
                var newTC = this.treeChanges();
                var pendTC = pending && pending.treeChanges();
                if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting)) return "SameAsPending";
                if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to)) return "SameAsCurrent";
            };
            Transition.prototype.run = function() {
                var _this = this;
                var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;
                var getHooksFor = function(phase) {
                    return _this._hookBuilder.buildHooksForPhase(phase);
                };
                var transitionSuccess = function() {
                    trace_1.trace.traceSuccess(_this.$to(), _this);
                    _this.success = true;
                    _this._deferred.resolve(_this.to());
                    runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));
                };
                var transitionError = function(reason) {
                    trace_1.trace.traceError(reason, _this);
                    _this.success = false;
                    _this._deferred.reject(reason);
                    _this._error = reason;
                    runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));
                };
                var runTransition = function() {
                    var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);
                    var done = function() {
                        return coreservices_1.services.$q.when(undefined);
                    };
                    return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);
                };
                var startTransition = function() {
                    var globals = _this.router.globals;
                    globals.lastStartedTransitionId = _this.$id;
                    globals.transition = _this;
                    globals.transitionHistory.enqueue(_this);
                    trace_1.trace.traceTransitionStart(_this);
                    return coreservices_1.services.$q.when(undefined);
                };
                var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);
                transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition).then(runTransition).then(transitionSuccess, transitionError);
                return this.promise;
            };
            Transition.prototype.valid = function() {
                return !this.error() || this.success !== undefined;
            };
            Transition.prototype.abort = function() {
                if (predicates_1.isUndefined(this.success)) {
                    this._aborted = true;
                }
            };
            Transition.prototype.error = function() {
                var state = this.$to();
                if (state.self.abstract) return "Cannot transition to abstract state '" + state.name + "'";
                if (!param_1.Param.validates(state.parameters(), this.params())) return "Param values not valid for state '" + state.name + "'";
                if (this.success === false) return this._error;
            };
            Transition.prototype.toString = function() {
                var fromStateOrName = this.from();
                var toStateOrName = this.to();
                var avoidEmptyHash = function(params) {
                    return params["#"] !== null && params["#"] !== undefined ? params : common_1.omit(params, [ "#" ]);
                };
                var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = common_1.toJson(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop("paramValues")).reduce(common_1.mergeR, {}))), toValid = this.valid() ? "" : "(X) ", to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = common_1.toJson(avoidEmptyHash(this.params()));
                return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
            };
            return Transition;
        }();
        Transition.diToken = Transition;
        exports.Transition = Transition;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../common/trace": 23,
        "../params/param": 38,
        "../path/pathFactory": 43,
        "../resolve/resolvable": 47,
        "../resolve/resolveContext": 48,
        "../state/targetState": 57,
        "./hookBuilder": 58,
        "./hookRegistry": 59,
        "./interface": 61,
        "./transitionHook": 65
    } ],
    64: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var transitionHook_1 = require("./transitionHook");
        var TransitionEventType = function() {
            function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
                if (reverseSort === void 0) {
                    reverseSort = false;
                }
                if (getResultHandler === void 0) {
                    getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT;
                }
                if (getErrorHandler === void 0) {
                    getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR;
                }
                if (synchronous === void 0) {
                    synchronous = false;
                }
                this.name = name;
                this.hookPhase = hookPhase;
                this.hookOrder = hookOrder;
                this.criteriaMatchPath = criteriaMatchPath;
                this.reverseSort = reverseSort;
                this.getResultHandler = getResultHandler;
                this.getErrorHandler = getErrorHandler;
                this.synchronous = synchronous;
            }
            return TransitionEventType;
        }();
        exports.TransitionEventType = TransitionEventType;
    }, {
        "./transitionHook": 65
    } ],
    65: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var interface_1 = require("./interface");
        var common_1 = require("../common/common");
        var strings_1 = require("../common/strings");
        var predicates_1 = require("../common/predicates");
        var hof_1 = require("../common/hof");
        var trace_1 = require("../common/trace");
        var coreservices_1 = require("../common/coreservices");
        var rejectFactory_1 = require("./rejectFactory");
        var targetState_1 = require("../state/targetState");
        var defaultOptions = {
            current: common_1.noop,
            transition: null,
            traceData: {},
            bind: null
        };
        var TransitionHook = function() {
            function TransitionHook(transition, stateContext, registeredHook, options) {
                var _this = this;
                this.transition = transition;
                this.stateContext = stateContext;
                this.registeredHook = registeredHook;
                this.options = options;
                this.isSuperseded = function() {
                    return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();
                };
                this.options = common_1.defaults(options, defaultOptions);
                this.type = registeredHook.eventType;
            }
            TransitionHook.prototype.logError = function(err) {
                this.transition.router.stateService.defaultErrorHandler()(err);
            };
            TransitionHook.prototype.invokeHook = function() {
                var _this = this;
                var hook = this.registeredHook;
                if (hook._deregistered) return;
                var notCurrent = this.getNotCurrentRejection();
                if (notCurrent) return notCurrent;
                var options = this.options;
                trace_1.trace.traceHookInvocation(this, this.transition, options);
                var invokeCallback = function() {
                    return hook.callback.call(options.bind, _this.transition, _this.stateContext);
                };
                var normalizeErr = function(err) {
                    return rejectFactory_1.Rejection.normalize(err).toPromise();
                };
                var handleError = function(err) {
                    return hook.eventType.getErrorHandler(_this)(err);
                };
                var handleResult = function(result) {
                    return hook.eventType.getResultHandler(_this)(result);
                };
                try {
                    var result = invokeCallback();
                    if (!this.type.synchronous && predicates_1.isPromise(result)) {
                        return result.catch(normalizeErr).then(handleResult, handleError);
                    } else {
                        return handleResult(result);
                    }
                } catch (err) {
                    return handleError(rejectFactory_1.Rejection.normalize(err));
                }
            };
            TransitionHook.prototype.handleHookResult = function(result) {
                var _this = this;
                var notCurrent = this.getNotCurrentRejection();
                if (notCurrent) return notCurrent;
                if (predicates_1.isPromise(result)) {
                    return result.then(function(val) {
                        return _this.handleHookResult(val);
                    });
                }
                trace_1.trace.traceHookResult(result, this.transition, this.options);
                if (result === false) {
                    return rejectFactory_1.Rejection.aborted("Hook aborted transition").toPromise();
                }
                var isTargetState = hof_1.is(targetState_1.TargetState);
                if (isTargetState(result)) {
                    return rejectFactory_1.Rejection.redirected(result).toPromise();
                }
            };
            TransitionHook.prototype.getNotCurrentRejection = function() {
                var router = this.transition.router;
                if (router._disposed) {
                    return rejectFactory_1.Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise();
                }
                if (this.transition._aborted) {
                    return rejectFactory_1.Rejection.aborted().toPromise();
                }
                if (this.isSuperseded()) {
                    return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();
                }
            };
            TransitionHook.prototype.toString = function() {
                var _a = this, options = _a.options, registeredHook = _a.registeredHook;
                var event = hof_1.parse("traceData.hookType")(options) || "internal", context = hof_1.parse("traceData.context.state.name")(options) || hof_1.parse("traceData.context")(options) || "unknown", name = strings_1.fnToString(registeredHook.callback);
                return event + " context: " + context + ", " + strings_1.maxLength(200, name);
            };
            TransitionHook.chain = function(hooks, waitFor) {
                var createHookChainR = function(prev, nextHook) {
                    return prev.then(function() {
                        return nextHook.invokeHook();
                    });
                };
                return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());
            };
            TransitionHook.invokeHooks = function(hooks, doneCallback) {
                for (var idx = 0; idx < hooks.length; idx++) {
                    var hookResult = hooks[idx].invokeHook();
                    if (predicates_1.isPromise(hookResult)) {
                        var remainingHooks = hooks.slice(idx + 1);
                        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);
                    }
                }
                return doneCallback();
            };
            TransitionHook.runAllHooks = function(hooks) {
                hooks.forEach(function(hook) {
                    return hook.invokeHook();
                });
            };
            return TransitionHook;
        }();
        TransitionHook.HANDLE_RESULT = function(hook) {
            return function(result) {
                return hook.handleHookResult(result);
            };
        };
        TransitionHook.LOG_REJECTED_RESULT = function(hook) {
            return function(result) {
                predicates_1.isPromise(result) && result.catch(function(err) {
                    return hook.logError(rejectFactory_1.Rejection.normalize(err));
                });
                return undefined;
            };
        };
        TransitionHook.LOG_ERROR = function(hook) {
            return function(error) {
                return hook.logError(error);
            };
        };
        TransitionHook.REJECT_ERROR = function(hook) {
            return function(error) {
                return common_1.silentRejection(error);
            };
        };
        TransitionHook.THROW_ERROR = function(hook) {
            return function(error) {
                throw error;
            };
        };
        exports.TransitionHook = TransitionHook;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../common/strings": 22,
        "../common/trace": 23,
        "../state/targetState": 57,
        "./interface": 61,
        "./rejectFactory": 62
    } ],
    66: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var interface_1 = require("./interface");
        var transition_1 = require("./transition");
        var hookRegistry_1 = require("./hookRegistry");
        var coreResolvables_1 = require("../hooks/coreResolvables");
        var redirectTo_1 = require("../hooks/redirectTo");
        var onEnterExitRetain_1 = require("../hooks/onEnterExitRetain");
        var resolve_1 = require("../hooks/resolve");
        var views_1 = require("../hooks/views");
        var updateGlobals_1 = require("../hooks/updateGlobals");
        var url_1 = require("../hooks/url");
        var lazyLoad_1 = require("../hooks/lazyLoad");
        var transitionEventType_1 = require("./transitionEventType");
        var transitionHook_1 = require("./transitionHook");
        var predicates_1 = require("../common/predicates");
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var ignoredTransition_1 = require("../hooks/ignoredTransition");
        var invalidTransition_1 = require("../hooks/invalidTransition");
        exports.defaultTransOpts = {
            location: true,
            relative: null,
            inherit: false,
            notify: true,
            reload: false,
            custom: {},
            current: function() {
                return null;
            },
            source: "unknown"
        };
        var TransitionService = function() {
            function TransitionService(_router) {
                this._transitionCount = 0;
                this._eventTypes = [];
                this._registeredHooks = {};
                this._criteriaPaths = {};
                this._router = _router;
                this.$view = _router.viewService;
                this._deregisterHookFns = {};
                this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [ "_definePathType", "_defineEvent", "_getPathTypes", "_getEvents", "getHooks" ]);
                this._defineCorePaths();
                this._defineCoreEvents();
                this._registerCoreTransitionHooks();
            }
            TransitionService.prototype.onCreate = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onBefore = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onStart = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onExit = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onRetain = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onEnter = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onFinish = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onSuccess = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.onError = function(criteria, callback, options) {
                return;
            };
            TransitionService.prototype.dispose = function(router) {
                common_1.values(this._registeredHooks).forEach(function(hooksArray) {
                    return hooksArray.forEach(function(hook) {
                        hook._deregistered = true;
                        common_1.removeFrom(hooksArray, hook);
                    });
                });
            };
            TransitionService.prototype.create = function(fromPath, targetState) {
                return new transition_1.Transition(fromPath, targetState, this._router);
            };
            TransitionService.prototype._defineCoreEvents = function() {
                var Phase = interface_1.TransitionHookPhase;
                var TH = transitionHook_1.TransitionHook;
                var paths = this._criteriaPaths;
                var NORMAL_SORT = false, REVERSE_SORT = true;
                var ASYNCHRONOUS = false, SYNCHRONOUS = true;
                this._defineEvent("onCreate", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);
                this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to);
                this._defineEvent("onStart", Phase.RUN, 0, paths.to);
                this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT);
                this._defineEvent("onRetain", Phase.RUN, 200, paths.retained);
                this._defineEvent("onEnter", Phase.RUN, 300, paths.entering);
                this._defineEvent("onFinish", Phase.RUN, 400, paths.to);
                this._defineEvent("onSuccess", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
                this._defineEvent("onError", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
            };
            TransitionService.prototype._defineCorePaths = function() {
                var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;
                this._definePathType("to", TRANSITION);
                this._definePathType("from", TRANSITION);
                this._definePathType("exiting", STATE);
                this._definePathType("retained", STATE);
                this._definePathType("entering", STATE);
            };
            TransitionService.prototype._defineEvent = function(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
                if (reverseSort === void 0) {
                    reverseSort = false;
                }
                if (getResultHandler === void 0) {
                    getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT;
                }
                if (getErrorHandler === void 0) {
                    getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR;
                }
                if (synchronous === void 0) {
                    synchronous = false;
                }
                var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
                this._eventTypes.push(eventType);
                hookRegistry_1.makeEvent(this, this, eventType);
            };
            TransitionService.prototype._getEvents = function(phase) {
                var transitionHookTypes = predicates_1.isDefined(phase) ? this._eventTypes.filter(function(type) {
                    return type.hookPhase === phase;
                }) : this._eventTypes.slice();
                return transitionHookTypes.sort(function(l, r) {
                    var cmpByPhase = l.hookPhase - r.hookPhase;
                    return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;
                });
            };
            TransitionService.prototype._definePathType = function(name, hookScope) {
                this._criteriaPaths[name] = {
                    name: name,
                    scope: hookScope
                };
            };
            TransitionService.prototype._getPathTypes = function() {
                return this._criteriaPaths;
            };
            TransitionService.prototype.getHooks = function(hookName) {
                return this._registeredHooks[hookName];
            };
            TransitionService.prototype._registerCoreTransitionHooks = function() {
                var fns = this._deregisterHookFns;
                fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);
                fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);
                fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);
                fns.redirectTo = redirectTo_1.registerRedirectToHook(this);
                fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);
                fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);
                fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);
                fns.eagerResolve = resolve_1.registerEagerResolvePath(this);
                fns.lazyResolve = resolve_1.registerLazyResolveState(this);
                fns.loadViews = views_1.registerLoadEnteringViews(this);
                fns.activateViews = views_1.registerActivateViews(this);
                fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);
                fns.updateUrl = url_1.registerUpdateUrl(this);
                fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);
            };
            return TransitionService;
        }();
        exports.TransitionService = TransitionService;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../hooks/coreResolvables": 25,
        "../hooks/ignoredTransition": 26,
        "../hooks/invalidTransition": 27,
        "../hooks/lazyLoad": 28,
        "../hooks/onEnterExitRetain": 29,
        "../hooks/redirectTo": 30,
        "../hooks/resolve": 31,
        "../hooks/updateGlobals": 32,
        "../hooks/url": 33,
        "../hooks/views": 34,
        "./hookRegistry": 59,
        "./interface": 61,
        "./transition": 63,
        "./transitionEventType": 64,
        "./transitionHook": 65
    } ],
    67: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./urlMatcher"));
        __export(require("./urlMatcherFactory"));
        __export(require("./urlRouter"));
        __export(require("./urlRule"));
        __export(require("./urlService"));
    }, {
        "./urlMatcher": 68,
        "./urlMatcherFactory": 69,
        "./urlRouter": 70,
        "./urlRule": 71,
        "./urlService": 72
    } ],
    68: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var predicates_1 = require("../common/predicates");
        var param_1 = require("../params/param");
        var strings_1 = require("../common/strings");
        function quoteRegExp(string, param) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!param) return result;
            switch (param.squash) {
              case false:
                surroundPattern = [ "(", ")" + (param.isOptional ? "?" : "") ];
                break;

              case true:
                result = result.replace(/\/$/, "");
                surroundPattern = [ "(?:/(", ")|/)?" ];
                break;

              default:
                surroundPattern = [ "(" + param.squash + "|", ")?" ];
                break;
            }
            return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
        }
        var memoizeTo = function(obj, prop, fn) {
            return obj[prop] = obj[prop] || fn();
        };
        var splitOnSlash = strings_1.splitOnDelim("/");
        var UrlMatcher = function() {
            function UrlMatcher(pattern, paramTypes, paramFactory, config) {
                var _this = this;
                this.config = config;
                this._cache = {
                    path: [ this ]
                };
                this._children = [];
                this._params = [];
                this._segments = [];
                this._compiled = [];
                this.pattern = pattern;
                this.config = common_1.defaults(this.config, {
                    params: {},
                    strict: true,
                    caseInsensitive: false,
                    paramMap: common_1.identity
                });
                var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, last = 0, m, patterns = [];
                var checkParamErrors = function(id) {
                    if (!UrlMatcher.nameValidator.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
                    if (common_1.find(_this._params, hof_1.propEq("id", id))) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
                };
                var matchDetails = function(m, isSearch) {
                    var id = m[2] || m[3];
                    var regexp = isSearch ? m[4] : m[4] || (m[1] === "*" ? ".*" : null);
                    var makeRegexpType = function(regexp) {
                        return common_1.inherit(paramTypes.type(isSearch ? "query" : "path"), {
                            pattern: new RegExp(regexp, _this.config.caseInsensitive ? "i" : undefined)
                        });
                    };
                    return {
                        id: id,
                        regexp: regexp,
                        cfg: _this.config.params[id],
                        segment: pattern.substring(last, m.index),
                        type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp)
                    };
                };
                var p, segment;
                while (m = placeholder.exec(pattern)) {
                    p = matchDetails(m, false);
                    if (p.segment.indexOf("?") >= 0) break;
                    checkParamErrors(p.id);
                    this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));
                    this._segments.push(p.segment);
                    patterns.push([ p.segment, common_1.tail(this._params) ]);
                    last = placeholder.lastIndex;
                }
                segment = pattern.substring(last);
                var i = segment.indexOf("?");
                if (i >= 0) {
                    var search = segment.substring(i);
                    segment = segment.substring(0, i);
                    if (search.length > 0) {
                        last = 0;
                        while (m = searchPlaceholder.exec(search)) {
                            p = matchDetails(m, true);
                            checkParamErrors(p.id);
                            this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));
                            last = placeholder.lastIndex;
                        }
                    }
                }
                this._segments.push(segment);
                this._compiled = patterns.map(function(pattern) {
                    return quoteRegExp.apply(null, pattern);
                }).concat(quoteRegExp(segment));
            }
            UrlMatcher.prototype.append = function(url) {
                this._children.push(url);
                url._cache = {
                    path: this._cache.path.concat(url),
                    parent: this,
                    pattern: null
                };
                return url;
            };
            UrlMatcher.prototype.isRoot = function() {
                return this._cache.path[0] === this;
            };
            UrlMatcher.prototype.toString = function() {
                return this.pattern;
            };
            UrlMatcher.prototype.exec = function(path, search, hash, options) {
                var _this = this;
                if (search === void 0) {
                    search = {};
                }
                if (options === void 0) {
                    options = {};
                }
                var match = memoizeTo(this._cache, "pattern", function() {
                    return new RegExp([ "^", common_1.unnest(_this._cache.path.map(hof_1.prop("_compiled"))).join(""), _this.config.strict === false ? "/?" : "", "$" ].join(""), _this.config.caseInsensitive ? "i" : undefined);
                }).exec(path);
                if (!match) return null;
                var allParams = this.parameters(), pathParams = allParams.filter(function(param) {
                    return !param.isSearch();
                }), searchParams = allParams.filter(function(param) {
                    return param.isSearch();
                }), nPathSegments = this._cache.path.map(function(urlm) {
                    return urlm._segments.length - 1;
                }).reduce(function(a, x) {
                    return a + x;
                }), values = {};
                if (nPathSegments !== match.length - 1) throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
                function decodePathArray(string) {
                    var reverseString = function(str) {
                        return str.split("").reverse().join("");
                    };
                    var unquoteDashes = function(str) {
                        return str.replace(/\\-/g, "-");
                    };
                    var split = reverseString(string).split(/-(?!\\)/);
                    var allReversed = common_1.map(split, reverseString);
                    return common_1.map(allReversed, unquoteDashes).reverse();
                }
                for (var i = 0; i < nPathSegments; i++) {
                    var param = pathParams[i];
                    var value = match[i + 1];
                    for (var j = 0; j < param.replace.length; j++) {
                        if (param.replace[j].from === value) value = param.replace[j].to;
                    }
                    if (value && param.array === true) value = decodePathArray(value);
                    if (predicates_1.isDefined(value)) value = param.type.decode(value);
                    values[param.id] = param.value(value);
                }
                searchParams.forEach(function(param) {
                    var value = search[param.id];
                    for (var j = 0; j < param.replace.length; j++) {
                        if (param.replace[j].from === value) value = param.replace[j].to;
                    }
                    if (predicates_1.isDefined(value)) value = param.type.decode(value);
                    values[param.id] = param.value(value);
                });
                if (hash) values["#"] = hash;
                return values;
            };
            UrlMatcher.prototype.parameters = function(opts) {
                if (opts === void 0) {
                    opts = {};
                }
                if (opts.inherit === false) return this._params;
                return common_1.unnest(this._cache.path.map(function(matcher) {
                    return matcher._params;
                }));
            };
            UrlMatcher.prototype.parameter = function(id, opts) {
                var _this = this;
                if (opts === void 0) {
                    opts = {};
                }
                var findParam = function() {
                    for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                        var param = _a[_i];
                        if (param.id === id) return param;
                    }
                };
                var parent = this._cache.parent;
                return findParam() || opts.inherit !== false && parent && parent.parameter(id, opts) || null;
            };
            UrlMatcher.prototype.validates = function(params) {
                var validParamVal = function(param, val) {
                    return !param || param.validates(val);
                };
                params = params || {};
                var paramSchema = this.parameters().filter(function(paramDef) {
                    return params.hasOwnProperty(paramDef.id);
                });
                return paramSchema.map(function(paramDef) {
                    return validParamVal(paramDef, params[paramDef.id]);
                }).reduce(common_1.allTrueR, true);
            };
            UrlMatcher.prototype.format = function(values) {
                if (values === void 0) {
                    values = {};
                }
                var urlMatchers = this._cache.path;
                var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []).map(function(x) {
                    return predicates_1.isString(x) ? x : getDetails(x);
                });
                var queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(common_1.unnestR, []).map(getDetails);
                var isInvalid = function(param) {
                    return param.isValid === false;
                };
                if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
                    return null;
                }
                function getDetails(param) {
                    var value = param.value(values[param.id]);
                    var isValid = param.validates(value);
                    var isDefaultValue = param.isDefaultValue(value);
                    var squash = isDefaultValue ? param.squash : false;
                    var encoded = param.type.encode(value);
                    return {
                        param: param,
                        value: value,
                        isValid: isValid,
                        isDefaultValue: isDefaultValue,
                        squash: squash,
                        encoded: encoded
                    };
                }
                var pathString = pathSegmentsAndParams.reduce(function(acc, x) {
                    if (predicates_1.isString(x)) return acc + x;
                    var squash = x.squash, encoded = x.encoded, param = x.param;
                    if (squash === true) return acc.match(/\/$/) ? acc.slice(0, -1) : acc;
                    if (predicates_1.isString(squash)) return acc + squash;
                    if (squash !== false) return acc;
                    if (encoded == null) return acc;
                    if (predicates_1.isArray(encoded)) return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join("-");
                    if (param.raw) return acc + encoded;
                    return acc + encodeURIComponent(encoded);
                }, "");
                var queryString = queryParams.map(function(paramDetails) {
                    var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
                    if (encoded == null || isDefaultValue && squash !== false) return;
                    if (!predicates_1.isArray(encoded)) encoded = [ encoded ];
                    if (encoded.length === 0) return;
                    if (!param.raw) encoded = common_1.map(encoded, encodeURIComponent);
                    return encoded.map(function(val) {
                        return param.id + "=" + val;
                    });
                }).filter(common_1.identity).reduce(common_1.unnestR, []).join("&");
                return pathString + (queryString ? "?" + queryString : "") + (values["#"] ? "#" + values["#"] : "");
            };
            UrlMatcher.encodeDashes = function(str) {
                return encodeURIComponent(str).replace(/-/g, function(c) {
                    return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
                });
            };
            UrlMatcher.pathSegmentsAndParams = function(matcher) {
                var staticSegments = matcher._segments;
                var pathParams = matcher._params.filter(function(p) {
                    return p.location === param_1.DefType.PATH;
                });
                return common_1.arrayTuples(staticSegments, pathParams.concat(undefined)).reduce(common_1.unnestR, []).filter(function(x) {
                    return x !== "" && predicates_1.isDefined(x);
                });
            };
            UrlMatcher.queryParams = function(matcher) {
                return matcher._params.filter(function(p) {
                    return p.location === param_1.DefType.SEARCH;
                });
            };
            UrlMatcher.compare = function(a, b) {
                var segments = function(matcher) {
                    return matcher._cache.segments = matcher._cache.segments || matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams).reduce(common_1.unnestR, []).reduce(strings_1.joinNeighborsR, []).map(function(x) {
                        return predicates_1.isString(x) ? splitOnSlash(x) : x;
                    }).reduce(common_1.unnestR, []);
                };
                var weights = function(matcher) {
                    return matcher._cache.weights = matcher._cache.weights || segments(matcher).map(function(segment) {
                        if (segment === "/") return 1;
                        if (predicates_1.isString(segment)) return 2;
                        if (segment instanceof param_1.Param) return 3;
                    });
                };
                var cmp, i, pairs = common_1.arrayTuples(weights(a), weights(b));
                for (i = 0; i < pairs.length; i++) {
                    cmp = pairs[i][0] - pairs[i][1];
                    if (cmp !== 0) return cmp;
                }
                return 0;
            };
            return UrlMatcher;
        }();
        UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;
        exports.UrlMatcher = UrlMatcher;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../common/strings": 22,
        "../params/param": 38
    } ],
    69: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var urlMatcher_1 = require("./urlMatcher");
        var param_1 = require("../params/param");
        var paramTypes_1 = require("../params/paramTypes");
        var UrlMatcherFactory = function() {
            function UrlMatcherFactory() {
                var _this = this;
                this.paramTypes = new paramTypes_1.ParamTypes();
                this._isCaseInsensitive = false;
                this._isStrictMode = true;
                this._defaultSquashPolicy = false;
                this._getConfig = function(config) {
                    return common_1.extend({
                        strict: _this._isStrictMode,
                        caseInsensitive: _this._isCaseInsensitive
                    }, config);
                };
                this.paramFactory = {
                    fromConfig: function(id, type, config) {
                        return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);
                    },
                    fromPath: function(id, type, config) {
                        return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);
                    },
                    fromSearch: function(id, type, config) {
                        return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);
                    }
                };
                common_1.extend(this, {
                    UrlMatcher: urlMatcher_1.UrlMatcher,
                    Param: param_1.Param
                });
            }
            UrlMatcherFactory.prototype.caseInsensitive = function(value) {
                return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;
            };
            UrlMatcherFactory.prototype.strictMode = function(value) {
                return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;
            };
            UrlMatcherFactory.prototype.defaultSquashPolicy = function(value) {
                if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
                return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;
            };
            UrlMatcherFactory.prototype.compile = function(pattern, config) {
                return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));
            };
            UrlMatcherFactory.prototype.isMatcher = function(object) {
                if (!predicates_1.isObject(object)) return false;
                var result = true;
                common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function(val, name) {
                    if (predicates_1.isFunction(val)) result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));
                });
                return result;
            };
            UrlMatcherFactory.prototype.type = function(name, definition, definitionFn) {
                var type = this.paramTypes.type(name, definition, definitionFn);
                return !predicates_1.isDefined(definition) ? type : this;
            };
            UrlMatcherFactory.prototype.$get = function() {
                this.paramTypes.enqueue = false;
                this.paramTypes._flushTypeQueue();
                return this;
            };
            UrlMatcherFactory.prototype.dispose = function() {
                this.paramTypes.dispose();
            };
            return UrlMatcherFactory;
        }();
        exports.UrlMatcherFactory = UrlMatcherFactory;
    }, {
        "../common/common": 15,
        "../common/predicates": 20,
        "../params/param": 38,
        "../params/paramTypes": 40,
        "./urlMatcher": 68
    } ],
    70: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var predicates_1 = require("../common/predicates");
        var urlMatcher_1 = require("./urlMatcher");
        var hof_1 = require("../common/hof");
        var urlRule_1 = require("./urlRule");
        var targetState_1 = require("../state/targetState");
        function appendBasePath(url, isHtml5, absolute, baseHref) {
            if (baseHref === "/") return url;
            if (isHtml5) return baseHref.slice(0, -1) + url;
            if (absolute) return baseHref.slice(1) + url;
            return url;
        }
        var getMatcher = hof_1.prop("urlMatcher");
        var defaultRuleSortFn;
        defaultRuleSortFn = common_1.composeSort(common_1.sortBy(hof_1.pipe(hof_1.prop("priority"), function(x) {
            return -x;
        })), common_1.sortBy(hof_1.pipe(hof_1.prop("type"), function(type) {
            return {
                STATE: 4,
                URLMATCHER: 4,
                REGEXP: 3,
                RAW: 2,
                OTHER: 1
            }[type];
        })), function(a, b) {
            return getMatcher(a) && getMatcher(b) ? urlMatcher_1.UrlMatcher.compare(getMatcher(a), getMatcher(b)) : 0;
        }, common_1.sortBy(hof_1.prop("$id"), common_1.inArray([ "REGEXP", "RAW", "OTHER" ])));
        var UrlRouter = function() {
            function UrlRouter(router) {
                this._sortFn = defaultRuleSortFn;
                this._rules = [];
                this.interceptDeferred = false;
                this._id = 0;
                this._sorted = false;
                this._router = router;
                this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);
                common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));
            }
            UrlRouter.prototype.dispose = function() {
                this.listen(false);
                this._rules = [];
                delete this._otherwiseFn;
            };
            UrlRouter.prototype.sort = function(compareFn) {
                this._rules.sort(this._sortFn = compareFn || this._sortFn);
                this._sorted = true;
            };
            UrlRouter.prototype.ensureSorted = function() {
                this._sorted || this.sort();
            };
            UrlRouter.prototype.match = function(url) {
                var _this = this;
                this.ensureSorted();
                url = common_1.extend({
                    path: "",
                    search: {},
                    hash: ""
                }, url);
                var rules = this.rules();
                if (this._otherwiseFn) rules.push(this._otherwiseFn);
                var checkRule = function(rule) {
                    var match = rule.match(url, _this._router);
                    return match && {
                        match: match,
                        rule: rule,
                        weight: rule.matchPriority(match)
                    };
                };
                var best;
                for (var i = 0; i < rules.length; i++) {
                    if (best && this._sortFn(rules[i], best.rule) !== 0) break;
                    var current = checkRule(rules[i]);
                    best = !best || current && current.weight > best.weight ? current : best;
                }
                return best;
            };
            UrlRouter.prototype.sync = function(evt) {
                if (evt && evt.defaultPrevented) return;
                var router = this._router, $url = router.urlService, $state = router.stateService;
                var url = {
                    path: $url.path(),
                    search: $url.search(),
                    hash: $url.hash()
                };
                var best = this.match(url);
                var applyResult = hof_1.pattern([ [ predicates_1.isString, function(newurl) {
                    return $url.url(newurl, true);
                } ], [ targetState_1.TargetState.isDef, function(def) {
                    return $state.go(def.state, def.params, def.options);
                } ], [ hof_1.is(targetState_1.TargetState), function(target) {
                    return $state.go(target.state(), target.params(), target.options());
                } ] ]);
                applyResult(best && best.rule.handler(best.match, url, router));
            };
            UrlRouter.prototype.listen = function(enabled) {
                var _this = this;
                if (enabled === false) {
                    this._stopFn && this._stopFn();
                    delete this._stopFn;
                } else {
                    return this._stopFn = this._stopFn || this._router.urlService.onChange(function(evt) {
                        return _this.sync(evt);
                    });
                }
            };
            UrlRouter.prototype.update = function(read) {
                var $url = this._router.locationService;
                if (read) {
                    this.location = $url.path();
                    return;
                }
                if ($url.path() === this.location) return;
                $url.url(this.location, true);
            };
            UrlRouter.prototype.push = function(urlMatcher, params, options) {
                var replace = options && !!options.replace;
                this._router.urlService.url(urlMatcher.format(params || {}), replace);
            };
            UrlRouter.prototype.href = function(urlMatcher, params, options) {
                var url = urlMatcher.format(params);
                if (url == null) return null;
                options = options || {
                    absolute: false
                };
                var cfg = this._router.urlService.config;
                var isHtml5 = cfg.html5Mode();
                if (!isHtml5 && url !== null) {
                    url = "#" + cfg.hashPrefix() + url;
                }
                url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());
                if (!options.absolute || !url) {
                    return url;
                }
                var slash = !isHtml5 && url ? "/" : "", port = cfg.port();
                port = port === 80 || port === 443 ? "" : ":" + port;
                return [ cfg.protocol(), "://", cfg.host(), port, slash, url ].join("");
            };
            UrlRouter.prototype.rule = function(rule) {
                var _this = this;
                if (!urlRule_1.UrlRuleFactory.isUrlRule(rule)) throw new Error("invalid rule");
                rule.$id = this._id++;
                rule.priority = rule.priority || 0;
                this._rules.push(rule);
                this._sorted = false;
                return function() {
                    return _this.removeRule(rule);
                };
            };
            UrlRouter.prototype.removeRule = function(rule) {
                common_1.removeFrom(this._rules, rule);
            };
            UrlRouter.prototype.rules = function() {
                this.ensureSorted();
                return this._rules.slice();
            };
            UrlRouter.prototype.otherwise = function(handler) {
                var handlerFn = getHandlerFn(handler);
                this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);
                this._sorted = false;
            };
            UrlRouter.prototype.initial = function(handler) {
                var handlerFn = getHandlerFn(handler);
                var matchFn = function(urlParts, router) {
                    return router.globals.transitionHistory.size() === 0 && !!/^\/?$/.exec(urlParts.path);
                };
                this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
            };
            UrlRouter.prototype.when = function(matcher, handler, options) {
                var rule = this.urlRuleFactory.create(matcher, handler);
                if (predicates_1.isDefined(options && options.priority)) rule.priority = options.priority;
                this.rule(rule);
                return rule;
            };
            UrlRouter.prototype.deferIntercept = function(defer) {
                if (defer === undefined) defer = true;
                this.interceptDeferred = defer;
            };
            return UrlRouter;
        }();
        exports.UrlRouter = UrlRouter;
        function getHandlerFn(handler) {
            if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {
                throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
            }
            return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);
        }
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../state/targetState": 57,
        "./urlMatcher": 68,
        "./urlRule": 71
    } ],
    71: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var urlMatcher_1 = require("./urlMatcher");
        var predicates_1 = require("../common/predicates");
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var UrlRuleFactory = function() {
            function UrlRuleFactory(router) {
                this.router = router;
            }
            UrlRuleFactory.prototype.compile = function(str) {
                return this.router.urlMatcherFactory.compile(str);
            };
            UrlRuleFactory.prototype.create = function(what, handler) {
                var _this = this;
                var makeRule = hof_1.pattern([ [ predicates_1.isString, function(_what) {
                    return makeRule(_this.compile(_what));
                } ], [ hof_1.is(urlMatcher_1.UrlMatcher), function(_what) {
                    return _this.fromUrlMatcher(_what, handler);
                } ], [ predicates_1.isState, function(_what) {
                    return _this.fromState(_what, _this.router);
                } ], [ hof_1.is(RegExp), function(_what) {
                    return _this.fromRegExp(_what, handler);
                } ], [ predicates_1.isFunction, function(_what) {
                    return new BaseUrlRule(_what, handler);
                } ] ]);
                var rule = makeRule(what);
                if (!rule) throw new Error("invalid 'what' in when()");
                return rule;
            };
            UrlRuleFactory.prototype.fromUrlMatcher = function(urlMatcher, handler) {
                var _handler = handler;
                if (predicates_1.isString(handler)) handler = this.router.urlMatcherFactory.compile(handler);
                if (hof_1.is(urlMatcher_1.UrlMatcher)(handler)) _handler = function(match) {
                    return handler.format(match);
                };
                function match(url) {
                    var match = urlMatcher.exec(url.path, url.search, url.hash);
                    return urlMatcher.validates(match) && match;
                }
                function matchPriority(params) {
                    var optional = urlMatcher.parameters().filter(function(param) {
                        return param.isOptional;
                    });
                    if (!optional.length) return 1e-6;
                    var matched = optional.filter(function(param) {
                        return params[param.id];
                    });
                    return matched.length / optional.length;
                }
                var details = {
                    urlMatcher: urlMatcher,
                    matchPriority: matchPriority,
                    type: "URLMATCHER"
                };
                return common_1.extend(new BaseUrlRule(match, _handler), details);
            };
            UrlRuleFactory.prototype.fromState = function(state, router) {
                var handler = function(match) {
                    var $state = router.stateService;
                    var globals = router.globals;
                    if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {
                        $state.transitionTo(state, match, {
                            inherit: true,
                            source: "url"
                        });
                    }
                };
                var details = {
                    state: state,
                    type: "STATE"
                };
                return common_1.extend(this.fromUrlMatcher(state.url, handler), details);
            };
            UrlRuleFactory.prototype.fromRegExp = function(regexp, handler) {
                if (regexp.global || regexp.sticky) throw new Error("Rule RegExp must not be global or sticky");
                var redirectUrlTo = function(match) {
                    return handler.replace(/\$(\$|\d{1,2})/, function(m, what) {
                        return match[what === "$" ? 0 : Number(what)];
                    });
                };
                var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;
                var match = function(url) {
                    return regexp.exec(url.path);
                };
                var details = {
                    regexp: regexp,
                    type: "REGEXP"
                };
                return common_1.extend(new BaseUrlRule(match, _handler), details);
            };
            return UrlRuleFactory;
        }();
        UrlRuleFactory.isUrlRule = function(obj) {
            return obj && [ "type", "match", "handler" ].every(function(key) {
                return predicates_1.isDefined(obj[key]);
            });
        };
        exports.UrlRuleFactory = UrlRuleFactory;
        var BaseUrlRule = function() {
            function BaseUrlRule(match, handler) {
                var _this = this;
                this.match = match;
                this.type = "RAW";
                this.matchPriority = function(match) {
                    return 0 - _this.$id;
                };
                this.handler = handler || common_1.identity;
            }
            return BaseUrlRule;
        }();
        exports.BaseUrlRule = BaseUrlRule;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/predicates": 20,
        "./urlMatcher": 68
    } ],
    72: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var coreservices_1 = require("../common/coreservices");
        var common_1 = require("../common/common");
        var makeStub = function(keys) {
            return keys.reduce(function(acc, key) {
                return acc[key] = coreservices_1.notImplemented(key), acc;
            }, {
                dispose: common_1.noop
            });
        };
        var locationServicesFns = [ "url", "path", "search", "hash", "onChange" ];
        var locationConfigFns = [ "port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix" ];
        var umfFns = [ "type", "caseInsensitive", "strictMode", "defaultSquashPolicy" ];
        var rulesFns = [ "sort", "when", "initial", "otherwise", "rules", "rule", "removeRule" ];
        var syncFns = [ "deferIntercept", "listen", "sync", "match" ];
        var UrlService = function() {
            function UrlService(router, lateBind) {
                if (lateBind === void 0) {
                    lateBind = true;
                }
                this.router = router;
                this.rules = {};
                this.config = {};
                var locationServices = function() {
                    return router.locationService;
                };
                common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);
                var locationConfig = function() {
                    return router.locationConfig;
                };
                common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);
                var umf = function() {
                    return router.urlMatcherFactory;
                };
                common_1.createProxyFunctions(umf, this.config, umf, umfFns);
                var urlRouter = function() {
                    return router.urlRouter;
                };
                common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);
                common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);
            }
            UrlService.prototype.url = function(newurl, replace, state) {
                return;
            };
            UrlService.prototype.path = function() {
                return;
            };
            UrlService.prototype.search = function() {
                return;
            };
            UrlService.prototype.hash = function() {
                return;
            };
            UrlService.prototype.onChange = function(callback) {
                return;
            };
            UrlService.prototype.parts = function() {
                return {
                    path: this.path(),
                    search: this.search(),
                    hash: this.hash()
                };
            };
            UrlService.prototype.dispose = function() {};
            UrlService.prototype.sync = function(evt) {
                return;
            };
            UrlService.prototype.listen = function(enabled) {
                return;
            };
            UrlService.prototype.deferIntercept = function(defer) {
                return;
            };
            UrlService.prototype.match = function(urlParts) {
                return;
            };
            return UrlService;
        }();
        UrlService.locationServiceStub = makeStub(locationServicesFns);
        UrlService.locationConfigStub = makeStub(locationConfigFns);
        exports.UrlService = UrlService;
    }, {
        "../common/common": 15,
        "../common/coreservices": 16
    } ],
    73: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./vanilla/index"));
    }, {
        "./vanilla/index": 77
    } ],
    74: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var utils_1 = require("./utils");
        var predicates_1 = require("../common/predicates");
        var common_1 = require("../common/common");
        var BaseLocationServices = function() {
            function BaseLocationServices(router, fireAfterUpdate) {
                var _this = this;
                this.fireAfterUpdate = fireAfterUpdate;
                this._listener = function(evt) {
                    return _this._listeners.forEach(function(cb) {
                        return cb(evt);
                    });
                };
                this._listeners = [];
                this.hash = function() {
                    return utils_1.parseUrl(_this._get()).hash;
                };
                this.path = function() {
                    return utils_1.parseUrl(_this._get()).path;
                };
                this.search = function() {
                    return utils_1.getParams(utils_1.parseUrl(_this._get()).search);
                };
                this._location = window && window.location;
                this._history = window && window.history;
            }
            BaseLocationServices.prototype.url = function(url, replace) {
                if (replace === void 0) {
                    replace = true;
                }
                if (predicates_1.isDefined(url) && url !== this._get()) {
                    this._set(null, null, url, replace);
                    if (this.fireAfterUpdate) {
                        var evt_1 = common_1.extend(new Event("locationchange"), {
                            url: url
                        });
                        this._listeners.forEach(function(cb) {
                            return cb(evt_1);
                        });
                    }
                }
                return utils_1.buildUrl(this);
            };
            BaseLocationServices.prototype.onChange = function(cb) {
                var _this = this;
                this._listeners.push(cb);
                return function() {
                    return common_1.removeFrom(_this._listeners, cb);
                };
            };
            BaseLocationServices.prototype.dispose = function(router) {
                common_1.deregAll(this._listeners);
            };
            return BaseLocationServices;
        }();
        exports.BaseLocationServices = BaseLocationServices;
    }, {
        "../common/common": 15,
        "../common/predicates": 20,
        "./utils": 84
    } ],
    75: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var predicates_1 = require("../common/predicates");
        var BrowserLocationConfig = function() {
            function BrowserLocationConfig(router, _isHtml5) {
                if (_isHtml5 === void 0) {
                    _isHtml5 = false;
                }
                this._isHtml5 = _isHtml5;
                this._baseHref = undefined;
                this._hashPrefix = "";
            }
            BrowserLocationConfig.prototype.port = function() {
                if (location.port) {
                    return Number(location.port);
                }
                return this.protocol() === "https" ? 443 : 80;
            };
            BrowserLocationConfig.prototype.protocol = function() {
                return location.protocol.replace(/:/g, "");
            };
            BrowserLocationConfig.prototype.host = function() {
                return location.host;
            };
            BrowserLocationConfig.prototype.html5Mode = function() {
                return this._isHtml5;
            };
            BrowserLocationConfig.prototype.hashPrefix = function(newprefix) {
                return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;
            };
            BrowserLocationConfig.prototype.baseHref = function(href) {
                return predicates_1.isDefined(href) ? this._baseHref = href : this._baseHref || this.applyDocumentBaseHref();
            };
            BrowserLocationConfig.prototype.applyDocumentBaseHref = function() {
                var baseTags = document.getElementsByTagName("base");
                return this._baseHref = baseTags.length ? baseTags[0].href.substr(location.origin.length) : "";
            };
            BrowserLocationConfig.prototype.dispose = function() {};
            return BrowserLocationConfig;
        }();
        exports.BrowserLocationConfig = BrowserLocationConfig;
    }, {
        "../common/predicates": 20
    } ],
    76: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
                extendStatics(d, b);
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var utils_1 = require("./utils");
        var baseLocationService_1 = require("./baseLocationService");
        var HashLocationService = function(_super) {
            __extends(HashLocationService, _super);
            function HashLocationService(router) {
                var _this = _super.call(this, router, false) || this;
                window.addEventListener("hashchange", _this._listener, false);
                return _this;
            }
            HashLocationService.prototype._get = function() {
                return utils_1.trimHashVal(this._location.hash);
            };
            HashLocationService.prototype._set = function(state, title, url, replace) {
                this._location.hash = url;
            };
            HashLocationService.prototype.dispose = function(router) {
                _super.prototype.dispose.call(this, router);
                window.removeEventListener("hashchange", this._listener);
            };
            return HashLocationService;
        }(baseLocationService_1.BaseLocationServices);
        exports.HashLocationService = HashLocationService;
    }, {
        "./baseLocationService": 74,
        "./utils": 84
    } ],
    77: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./q"));
        __export(require("./injector"));
        __export(require("./baseLocationService"));
        __export(require("./hashLocationService"));
        __export(require("./memoryLocationService"));
        __export(require("./pushStateLocationService"));
        __export(require("./memoryLocationConfig"));
        __export(require("./browserLocationConfig"));
        __export(require("./utils"));
        __export(require("./plugins"));
    }, {
        "./baseLocationService": 74,
        "./browserLocationConfig": 75,
        "./hashLocationService": 76,
        "./injector": 78,
        "./memoryLocationConfig": 79,
        "./memoryLocationService": 80,
        "./plugins": 81,
        "./pushStateLocationService": 82,
        "./q": 83,
        "./utils": 84
    } ],
    78: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var index_1 = require("../common/index");
        var globals = {};
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
        var ARGUMENT_NAMES = /([^\s,]+)/g;
        exports.$injector = {
            get: function(name) {
                return globals[name];
            },
            has: function(name) {
                return exports.$injector.get(name) != null;
            },
            invoke: function(fn, context, locals) {
                var all = index_1.extend({}, globals, locals || {});
                var params = exports.$injector.annotate(fn);
                var ensureExist = index_1.assertPredicate(function(key) {
                    return all.hasOwnProperty(key);
                }, function(key) {
                    return "DI can't find injectable: '" + key + "'";
                });
                var args = params.filter(ensureExist).map(function(x) {
                    return all[x];
                });
                if (index_1.isFunction(fn)) return fn.apply(context, args); else return fn.slice(-1)[0].apply(context, args);
            },
            annotate: function(fn) {
                if (!index_1.isInjectable(fn)) throw new Error("Not an injectable function: " + fn);
                if (fn && fn.$inject) return fn.$inject;
                if (index_1.isArray(fn)) return fn.slice(0, -1);
                var fnStr = fn.toString().replace(STRIP_COMMENTS, "");
                var result = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(ARGUMENT_NAMES);
                return result || [];
            }
        };
    }, {
        "../common/index": 19
    } ],
    79: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var predicates_1 = require("../common/predicates");
        var common_1 = require("../common/common");
        var MemoryLocationConfig = function() {
            function MemoryLocationConfig() {
                var _this = this;
                this._baseHref = "";
                this._port = 80;
                this._protocol = "http";
                this._host = "localhost";
                this._hashPrefix = "";
                this.port = function() {
                    return _this._port;
                };
                this.protocol = function() {
                    return _this._protocol;
                };
                this.host = function() {
                    return _this._host;
                };
                this.baseHref = function() {
                    return _this._baseHref;
                };
                this.html5Mode = function() {
                    return false;
                };
                this.hashPrefix = function(newval) {
                    return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix;
                };
                this.dispose = common_1.noop;
            }
            return MemoryLocationConfig;
        }();
        exports.MemoryLocationConfig = MemoryLocationConfig;
    }, {
        "../common/common": 15,
        "../common/predicates": 20
    } ],
    80: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
                extendStatics(d, b);
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var baseLocationService_1 = require("./baseLocationService");
        var MemoryLocationService = function(_super) {
            __extends(MemoryLocationService, _super);
            function MemoryLocationService(router) {
                return _super.call(this, router, true) || this;
            }
            MemoryLocationService.prototype._get = function() {
                return this._url;
            };
            MemoryLocationService.prototype._set = function(state, title, url, replace) {
                this._url = url;
            };
            return MemoryLocationService;
        }(baseLocationService_1.BaseLocationServices);
        exports.MemoryLocationService = MemoryLocationService;
    }, {
        "./baseLocationService": 74
    } ],
    81: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var browserLocationConfig_1 = require("./browserLocationConfig");
        var hashLocationService_1 = require("./hashLocationService");
        var utils_1 = require("./utils");
        var pushStateLocationService_1 = require("./pushStateLocationService");
        var memoryLocationService_1 = require("./memoryLocationService");
        var memoryLocationConfig_1 = require("./memoryLocationConfig");
        var injector_1 = require("./injector");
        var q_1 = require("./q");
        var coreservices_1 = require("../common/coreservices");
        function servicesPlugin(router) {
            coreservices_1.services.$injector = injector_1.$injector;
            coreservices_1.services.$q = q_1.$q;
            return {
                name: "vanilla.services",
                $q: q_1.$q,
                $injector: injector_1.$injector,
                dispose: function() {
                    return null;
                }
            };
        }
        exports.servicesPlugin = servicesPlugin;
        exports.hashLocationPlugin = utils_1.locationPluginFactory("vanilla.hashBangLocation", false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);
        exports.pushStateLocationPlugin = utils_1.locationPluginFactory("vanilla.pushStateLocation", true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);
        exports.memoryLocationPlugin = utils_1.locationPluginFactory("vanilla.memoryLocation", false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);
    }, {
        "../common/coreservices": 16,
        "./browserLocationConfig": 75,
        "./hashLocationService": 76,
        "./injector": 78,
        "./memoryLocationConfig": 79,
        "./memoryLocationService": 80,
        "./pushStateLocationService": 82,
        "./q": 83,
        "./utils": 84
    } ],
    82: [ function(require, module, exports) {
        "use strict";
        var __extends = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
            };
            return function(d, b) {
                extendStatics(d, b);
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var utils_1 = require("./utils");
        var baseLocationService_1 = require("./baseLocationService");
        var PushStateLocationService = function(_super) {
            __extends(PushStateLocationService, _super);
            function PushStateLocationService(router) {
                var _this = _super.call(this, router, true) || this;
                _this._config = router.urlService.config;
                window.addEventListener("popstate", _this._listener, false);
                return _this;
            }
            PushStateLocationService.prototype._get = function() {
                var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
                search = utils_1.splitQuery(search)[1];
                hash = utils_1.splitHash(hash)[1];
                return pathname + (search ? "?" + search : "") + (hash ? "$" + search : "");
            };
            PushStateLocationService.prototype._set = function(state, title, url, replace) {
                var _a = this, _config = _a._config, _history = _a._history;
                var fullUrl = _config.baseHref() + url;
                if (replace) {
                    _history.replaceState(state, title, fullUrl);
                } else {
                    _history.pushState(state, title, fullUrl);
                }
            };
            PushStateLocationService.prototype.dispose = function(router) {
                _super.prototype.dispose.call(this, router);
                window.removeEventListener("popstate", this._listener);
            };
            return PushStateLocationService;
        }(baseLocationService_1.BaseLocationServices);
        exports.PushStateLocationService = PushStateLocationService;
    }, {
        "./baseLocationService": 74,
        "./utils": 84
    } ],
    83: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var index_1 = require("../common/index");
        exports.$q = {
            when: function(val) {
                return new Promise(function(resolve, reject) {
                    return resolve(val);
                });
            },
            reject: function(val) {
                return new Promise(function(resolve, reject) {
                    reject(val);
                });
            },
            defer: function() {
                var deferred = {};
                deferred.promise = new Promise(function(resolve, reject) {
                    deferred.resolve = resolve;
                    deferred.reject = reject;
                });
                return deferred;
            },
            all: function(promises) {
                if (index_1.isArray(promises)) {
                    return Promise.all(promises);
                }
                if (index_1.isObject(promises)) {
                    var chain = Object.keys(promises).map(function(key) {
                        return promises[key].then(function(val) {
                            return {
                                key: key,
                                val: val
                            };
                        });
                    });
                    return exports.$q.all(chain).then(function(values) {
                        return values.reduce(function(acc, tuple) {
                            acc[tuple.key] = tuple.val;
                            return acc;
                        }, {});
                    });
                }
            }
        };
    }, {
        "../common/index": 19
    } ],
    84: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var index_1 = require("../common/index");
        var common_1 = require("../common/common");
        var beforeAfterSubstr = function(char) {
            return function(str) {
                if (!str) return [ "", "" ];
                var idx = str.indexOf(char);
                if (idx === -1) return [ str, "" ];
                return [ str.substr(0, idx), str.substr(idx + 1) ];
            };
        };
        exports.splitHash = beforeAfterSubstr("#");
        exports.splitQuery = beforeAfterSubstr("?");
        exports.splitEqual = beforeAfterSubstr("=");
        exports.trimHashVal = function(str) {
            return str ? str.replace(/^#/, "") : "";
        };
        exports.keyValsToObjectR = function(accum, _a) {
            var key = _a[0], val = _a[1];
            if (!accum.hasOwnProperty(key)) {
                accum[key] = val;
            } else if (index_1.isArray(accum[key])) {
                accum[key].push(val);
            } else {
                accum[key] = [ accum[key], val ];
            }
            return accum;
        };
        exports.getParams = function(queryString) {
            return queryString.split("&").filter(common_1.identity).map(exports.splitEqual).reduce(exports.keyValsToObjectR, {});
        };
        function parseUrl(url) {
            var orEmptyString = function(x) {
                return x || "";
            };
            var _a = exports.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];
            var _b = exports.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
            return {
                path: path,
                search: search,
                hash: hash,
                url: url
            };
        }
        exports.parseUrl = parseUrl;
        exports.buildUrl = function(loc) {
            var path = loc.path();
            var searchObject = loc.search();
            var hash = loc.hash();
            var search = Object.keys(searchObject).map(function(key) {
                var param = searchObject[key];
                var vals = index_1.isArray(param) ? param : [ param ];
                return vals.map(function(val) {
                    return key + "=" + val;
                });
            }).reduce(common_1.unnestR, []).join("&");
            return path + (search ? "?" + search : "") + (hash ? "#" + hash : "");
        };
        function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
            return function(router) {
                var service = router.locationService = new serviceClass(router);
                var configuration = router.locationConfig = new configurationClass(router, isHtml5);
                function dispose(router) {
                    router.dispose(service);
                    router.dispose(configuration);
                }
                return {
                    name: name,
                    service: service,
                    configuration: configuration,
                    dispose: dispose
                };
            };
        }
        exports.locationPluginFactory = locationPluginFactory;
    }, {
        "../common/common": 15,
        "../common/index": 19
    } ],
    85: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __export(require("./view"));
    }, {
        "./view": 86
    } ],
    86: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var common_1 = require("../common/common");
        var hof_1 = require("../common/hof");
        var predicates_1 = require("../common/predicates");
        var trace_1 = require("../common/trace");
        var ViewService = function() {
            function ViewService() {
                var _this = this;
                this._uiViews = [];
                this._viewConfigs = [];
                this._viewConfigFactories = {};
                this._pluginapi = {
                    _rootViewContext: this._rootViewContext.bind(this),
                    _viewConfigFactory: this._viewConfigFactory.bind(this),
                    _registeredUIViews: function() {
                        return _this._uiViews;
                    },
                    _activeViewConfigs: function() {
                        return _this._viewConfigs;
                    }
                };
            }
            ViewService.prototype._rootViewContext = function(context) {
                return this._rootContext = context || this._rootContext;
            };
            ViewService.prototype._viewConfigFactory = function(viewType, factory) {
                this._viewConfigFactories[viewType] = factory;
            };
            ViewService.prototype.createViewConfig = function(path, decl) {
                var cfgFactory = this._viewConfigFactories[decl.$type];
                if (!cfgFactory) throw new Error("ViewService: No view config factory registered for type " + decl.$type);
                var cfgs = cfgFactory(path, decl);
                return predicates_1.isArray(cfgs) ? cfgs : [ cfgs ];
            };
            ViewService.prototype.deactivateViewConfig = function(viewConfig) {
                trace_1.trace.traceViewServiceEvent("<- Removing", viewConfig);
                common_1.removeFrom(this._viewConfigs, viewConfig);
            };
            ViewService.prototype.activateViewConfig = function(viewConfig) {
                trace_1.trace.traceViewServiceEvent("-> Registering", viewConfig);
                this._viewConfigs.push(viewConfig);
            };
            ViewService.prototype.sync = function() {
                var _this = this;
                var uiViewsByFqn = this._uiViews.map(function(uiv) {
                    return [ uiv.fqn, uiv ];
                }).reduce(common_1.applyPairs, {});
                function uiViewDepth(uiView) {
                    var stateDepth = function(context) {
                        return context && context.parent ? stateDepth(context.parent) + 1 : 1;
                    };
                    return uiView.fqn.split(".").length * 1e4 + stateDepth(uiView.creationContext);
                }
                function viewConfigDepth(config) {
                    var context = config.viewDecl.$context, count = 0;
                    while (++count && context.parent) context = context.parent;
                    return count;
                }
                var depthCompare = hof_1.curry(function(depthFn, posNeg, left, right) {
                    return posNeg * (depthFn(left) - depthFn(right));
                });
                var matchingConfigPair = function(uiView) {
                    var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
                    if (matchingConfigs.length > 1) {
                        matchingConfigs.sort(depthCompare(viewConfigDepth, -1));
                    }
                    return [ uiView, matchingConfigs[0] ];
                };
                var configureUIView = function(_a) {
                    var uiView = _a[0], viewConfig = _a[1];
                    if (_this._uiViews.indexOf(uiView) !== -1) uiView.configUpdated(viewConfig);
                };
                this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUIView);
            };
            ViewService.prototype.registerUIView = function(uiView) {
                trace_1.trace.traceViewServiceUIViewEvent("-> Registering", uiView);
                var uiViews = this._uiViews;
                var fqnMatches = function(uiv) {
                    return uiv.fqn === uiView.fqn;
                };
                if (uiViews.filter(fqnMatches).length) trace_1.trace.traceViewServiceUIViewEvent("!!!! duplicate uiView named:", uiView);
                uiViews.push(uiView);
                this.sync();
                return function() {
                    var idx = uiViews.indexOf(uiView);
                    if (idx === -1) {
                        trace_1.trace.traceViewServiceUIViewEvent("Tried removing non-registered uiView", uiView);
                        return;
                    }
                    trace_1.trace.traceViewServiceUIViewEvent("<- Deregistering", uiView);
                    common_1.removeFrom(uiViews)(uiView);
                };
            };
            ViewService.prototype.available = function() {
                return this._uiViews.map(hof_1.prop("fqn"));
            };
            ViewService.prototype.active = function() {
                return this._uiViews.filter(hof_1.prop("$config")).map(hof_1.prop("name"));
            };
            ViewService.normalizeUIViewTarget = function(context, rawViewName) {
                if (rawViewName === void 0) {
                    rawViewName = "";
                }
                var viewAtContext = rawViewName.split("@");
                var uiViewName = viewAtContext[0] || "$default";
                var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : "^";
                var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
                if (relativeViewNameSugar) {
                    uiViewContextAnchor = relativeViewNameSugar[1];
                    uiViewName = relativeViewNameSugar[2];
                }
                if (uiViewName.charAt(0) === "!") {
                    uiViewName = uiViewName.substr(1);
                    uiViewContextAnchor = "";
                }
                var relativeMatch = /^(\^(?:\.\^)*)$/;
                if (relativeMatch.exec(uiViewContextAnchor)) {
                    var anchor = uiViewContextAnchor.split(".").reduce(function(anchor, x) {
                        return anchor.parent;
                    }, context);
                    uiViewContextAnchor = anchor.name;
                } else if (uiViewContextAnchor === ".") {
                    uiViewContextAnchor = context.name;
                }
                return {
                    uiViewName: uiViewName,
                    uiViewContextAnchor: uiViewContextAnchor
                };
            };
            return ViewService;
        }();
        ViewService.matches = function(uiViewsByFqn, uiView) {
            return function(viewConfig) {
                if (uiView.$type !== viewConfig.viewDecl.$type) return false;
                var vc = viewConfig.viewDecl;
                var vcSegments = vc.$uiViewName.split(".");
                var uivSegments = uiView.fqn.split(".");
                if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length))) return false;
                var negOffset = 1 - vcSegments.length || undefined;
                var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
                var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
                return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
            };
        };
        exports.ViewService = ViewService;
    }, {
        "../common/common": 15,
        "../common/hof": 18,
        "../common/predicates": 20,
        "../common/trace": 23
    } ],
    87: [ function(require, module, exports) {
        (function(window, angular) {
            "use strict";
            var ELEMENT_NODE = 1;
            var COMMENT_NODE = 8;
            var ADD_CLASS_SUFFIX = "-add";
            var REMOVE_CLASS_SUFFIX = "-remove";
            var EVENT_CLASS_PREFIX = "ng-";
            var ACTIVE_CLASS_SUFFIX = "-active";
            var PREPARE_CLASS_SUFFIX = "-prepare";
            var NG_ANIMATE_CLASSNAME = "ng-animate";
            var NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";
            var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
            if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
                CSS_PREFIX = "-webkit-";
                TRANSITION_PROP = "WebkitTransition";
                TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend";
            } else {
                TRANSITION_PROP = "transition";
                TRANSITIONEND_EVENT = "transitionend";
            }
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS_PREFIX = "-webkit-";
                ANIMATION_PROP = "WebkitAnimation";
                ANIMATIONEND_EVENT = "webkitAnimationEnd animationend";
            } else {
                ANIMATION_PROP = "animation";
                ANIMATIONEND_EVENT = "animationend";
            }
            var DURATION_KEY = "Duration";
            var PROPERTY_KEY = "Property";
            var DELAY_KEY = "Delay";
            var TIMING_KEY = "TimingFunction";
            var ANIMATION_ITERATION_COUNT_KEY = "IterationCount";
            var ANIMATION_PLAYSTATE_KEY = "PlayState";
            var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
            var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
            var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
            var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
            var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
            var ngMinErr = angular.$$minErr("ng");
            function assertArg(arg, name, reason) {
                if (!arg) {
                    throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
                }
                return arg;
            }
            function mergeClasses(a, b) {
                if (!a && !b) return "";
                if (!a) return b;
                if (!b) return a;
                if (isArray(a)) a = a.join(" ");
                if (isArray(b)) b = b.join(" ");
                return a + " " + b;
            }
            function packageStyles(options) {
                var styles = {};
                if (options && (options.to || options.from)) {
                    styles.to = options.to;
                    styles.from = options.from;
                }
                return styles;
            }
            function pendClasses(classes, fix, isPrefix) {
                var className = "";
                classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
                forEach(classes, function(klass, i) {
                    if (klass && klass.length > 0) {
                        className += i > 0 ? " " : "";
                        className += isPrefix ? fix + klass : klass + fix;
                    }
                });
                return className;
            }
            function removeFromArray(arr, val) {
                var index = arr.indexOf(val);
                if (val >= 0) {
                    arr.splice(index, 1);
                }
            }
            function stripCommentsFromElement(element) {
                if (element instanceof jqLite) {
                    switch (element.length) {
                      case 0:
                        return element;

                      case 1:
                        if (element[0].nodeType === ELEMENT_NODE) {
                            return element;
                        }
                        break;

                      default:
                        return jqLite(extractElementNode(element));
                    }
                }
                if (element.nodeType === ELEMENT_NODE) {
                    return jqLite(element);
                }
            }
            function extractElementNode(element) {
                if (!element[0]) return element;
                for (var i = 0; i < element.length; i++) {
                    var elm = element[i];
                    if (elm.nodeType === ELEMENT_NODE) {
                        return elm;
                    }
                }
            }
            function $$addClass($$jqLite, element, className) {
                forEach(element, function(elm) {
                    $$jqLite.addClass(elm, className);
                });
            }
            function $$removeClass($$jqLite, element, className) {
                forEach(element, function(elm) {
                    $$jqLite.removeClass(elm, className);
                });
            }
            function applyAnimationClassesFactory($$jqLite) {
                return function(element, options) {
                    if (options.addClass) {
                        $$addClass($$jqLite, element, options.addClass);
                        options.addClass = null;
                    }
                    if (options.removeClass) {
                        $$removeClass($$jqLite, element, options.removeClass);
                        options.removeClass = null;
                    }
                };
            }
            function prepareAnimationOptions(options) {
                options = options || {};
                if (!options.$$prepared) {
                    var domOperation = options.domOperation || noop;
                    options.domOperation = function() {
                        options.$$domOperationFired = true;
                        domOperation();
                        domOperation = noop;
                    };
                    options.$$prepared = true;
                }
                return options;
            }
            function applyAnimationStyles(element, options) {
                applyAnimationFromStyles(element, options);
                applyAnimationToStyles(element, options);
            }
            function applyAnimationFromStyles(element, options) {
                if (options.from) {
                    element.css(options.from);
                    options.from = null;
                }
            }
            function applyAnimationToStyles(element, options) {
                if (options.to) {
                    element.css(options.to);
                    options.to = null;
                }
            }
            function mergeAnimationDetails(element, oldAnimation, newAnimation) {
                var target = oldAnimation.options || {};
                var newOptions = newAnimation.options || {};
                var toAdd = (target.addClass || "") + " " + (newOptions.addClass || "");
                var toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || "");
                var classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
                if (newOptions.preparationClasses) {
                    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
                    delete newOptions.preparationClasses;
                }
                var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
                extend(target, newOptions);
                if (realDomOperation) {
                    target.domOperation = realDomOperation;
                }
                if (classes.addClass) {
                    target.addClass = classes.addClass;
                } else {
                    target.addClass = null;
                }
                if (classes.removeClass) {
                    target.removeClass = classes.removeClass;
                } else {
                    target.removeClass = null;
                }
                oldAnimation.addClass = target.addClass;
                oldAnimation.removeClass = target.removeClass;
                return target;
            }
            function resolveElementClasses(existing, toAdd, toRemove) {
                var ADD_CLASS = 1;
                var REMOVE_CLASS = -1;
                var flags = {};
                existing = splitClassesToLookup(existing);
                toAdd = splitClassesToLookup(toAdd);
                forEach(toAdd, function(value, key) {
                    flags[key] = ADD_CLASS;
                });
                toRemove = splitClassesToLookup(toRemove);
                forEach(toRemove, function(value, key) {
                    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
                });
                var classes = {
                    addClass: "",
                    removeClass: ""
                };
                forEach(flags, function(val, klass) {
                    var prop, allow;
                    if (val === ADD_CLASS) {
                        prop = "addClass";
                        allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
                    } else if (val === REMOVE_CLASS) {
                        prop = "removeClass";
                        allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
                    }
                    if (allow) {
                        if (classes[prop].length) {
                            classes[prop] += " ";
                        }
                        classes[prop] += klass;
                    }
                });
                function splitClassesToLookup(classes) {
                    if (isString(classes)) {
                        classes = classes.split(" ");
                    }
                    var obj = {};
                    forEach(classes, function(klass) {
                        if (klass.length) {
                            obj[klass] = true;
                        }
                    });
                    return obj;
                }
                return classes;
            }
            function getDomNode(element) {
                return element instanceof jqLite ? element[0] : element;
            }
            function applyGeneratedPreparationClasses(element, event, options) {
                var classes = "";
                if (event) {
                    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
                }
                if (options.addClass) {
                    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
                }
                if (options.removeClass) {
                    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
                }
                if (classes.length) {
                    options.preparationClasses = classes;
                    element.addClass(classes);
                }
            }
            function clearGeneratedClasses(element, options) {
                if (options.preparationClasses) {
                    element.removeClass(options.preparationClasses);
                    options.preparationClasses = null;
                }
                if (options.activeClasses) {
                    element.removeClass(options.activeClasses);
                    options.activeClasses = null;
                }
            }
            function blockTransitions(node, duration) {
                var value = duration ? "-" + duration + "s" : "";
                applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]);
                return [ TRANSITION_DELAY_PROP, value ];
            }
            function blockKeyframeAnimations(node, applyBlock) {
                var value = applyBlock ? "paused" : "";
                var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
                applyInlineStyle(node, [ key, value ]);
                return [ key, value ];
            }
            function applyInlineStyle(node, styleTuple) {
                var prop = styleTuple[0];
                var value = styleTuple[1];
                node.style[prop] = value;
            }
            function concatWithSpace(a, b) {
                if (!a) return b;
                if (!b) return a;
                return a + " " + b;
            }
            var $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
                var queue, cancelFn;
                function scheduler(tasks) {
                    queue = queue.concat(tasks);
                    nextTick();
                }
                queue = scheduler.queue = [];
                scheduler.waitUntilQuiet = function(fn) {
                    if (cancelFn) cancelFn();
                    cancelFn = $$rAF(function() {
                        cancelFn = null;
                        fn();
                        nextTick();
                    });
                };
                return scheduler;
                function nextTick() {
                    if (!queue.length) return;
                    var items = queue.shift();
                    for (var i = 0; i < items.length; i++) {
                        items[i]();
                    }
                    if (!cancelFn) {
                        $$rAF(function() {
                            if (!cancelFn) nextTick();
                        });
                    }
                }
            } ];
            var $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
                return {
                    link: function(scope, element, attrs) {
                        var val = attrs.ngAnimateChildren;
                        if (isString(val) && val.length === 0) {
                            element.data(NG_ANIMATE_CHILDREN_DATA, true);
                        } else {
                            setData($interpolate(val)(scope));
                            attrs.$observe("ngAnimateChildren", setData);
                        }
                        function setData(value) {
                            value = value === "on" || value === "true";
                            element.data(NG_ANIMATE_CHILDREN_DATA, value);
                        }
                    }
                };
            } ];
            var ANIMATE_TIMER_KEY = "$$animateCss";
            var ONE_SECOND = 1e3;
            var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
            var CLOSING_TIME_BUFFER = 1.5;
            var DETECT_CSS_PROPERTIES = {
                transitionDuration: TRANSITION_DURATION_PROP,
                transitionDelay: TRANSITION_DELAY_PROP,
                transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
                animationDuration: ANIMATION_DURATION_PROP,
                animationDelay: ANIMATION_DELAY_PROP,
                animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
            };
            var DETECT_STAGGER_CSS_PROPERTIES = {
                transitionDuration: TRANSITION_DURATION_PROP,
                transitionDelay: TRANSITION_DELAY_PROP,
                animationDuration: ANIMATION_DURATION_PROP,
                animationDelay: ANIMATION_DELAY_PROP
            };
            function getCssKeyframeDurationStyle(duration) {
                return [ ANIMATION_DURATION_PROP, duration + "s" ];
            }
            function getCssDelayStyle(delay, isKeyframeAnimation) {
                var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
                return [ prop, delay + "s" ];
            }
            function computeCssStyles($window, element, properties) {
                var styles = Object.create(null);
                var detectedStyles = $window.getComputedStyle(element) || {};
                forEach(properties, function(formalStyleName, actualStyleName) {
                    var val = detectedStyles[formalStyleName];
                    if (val) {
                        var c = val.charAt(0);
                        if (c === "-" || c === "+" || c >= 0) {
                            val = parseMaxTime(val);
                        }
                        if (val === 0) {
                            val = null;
                        }
                        styles[actualStyleName] = val;
                    }
                });
                return styles;
            }
            function parseMaxTime(str) {
                var maxValue = 0;
                var values = str.split(/\s*,\s*/);
                forEach(values, function(value) {
                    if (value.charAt(value.length - 1) === "s") {
                        value = value.substring(0, value.length - 1);
                    }
                    value = parseFloat(value) || 0;
                    maxValue = maxValue ? Math.max(value, maxValue) : value;
                });
                return maxValue;
            }
            function truthyTimingValue(val) {
                return val === 0 || val != null;
            }
            function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
                var style = TRANSITION_PROP;
                var value = duration + "s";
                if (applyOnlyDuration) {
                    style += DURATION_KEY;
                } else {
                    value += " linear all";
                }
                return [ style, value ];
            }
            function createLocalCacheLookup() {
                var cache = Object.create(null);
                return {
                    flush: function() {
                        cache = Object.create(null);
                    },
                    count: function(key) {
                        var entry = cache[key];
                        return entry ? entry.total : 0;
                    },
                    get: function(key) {
                        var entry = cache[key];
                        return entry && entry.value;
                    },
                    put: function(key, value) {
                        if (!cache[key]) {
                            cache[key] = {
                                total: 1,
                                value: value
                            };
                        } else {
                            cache[key].total++;
                        }
                    }
                };
            }
            function registerRestorableStyles(backup, node, properties) {
                forEach(properties, function(prop) {
                    backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
                });
            }
            var $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
                var gcsLookup = createLocalCacheLookup();
                var gcsStaggerLookup = createLocalCacheLookup();
                this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
                    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    var parentCounter = 0;
                    function gcsHashFn(node, extraClasses) {
                        var KEY = "$$ngAnimateParentKey";
                        var parentNode = node.parentNode;
                        var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                        return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
                    }
                    function computeCachedCssStyles(node, className, cacheKey, properties) {
                        var timings = gcsLookup.get(cacheKey);
                        if (!timings) {
                            timings = computeCssStyles($window, node, properties);
                            if (timings.animationIterationCount === "infinite") {
                                timings.animationIterationCount = 1;
                            }
                        }
                        gcsLookup.put(cacheKey, timings);
                        return timings;
                    }
                    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                        var stagger;
                        if (gcsLookup.count(cacheKey) > 0) {
                            stagger = gcsStaggerLookup.get(cacheKey);
                            if (!stagger) {
                                var staggerClassName = pendClasses(className, "-stagger");
                                $$jqLite.addClass(node, staggerClassName);
                                stagger = computeCssStyles($window, node, properties);
                                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                                $$jqLite.removeClass(node, staggerClassName);
                                gcsStaggerLookup.put(cacheKey, stagger);
                            }
                        }
                        return stagger || {};
                    }
                    var rafWaitQueue = [];
                    function waitUntilQuiet(callback) {
                        rafWaitQueue.push(callback);
                        $$rAFScheduler.waitUntilQuiet(function() {
                            gcsLookup.flush();
                            gcsStaggerLookup.flush();
                            var pageWidth = $$forceReflow();
                            for (var i = 0; i < rafWaitQueue.length; i++) {
                                rafWaitQueue[i](pageWidth);
                            }
                            rafWaitQueue.length = 0;
                        });
                    }
                    function computeTimings(node, className, cacheKey) {
                        var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
                        var aD = timings.animationDelay;
                        var tD = timings.transitionDelay;
                        timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
                        timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
                        return timings;
                    }
                    return function init(element, initialOptions) {
                        var options = initialOptions || {};
                        if (!options.$$prepared) {
                            options = prepareAnimationOptions(copy(options));
                        }
                        var restoreStyles = {};
                        var node = getDomNode(element);
                        if (!node || !node.parentNode || !$$animateQueue.enabled()) {
                            return closeAndReturnNoopAnimator();
                        }
                        var temporaryStyles = [];
                        var classes = element.attr("class");
                        var styles = packageStyles(options);
                        var animationClosed;
                        var animationPaused;
                        var animationCompleted;
                        var runner;
                        var runnerHost;
                        var maxDelay;
                        var maxDelayTime;
                        var maxDuration;
                        var maxDurationTime;
                        var startTime;
                        var events = [];
                        if (options.duration === 0 || !$sniffer.animations && !$sniffer.transitions) {
                            return closeAndReturnNoopAnimator();
                        }
                        var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event;
                        var isStructural = method && options.structural;
                        var structuralClassName = "";
                        var addRemoveClassName = "";
                        if (isStructural) {
                            structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
                        } else if (method) {
                            structuralClassName = method;
                        }
                        if (options.addClass) {
                            addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
                        }
                        if (options.removeClass) {
                            if (addRemoveClassName.length) {
                                addRemoveClassName += " ";
                            }
                            addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
                        }
                        if (options.applyClassesEarly && addRemoveClassName.length) {
                            applyAnimationClasses(element, options);
                        }
                        var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim();
                        var fullClassName = classes + " " + preparationClasses;
                        var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
                        var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
                        var containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                        if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
                            return closeAndReturnNoopAnimator();
                        }
                        var cacheKey, stagger;
                        if (options.stagger > 0) {
                            var staggerVal = parseFloat(options.stagger);
                            stagger = {
                                transitionDelay: staggerVal,
                                animationDelay: staggerVal,
                                transitionDuration: 0,
                                animationDuration: 0
                            };
                        } else {
                            cacheKey = gcsHashFn(node, fullClassName);
                            stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                        }
                        if (!options.$$skipPreparationClasses) {
                            $$jqLite.addClass(element, preparationClasses);
                        }
                        var applyOnlyDuration;
                        if (options.transitionStyle) {
                            var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                            applyInlineStyle(node, transitionStyle);
                            temporaryStyles.push(transitionStyle);
                        }
                        if (options.duration >= 0) {
                            applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                            var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                            applyInlineStyle(node, durationStyle);
                            temporaryStyles.push(durationStyle);
                        }
                        if (options.keyframeStyle) {
                            var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                            applyInlineStyle(node, keyframeStyle);
                            temporaryStyles.push(keyframeStyle);
                        }
                        var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
                        var isFirst = itemIndex === 0;
                        if (isFirst && !options.skipBlocking) {
                            blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                        }
                        var timings = computeTimings(node, fullClassName, cacheKey);
                        var relativeDelay = timings.maxDelay;
                        maxDelay = Math.max(relativeDelay, 0);
                        maxDuration = timings.maxDuration;
                        var flags = {};
                        flags.hasTransitions = timings.transitionDuration > 0;
                        flags.hasAnimations = timings.animationDuration > 0;
                        flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty === "all";
                        flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions);
                        flags.applyAnimationDuration = options.duration && flags.hasAnimations;
                        flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
                        flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
                        flags.recalculateTimingStyles = addRemoveClassName.length > 0;
                        if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
                            maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
                            if (flags.applyTransitionDuration) {
                                flags.hasTransitions = true;
                                timings.transitionDuration = maxDuration;
                                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
                            }
                            if (flags.applyAnimationDuration) {
                                flags.hasAnimations = true;
                                timings.animationDuration = maxDuration;
                                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
                            }
                        }
                        if (maxDuration === 0 && !flags.recalculateTimingStyles) {
                            return closeAndReturnNoopAnimator();
                        }
                        if (options.delay != null) {
                            var delayStyle;
                            if (typeof options.delay !== "boolean") {
                                delayStyle = parseFloat(options.delay);
                                maxDelay = Math.max(delayStyle, 0);
                            }
                            if (flags.applyTransitionDelay) {
                                temporaryStyles.push(getCssDelayStyle(delayStyle));
                            }
                            if (flags.applyAnimationDelay) {
                                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
                            }
                        }
                        if (options.duration == null && timings.transitionDuration > 0) {
                            flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
                        }
                        maxDelayTime = maxDelay * ONE_SECOND;
                        maxDurationTime = maxDuration * ONE_SECOND;
                        if (!options.skipBlocking) {
                            flags.blockTransition = timings.transitionDuration > 0;
                            flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                        }
                        if (options.from) {
                            if (options.cleanupStyles) {
                                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
                            }
                            applyAnimationFromStyles(element, options);
                        }
                        if (flags.blockTransition || flags.blockKeyframeAnimation) {
                            applyBlocking(maxDuration);
                        } else if (!options.skipBlocking) {
                            blockTransitions(node, false);
                        }
                        return {
                            $$willAnimate: true,
                            end: endFn,
                            start: function() {
                                if (animationClosed) return;
                                runnerHost = {
                                    end: endFn,
                                    cancel: cancelFn,
                                    resume: null,
                                    pause: null
                                };
                                runner = new $$AnimateRunner(runnerHost);
                                waitUntilQuiet(start);
                                return runner;
                            }
                        };
                        function endFn() {
                            close();
                        }
                        function cancelFn() {
                            close(true);
                        }
                        function close(rejected) {
                            if (animationClosed || animationCompleted && animationPaused) return;
                            animationClosed = true;
                            animationPaused = false;
                            if (!options.$$skipPreparationClasses) {
                                $$jqLite.removeClass(element, preparationClasses);
                            }
                            $$jqLite.removeClass(element, activeClasses);
                            blockKeyframeAnimations(node, false);
                            blockTransitions(node, false);
                            forEach(temporaryStyles, function(entry) {
                                node.style[entry[0]] = "";
                            });
                            applyAnimationClasses(element, options);
                            applyAnimationStyles(element, options);
                            if (Object.keys(restoreStyles).length) {
                                forEach(restoreStyles, function(value, prop) {
                                    if (value) {
                                        node.style.setProperty(prop, value);
                                    } else {
                                        node.style.removeProperty(prop);
                                    }
                                });
                            }
                            if (options.onDone) {
                                options.onDone();
                            }
                            if (events && events.length) {
                                element.off(events.join(" "), onAnimationProgress);
                            }
                            var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                            if (animationTimerData) {
                                $timeout.cancel(animationTimerData[0].timer);
                                element.removeData(ANIMATE_TIMER_KEY);
                            }
                            if (runner) {
                                runner.complete(!rejected);
                            }
                        }
                        function applyBlocking(duration) {
                            if (flags.blockTransition) {
                                blockTransitions(node, duration);
                            }
                            if (flags.blockKeyframeAnimation) {
                                blockKeyframeAnimations(node, !!duration);
                            }
                        }
                        function closeAndReturnNoopAnimator() {
                            runner = new $$AnimateRunner({
                                end: endFn,
                                cancel: cancelFn
                            });
                            waitUntilQuiet(noop);
                            close();
                            return {
                                $$willAnimate: false,
                                start: function() {
                                    return runner;
                                },
                                end: endFn
                            };
                        }
                        function onAnimationProgress(event) {
                            event.stopPropagation();
                            var ev = event.originalEvent || event;
                            if (ev.target !== node) {
                                return;
                            }
                            var timeStamp = ev.$manualTimeStamp || Date.now();
                            var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                            if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                                animationCompleted = true;
                                close();
                            }
                        }
                        function start() {
                            if (animationClosed) return;
                            if (!node.parentNode) {
                                close();
                                return;
                            }
                            var playPause = function(playAnimation) {
                                if (!animationCompleted) {
                                    animationPaused = !playAnimation;
                                    if (timings.animationDuration) {
                                        var value = blockKeyframeAnimations(node, animationPaused);
                                        if (animationPaused) {
                                            temporaryStyles.push(value);
                                        } else {
                                            removeFromArray(temporaryStyles, value);
                                        }
                                    }
                                } else if (animationPaused && playAnimation) {
                                    animationPaused = false;
                                    close();
                                }
                            };
                            var maxStagger = itemIndex > 0 && (timings.transitionDuration && stagger.transitionDuration === 0 || timings.animationDuration && stagger.animationDuration === 0) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                            if (maxStagger) {
                                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
                            } else {
                                triggerAnimationStart();
                            }
                            runnerHost.resume = function() {
                                playPause(true);
                            };
                            runnerHost.pause = function() {
                                playPause(false);
                            };
                            function triggerAnimationStart() {
                                if (animationClosed) return;
                                applyBlocking(false);
                                forEach(temporaryStyles, function(entry) {
                                    var key = entry[0];
                                    var value = entry[1];
                                    node.style[key] = value;
                                });
                                applyAnimationClasses(element, options);
                                $$jqLite.addClass(element, activeClasses);
                                if (flags.recalculateTimingStyles) {
                                    fullClassName = node.getAttribute("class") + " " + preparationClasses;
                                    cacheKey = gcsHashFn(node, fullClassName);
                                    timings = computeTimings(node, fullClassName, cacheKey);
                                    relativeDelay = timings.maxDelay;
                                    maxDelay = Math.max(relativeDelay, 0);
                                    maxDuration = timings.maxDuration;
                                    if (maxDuration === 0) {
                                        close();
                                        return;
                                    }
                                    flags.hasTransitions = timings.transitionDuration > 0;
                                    flags.hasAnimations = timings.animationDuration > 0;
                                }
                                if (flags.applyAnimationDelay) {
                                    relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                                    maxDelay = Math.max(relativeDelay, 0);
                                    timings.animationDelay = relativeDelay;
                                    delayStyle = getCssDelayStyle(relativeDelay, true);
                                    temporaryStyles.push(delayStyle);
                                    node.style[delayStyle[0]] = delayStyle[1];
                                }
                                maxDelayTime = maxDelay * ONE_SECOND;
                                maxDurationTime = maxDuration * ONE_SECOND;
                                if (options.easing) {
                                    var easeProp, easeVal = options.easing;
                                    if (flags.hasTransitions) {
                                        easeProp = TRANSITION_PROP + TIMING_KEY;
                                        temporaryStyles.push([ easeProp, easeVal ]);
                                        node.style[easeProp] = easeVal;
                                    }
                                    if (flags.hasAnimations) {
                                        easeProp = ANIMATION_PROP + TIMING_KEY;
                                        temporaryStyles.push([ easeProp, easeVal ]);
                                        node.style[easeProp] = easeVal;
                                    }
                                }
                                if (timings.transitionDuration) {
                                    events.push(TRANSITIONEND_EVENT);
                                }
                                if (timings.animationDuration) {
                                    events.push(ANIMATIONEND_EVENT);
                                }
                                startTime = Date.now();
                                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                                var endTime = startTime + timerTime;
                                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                                var setupFallbackTimer = true;
                                if (animationsData.length) {
                                    var currentTimerData = animationsData[0];
                                    setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                                    if (setupFallbackTimer) {
                                        $timeout.cancel(currentTimerData.timer);
                                    } else {
                                        animationsData.push(close);
                                    }
                                }
                                if (setupFallbackTimer) {
                                    var timer = $timeout(onAnimationExpired, timerTime, false);
                                    animationsData[0] = {
                                        timer: timer,
                                        expectedEndTime: endTime
                                    };
                                    animationsData.push(close);
                                    element.data(ANIMATE_TIMER_KEY, animationsData);
                                }
                                if (events.length) {
                                    element.on(events.join(" "), onAnimationProgress);
                                }
                                if (options.to) {
                                    if (options.cleanupStyles) {
                                        registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                                    }
                                    applyAnimationToStyles(element, options);
                                }
                            }
                            function onAnimationExpired() {
                                var animationsData = element.data(ANIMATE_TIMER_KEY);
                                if (animationsData) {
                                    for (var i = 1; i < animationsData.length; i++) {
                                        animationsData[i]();
                                    }
                                    element.removeData(ANIMATE_TIMER_KEY);
                                }
                            }
                        }
                    };
                } ];
            } ];
            var $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
                $$animationProvider.drivers.push("$$animateCssDriver");
                var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";
                var NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";
                var NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";
                var NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
                function isDocumentFragment(node) {
                    return node.parentNode && node.parentNode.nodeType === 11;
                }
                this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
                    if (!$sniffer.animations && !$sniffer.transitions) return noop;
                    var bodyNode = $document[0].body;
                    var rootNode = getDomNode($rootElement);
                    var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
                    return function initDriverFn(animationDetails) {
                        return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
                    };
                    function filterCssClasses(classes) {
                        return classes.replace(/\bng-\S+\b/g, "");
                    }
                    function getUniqueValues(a, b) {
                        if (isString(a)) a = a.split(" ");
                        if (isString(b)) b = b.split(" ");
                        return a.filter(function(val) {
                            return b.indexOf(val) === -1;
                        }).join(" ");
                    }
                    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                        var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
                        var startingClasses = filterCssClasses(getClassVal(clone));
                        outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                        inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                        clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
                        rootBodyElement.append(clone);
                        var animatorIn, animatorOut = prepareOutAnimation();
                        if (!animatorOut) {
                            animatorIn = prepareInAnimation();
                            if (!animatorIn) {
                                return end();
                            }
                        }
                        var startingAnimator = animatorOut || animatorIn;
                        return {
                            start: function() {
                                var runner;
                                var currentAnimation = startingAnimator.start();
                                currentAnimation.done(function() {
                                    currentAnimation = null;
                                    if (!animatorIn) {
                                        animatorIn = prepareInAnimation();
                                        if (animatorIn) {
                                            currentAnimation = animatorIn.start();
                                            currentAnimation.done(function() {
                                                currentAnimation = null;
                                                end();
                                                runner.complete();
                                            });
                                            return currentAnimation;
                                        }
                                    }
                                    end();
                                    runner.complete();
                                });
                                runner = new $$AnimateRunner({
                                    end: endFn,
                                    cancel: endFn
                                });
                                return runner;
                                function endFn() {
                                    if (currentAnimation) {
                                        currentAnimation.end();
                                    }
                                }
                            }
                        };
                        function calculateAnchorStyles(anchor) {
                            var styles = {};
                            var coords = getDomNode(anchor).getBoundingClientRect();
                            forEach([ "width", "height", "top", "left" ], function(key) {
                                var value = coords[key];
                                switch (key) {
                                  case "top":
                                    value += bodyNode.scrollTop;
                                    break;

                                  case "left":
                                    value += bodyNode.scrollLeft;
                                    break;
                                }
                                styles[key] = Math.floor(value) + "px";
                            });
                            return styles;
                        }
                        function prepareOutAnimation() {
                            var animator = $animateCss(clone, {
                                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                                delay: true,
                                from: calculateAnchorStyles(outAnchor)
                            });
                            return animator.$$willAnimate ? animator : null;
                        }
                        function getClassVal(element) {
                            return element.attr("class") || "";
                        }
                        function prepareInAnimation() {
                            var endingClasses = filterCssClasses(getClassVal(inAnchor));
                            var toAdd = getUniqueValues(endingClasses, startingClasses);
                            var toRemove = getUniqueValues(startingClasses, endingClasses);
                            var animator = $animateCss(clone, {
                                to: calculateAnchorStyles(inAnchor),
                                addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                                removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                                delay: true
                            });
                            return animator.$$willAnimate ? animator : null;
                        }
                        function end() {
                            clone.remove();
                            outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                        }
                    }
                    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                        var fromAnimation = prepareRegularAnimation(from, noop);
                        var toAnimation = prepareRegularAnimation(to, noop);
                        var anchorAnimations = [];
                        forEach(anchors, function(anchor) {
                            var outElement = anchor["out"];
                            var inElement = anchor["in"];
                            var animator = prepareAnchoredAnimation(classes, outElement, inElement);
                            if (animator) {
                                anchorAnimations.push(animator);
                            }
                        });
                        if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;
                        return {
                            start: function() {
                                var animationRunners = [];
                                if (fromAnimation) {
                                    animationRunners.push(fromAnimation.start());
                                }
                                if (toAnimation) {
                                    animationRunners.push(toAnimation.start());
                                }
                                forEach(anchorAnimations, function(animation) {
                                    animationRunners.push(animation.start());
                                });
                                var runner = new $$AnimateRunner({
                                    end: endFn,
                                    cancel: endFn
                                });
                                $$AnimateRunner.all(animationRunners, function(status) {
                                    runner.complete(status);
                                });
                                return runner;
                                function endFn() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                }
                            }
                        };
                    }
                    function prepareRegularAnimation(animationDetails) {
                        var element = animationDetails.element;
                        var options = animationDetails.options || {};
                        if (animationDetails.structural) {
                            options.event = animationDetails.event;
                            options.structural = true;
                            options.applyClassesEarly = true;
                            if (animationDetails.event === "leave") {
                                options.onDone = options.domOperation;
                            }
                        }
                        if (options.preparationClasses) {
                            options.event = concatWithSpace(options.event, options.preparationClasses);
                        }
                        var animator = $animateCss(element, options);
                        return animator.$$willAnimate ? animator : null;
                    }
                } ];
            } ];
            var $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
                this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
                    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    return function(element, event, classes, options) {
                        var animationClosed = false;
                        if (arguments.length === 3 && isObject(classes)) {
                            options = classes;
                            classes = null;
                        }
                        options = prepareAnimationOptions(options);
                        if (!classes) {
                            classes = element.attr("class") || "";
                            if (options.addClass) {
                                classes += " " + options.addClass;
                            }
                            if (options.removeClass) {
                                classes += " " + options.removeClass;
                            }
                        }
                        var classesToAdd = options.addClass;
                        var classesToRemove = options.removeClass;
                        var animations = lookupAnimations(classes);
                        var before, after;
                        if (animations.length) {
                            var afterFn, beforeFn;
                            if (event === "leave") {
                                beforeFn = "leave";
                                afterFn = "afterLeave";
                            } else {
                                beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1);
                                afterFn = event;
                            }
                            if (event !== "enter" && event !== "move") {
                                before = packageAnimations(element, event, options, animations, beforeFn);
                            }
                            after = packageAnimations(element, event, options, animations, afterFn);
                        }
                        if (!before && !after) return;
                        function applyOptions() {
                            options.domOperation();
                            applyAnimationClasses(element, options);
                        }
                        function close() {
                            animationClosed = true;
                            applyOptions();
                            applyAnimationStyles(element, options);
                        }
                        var runner;
                        return {
                            $$willAnimate: true,
                            end: function() {
                                if (runner) {
                                    runner.end();
                                } else {
                                    close();
                                    runner = new $$AnimateRunner();
                                    runner.complete(true);
                                }
                                return runner;
                            },
                            start: function() {
                                if (runner) {
                                    return runner;
                                }
                                runner = new $$AnimateRunner();
                                var closeActiveAnimations;
                                var chain = [];
                                if (before) {
                                    chain.push(function(fn) {
                                        closeActiveAnimations = before(fn);
                                    });
                                }
                                if (chain.length) {
                                    chain.push(function(fn) {
                                        applyOptions();
                                        fn(true);
                                    });
                                } else {
                                    applyOptions();
                                }
                                if (after) {
                                    chain.push(function(fn) {
                                        closeActiveAnimations = after(fn);
                                    });
                                }
                                runner.setHost({
                                    end: function() {
                                        endAnimations();
                                    },
                                    cancel: function() {
                                        endAnimations(true);
                                    }
                                });
                                $$AnimateRunner.chain(chain, onComplete);
                                return runner;
                                function onComplete(success) {
                                    close(success);
                                    runner.complete(success);
                                }
                                function endAnimations(cancelled) {
                                    if (!animationClosed) {
                                        (closeActiveAnimations || noop)(cancelled);
                                        onComplete(cancelled);
                                    }
                                }
                            }
                        };
                        function executeAnimationFn(fn, element, event, options, onDone) {
                            var args;
                            switch (event) {
                              case "animate":
                                args = [ element, options.from, options.to, onDone ];
                                break;

                              case "setClass":
                                args = [ element, classesToAdd, classesToRemove, onDone ];
                                break;

                              case "addClass":
                                args = [ element, classesToAdd, onDone ];
                                break;

                              case "removeClass":
                                args = [ element, classesToRemove, onDone ];
                                break;

                              default:
                                args = [ element, onDone ];
                                break;
                            }
                            args.push(options);
                            var value = fn.apply(fn, args);
                            if (value) {
                                if (isFunction(value.start)) {
                                    value = value.start();
                                }
                                if (value instanceof $$AnimateRunner) {
                                    value.done(onDone);
                                } else if (isFunction(value)) {
                                    return value;
                                }
                            }
                            return noop;
                        }
                        function groupEventedAnimations(element, event, options, animations, fnName) {
                            var operations = [];
                            forEach(animations, function(ani) {
                                var animation = ani[fnName];
                                if (!animation) return;
                                operations.push(function() {
                                    var runner;
                                    var endProgressCb;
                                    var resolved = false;
                                    var onAnimationComplete = function(rejected) {
                                        if (!resolved) {
                                            resolved = true;
                                            (endProgressCb || noop)(rejected);
                                            runner.complete(!rejected);
                                        }
                                    };
                                    runner = new $$AnimateRunner({
                                        end: function() {
                                            onAnimationComplete();
                                        },
                                        cancel: function() {
                                            onAnimationComplete(true);
                                        }
                                    });
                                    endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                        var cancelled = result === false;
                                        onAnimationComplete(cancelled);
                                    });
                                    return runner;
                                });
                            });
                            return operations;
                        }
                        function packageAnimations(element, event, options, animations, fnName) {
                            var operations = groupEventedAnimations(element, event, options, animations, fnName);
                            if (operations.length === 0) {
                                var a, b;
                                if (fnName === "beforeSetClass") {
                                    a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass");
                                    b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass");
                                } else if (fnName === "setClass") {
                                    a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass");
                                    b = groupEventedAnimations(element, "addClass", options, animations, "addClass");
                                }
                                if (a) {
                                    operations = operations.concat(a);
                                }
                                if (b) {
                                    operations = operations.concat(b);
                                }
                            }
                            if (operations.length === 0) return;
                            return function startAnimation(callback) {
                                var runners = [];
                                if (operations.length) {
                                    forEach(operations, function(animateFn) {
                                        runners.push(animateFn());
                                    });
                                }
                                if (runners.length) {
                                    $$AnimateRunner.all(runners, callback);
                                } else {
                                    callback();
                                }
                                return function endFn(reject) {
                                    forEach(runners, function(runner) {
                                        if (reject) {
                                            runner.cancel();
                                        } else {
                                            runner.end();
                                        }
                                    });
                                };
                            };
                        }
                    };
                    function lookupAnimations(classes) {
                        classes = isArray(classes) ? classes : classes.split(" ");
                        var matches = [], flagMap = {};
                        for (var i = 0; i < classes.length; i++) {
                            var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                            if (animationFactory && !flagMap[klass]) {
                                matches.push($injector.get(animationFactory));
                                flagMap[klass] = true;
                            }
                        }
                        return matches;
                    }
                } ];
            } ];
            var $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
                $$animationProvider.drivers.push("$$animateJsDriver");
                this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
                    return function initDriverFn(animationDetails) {
                        if (animationDetails.from && animationDetails.to) {
                            var fromAnimation = prepareAnimation(animationDetails.from);
                            var toAnimation = prepareAnimation(animationDetails.to);
                            if (!fromAnimation && !toAnimation) return;
                            return {
                                start: function() {
                                    var animationRunners = [];
                                    if (fromAnimation) {
                                        animationRunners.push(fromAnimation.start());
                                    }
                                    if (toAnimation) {
                                        animationRunners.push(toAnimation.start());
                                    }
                                    $$AnimateRunner.all(animationRunners, done);
                                    var runner = new $$AnimateRunner({
                                        end: endFnFactory(),
                                        cancel: endFnFactory()
                                    });
                                    return runner;
                                    function endFnFactory() {
                                        return function() {
                                            forEach(animationRunners, function(runner) {
                                                runner.end();
                                            });
                                        };
                                    }
                                    function done(status) {
                                        runner.complete(status);
                                    }
                                }
                            };
                        } else {
                            return prepareAnimation(animationDetails);
                        }
                    };
                    function prepareAnimation(animationDetails) {
                        var element = animationDetails.element;
                        var event = animationDetails.event;
                        var options = animationDetails.options;
                        var classes = animationDetails.classes;
                        return $$animateJs(element, event, classes, options);
                    }
                } ];
            } ];
            var NG_ANIMATE_ATTR_NAME = "data-ng-animate";
            var NG_ANIMATE_PIN_DATA = "$ngAnimatePin";
            var $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
                var PRE_DIGEST_STATE = 1;
                var RUNNING_STATE = 2;
                var ONE_SPACE = " ";
                var rules = this.rules = {
                    skip: [],
                    cancel: [],
                    join: []
                };
                function makeTruthyCssClassMap(classString) {
                    if (!classString) {
                        return null;
                    }
                    var keys = classString.split(ONE_SPACE);
                    var map = Object.create(null);
                    forEach(keys, function(key) {
                        map[key] = true;
                    });
                    return map;
                }
                function hasMatchingClasses(newClassString, currentClassString) {
                    if (newClassString && currentClassString) {
                        var currentClassMap = makeTruthyCssClassMap(currentClassString);
                        return newClassString.split(ONE_SPACE).some(function(className) {
                            return currentClassMap[className];
                        });
                    }
                }
                function isAllowed(ruleType, currentAnimation, previousAnimation) {
                    return rules[ruleType].some(function(fn) {
                        return fn(currentAnimation, previousAnimation);
                    });
                }
                function hasAnimationClasses(animation, and) {
                    var a = (animation.addClass || "").length > 0;
                    var b = (animation.removeClass || "").length > 0;
                    return and ? a && b : a || b;
                }
                rules.join.push(function(newAnimation, currentAnimation) {
                    return !newAnimation.structural && hasAnimationClasses(newAnimation);
                });
                rules.skip.push(function(newAnimation, currentAnimation) {
                    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
                });
                rules.skip.push(function(newAnimation, currentAnimation) {
                    return currentAnimation.event === "leave" && newAnimation.structural;
                });
                rules.skip.push(function(newAnimation, currentAnimation) {
                    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
                });
                rules.cancel.push(function(newAnimation, currentAnimation) {
                    return currentAnimation.structural && newAnimation.structural;
                });
                rules.cancel.push(function(newAnimation, currentAnimation) {
                    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
                });
                rules.cancel.push(function(newAnimation, currentAnimation) {
                    if (currentAnimation.structural) return false;
                    var nA = newAnimation.addClass;
                    var nR = newAnimation.removeClass;
                    var cA = currentAnimation.addClass;
                    var cR = currentAnimation.removeClass;
                    if (isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) {
                        return false;
                    }
                    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
                });
                this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function($$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
                    var activeAnimationsLookup = new $$Map();
                    var disabledElementsLookup = new $$Map();
                    var animationsEnabled = null;
                    function postDigestTaskFactory() {
                        var postDigestCalled = false;
                        return function(fn) {
                            if (postDigestCalled) {
                                fn();
                            } else {
                                $rootScope.$$postDigest(function() {
                                    postDigestCalled = true;
                                    fn();
                                });
                            }
                        };
                    }
                    var deregisterWatch = $rootScope.$watch(function() {
                        return $templateRequest.totalPendingRequests === 0;
                    }, function(isEmpty) {
                        if (!isEmpty) return;
                        deregisterWatch();
                        $rootScope.$$postDigest(function() {
                            $rootScope.$$postDigest(function() {
                                if (animationsEnabled === null) {
                                    animationsEnabled = true;
                                }
                            });
                        });
                    });
                    var callbackRegistry = Object.create(null);
                    var customFilter = $animateProvider.customFilter();
                    var classNameFilter = $animateProvider.classNameFilter();
                    var returnTrue = function() {
                        return true;
                    };
                    var isAnimatableByFilter = customFilter || returnTrue;
                    var isAnimatableClassName = !classNameFilter ? returnTrue : function(node, options) {
                        var className = [ node.getAttribute("class"), options.addClass, options.removeClass ].join(" ");
                        return classNameFilter.test(className);
                    };
                    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    function normalizeAnimationDetails(element, animation) {
                        return mergeAnimationDetails(element, animation, {});
                    }
                    var contains = window.Node.prototype.contains || function(arg) {
                        return this === arg || !!(this.compareDocumentPosition(arg) & 16);
                    };
                    function findCallbacks(targetParentNode, targetNode, event) {
                        var matches = [];
                        var entries = callbackRegistry[event];
                        if (entries) {
                            forEach(entries, function(entry) {
                                if (contains.call(entry.node, targetNode)) {
                                    matches.push(entry.callback);
                                } else if (event === "leave" && contains.call(entry.node, targetParentNode)) {
                                    matches.push(entry.callback);
                                }
                            });
                        }
                        return matches;
                    }
                    function filterFromRegistry(list, matchContainer, matchCallback) {
                        var containerNode = extractElementNode(matchContainer);
                        return list.filter(function(entry) {
                            var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                            return !isMatch;
                        });
                    }
                    function cleanupEventListeners(phase, node) {
                        if (phase === "close" && !node.parentNode) {
                            $animate.off(node);
                        }
                    }
                    var $animate = {
                        on: function(event, container, callback) {
                            var node = extractElementNode(container);
                            callbackRegistry[event] = callbackRegistry[event] || [];
                            callbackRegistry[event].push({
                                node: node,
                                callback: callback
                            });
                            jqLite(container).on("$destroy", function() {
                                var animationDetails = activeAnimationsLookup.get(node);
                                if (!animationDetails) {
                                    $animate.off(event, container, callback);
                                }
                            });
                        },
                        off: function(event, container, callback) {
                            if (arguments.length === 1 && !isString(arguments[0])) {
                                container = arguments[0];
                                for (var eventType in callbackRegistry) {
                                    callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                                }
                                return;
                            }
                            var entries = callbackRegistry[event];
                            if (!entries) return;
                            callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
                        },
                        pin: function(element, parentElement) {
                            assertArg(isElement(element), "element", "not an element");
                            assertArg(isElement(parentElement), "parentElement", "not an element");
                            element.data(NG_ANIMATE_PIN_DATA, parentElement);
                        },
                        push: function(element, event, options, domOperation) {
                            options = options || {};
                            options.domOperation = domOperation;
                            return queueAnimation(element, event, options);
                        },
                        enabled: function(element, bool) {
                            var argCount = arguments.length;
                            if (argCount === 0) {
                                bool = !!animationsEnabled;
                            } else {
                                var hasElement = isElement(element);
                                if (!hasElement) {
                                    bool = animationsEnabled = !!element;
                                } else {
                                    var node = getDomNode(element);
                                    if (argCount === 1) {
                                        bool = !disabledElementsLookup.get(node);
                                    } else {
                                        disabledElementsLookup.set(node, !bool);
                                    }
                                }
                            }
                            return bool;
                        }
                    };
                    return $animate;
                    function queueAnimation(originalElement, event, initialOptions) {
                        var options = copy(initialOptions);
                        var element = stripCommentsFromElement(originalElement);
                        var node = getDomNode(element);
                        var parentNode = node && node.parentNode;
                        options = prepareAnimationOptions(options);
                        var runner = new $$AnimateRunner();
                        var runInNextPostDigestOrNow = postDigestTaskFactory();
                        if (isArray(options.addClass)) {
                            options.addClass = options.addClass.join(" ");
                        }
                        if (options.addClass && !isString(options.addClass)) {
                            options.addClass = null;
                        }
                        if (isArray(options.removeClass)) {
                            options.removeClass = options.removeClass.join(" ");
                        }
                        if (options.removeClass && !isString(options.removeClass)) {
                            options.removeClass = null;
                        }
                        if (options.from && !isObject(options.from)) {
                            options.from = null;
                        }
                        if (options.to && !isObject(options.to)) {
                            options.to = null;
                        }
                        if (!animationsEnabled || !node || !isAnimatableByFilter(node, event, initialOptions) || !isAnimatableClassName(node, options)) {
                            close();
                            return runner;
                        }
                        var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0;
                        var documentHidden = $$isDocumentHidden();
                        var skipAnimations = documentHidden || disabledElementsLookup.get(node);
                        var existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {};
                        var hasExistingAnimation = !!existingAnimation.state;
                        if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {
                            skipAnimations = !areAnimationsAllowed(node, parentNode, event);
                        }
                        if (skipAnimations) {
                            if (documentHidden) notifyProgress(runner, event, "start");
                            close();
                            if (documentHidden) notifyProgress(runner, event, "close");
                            return runner;
                        }
                        if (isStructural) {
                            closeChildAnimations(node);
                        }
                        var newAnimation = {
                            structural: isStructural,
                            element: element,
                            event: event,
                            addClass: options.addClass,
                            removeClass: options.removeClass,
                            close: close,
                            options: options,
                            runner: runner
                        };
                        if (hasExistingAnimation) {
                            var skipAnimationFlag = isAllowed("skip", newAnimation, existingAnimation);
                            if (skipAnimationFlag) {
                                if (existingAnimation.state === RUNNING_STATE) {
                                    close();
                                    return runner;
                                } else {
                                    mergeAnimationDetails(element, existingAnimation, newAnimation);
                                    return existingAnimation.runner;
                                }
                            }
                            var cancelAnimationFlag = isAllowed("cancel", newAnimation, existingAnimation);
                            if (cancelAnimationFlag) {
                                if (existingAnimation.state === RUNNING_STATE) {
                                    existingAnimation.runner.end();
                                } else if (existingAnimation.structural) {
                                    existingAnimation.close();
                                } else {
                                    mergeAnimationDetails(element, existingAnimation, newAnimation);
                                    return existingAnimation.runner;
                                }
                            } else {
                                var joinAnimationFlag = isAllowed("join", newAnimation, existingAnimation);
                                if (joinAnimationFlag) {
                                    if (existingAnimation.state === RUNNING_STATE) {
                                        normalizeAnimationDetails(element, newAnimation);
                                    } else {
                                        applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                                        event = newAnimation.event = existingAnimation.event;
                                        options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                                        return existingAnimation.runner;
                                    }
                                }
                            }
                        } else {
                            normalizeAnimationDetails(element, newAnimation);
                        }
                        var isValidAnimation = newAnimation.structural;
                        if (!isValidAnimation) {
                            isValidAnimation = newAnimation.event === "animate" && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation);
                        }
                        if (!isValidAnimation) {
                            close();
                            clearElementAnimationState(node);
                            return runner;
                        }
                        var counter = (existingAnimation.counter || 0) + 1;
                        newAnimation.counter = counter;
                        markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);
                        $rootScope.$$postDigest(function() {
                            element = stripCommentsFromElement(originalElement);
                            var animationDetails = activeAnimationsLookup.get(node);
                            var animationCancelled = !animationDetails;
                            animationDetails = animationDetails || {};
                            var parentElement = element.parent() || [];
                            var isValidAnimation = parentElement.length > 0 && (animationDetails.event === "animate" || animationDetails.structural || hasAnimationClasses(animationDetails));
                            if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                                if (animationCancelled) {
                                    applyAnimationClasses(element, options);
                                    applyAnimationStyles(element, options);
                                }
                                if (animationCancelled || isStructural && animationDetails.event !== event) {
                                    options.domOperation();
                                    runner.end();
                                }
                                if (!isValidAnimation) {
                                    clearElementAnimationState(node);
                                }
                                return;
                            }
                            event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? "setClass" : animationDetails.event;
                            markElementAnimationState(node, RUNNING_STATE);
                            var realRunner = $$animation(element, event, animationDetails.options);
                            runner.setHost(realRunner);
                            notifyProgress(runner, event, "start", {});
                            realRunner.done(function(status) {
                                close(!status);
                                var animationDetails = activeAnimationsLookup.get(node);
                                if (animationDetails && animationDetails.counter === counter) {
                                    clearElementAnimationState(node);
                                }
                                notifyProgress(runner, event, "close", {});
                            });
                        });
                        return runner;
                        function notifyProgress(runner, event, phase, data) {
                            runInNextPostDigestOrNow(function() {
                                var callbacks = findCallbacks(parentNode, node, event);
                                if (callbacks.length) {
                                    $$rAF(function() {
                                        forEach(callbacks, function(callback) {
                                            callback(element, phase, data);
                                        });
                                        cleanupEventListeners(phase, node);
                                    });
                                } else {
                                    cleanupEventListeners(phase, node);
                                }
                            });
                            runner.progress(event, phase, data);
                        }
                        function close(reject) {
                            clearGeneratedClasses(element, options);
                            applyAnimationClasses(element, options);
                            applyAnimationStyles(element, options);
                            options.domOperation();
                            runner.complete(!reject);
                        }
                    }
                    function closeChildAnimations(node) {
                        var children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                        forEach(children, function(child) {
                            var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
                            var animationDetails = activeAnimationsLookup.get(child);
                            if (animationDetails) {
                                switch (state) {
                                  case RUNNING_STATE:
                                    animationDetails.runner.end();

                                  case PRE_DIGEST_STATE:
                                    activeAnimationsLookup.delete(child);
                                    break;
                                }
                            }
                        });
                    }
                    function clearElementAnimationState(node) {
                        node.removeAttribute(NG_ANIMATE_ATTR_NAME);
                        activeAnimationsLookup.delete(node);
                    }
                    function areAnimationsAllowed(node, parentNode, event) {
                        var bodyNode = $document[0].body;
                        var rootNode = getDomNode($rootElement);
                        var bodyNodeDetected = node === bodyNode || node.nodeName === "HTML";
                        var rootNodeDetected = node === rootNode;
                        var parentAnimationDetected = false;
                        var elementDisabled = disabledElementsLookup.get(node);
                        var animateChildren;
                        var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
                        if (parentHost) {
                            parentNode = getDomNode(parentHost);
                        }
                        while (parentNode) {
                            if (!rootNodeDetected) {
                                rootNodeDetected = parentNode === rootNode;
                            }
                            if (parentNode.nodeType !== ELEMENT_NODE) {
                                break;
                            }
                            var details = activeAnimationsLookup.get(parentNode) || {};
                            if (!parentAnimationDetected) {
                                var parentNodeDisabled = disabledElementsLookup.get(parentNode);
                                if (parentNodeDisabled === true && elementDisabled !== false) {
                                    elementDisabled = true;
                                    break;
                                } else if (parentNodeDisabled === false) {
                                    elementDisabled = false;
                                }
                                parentAnimationDetected = details.structural;
                            }
                            if (isUndefined(animateChildren) || animateChildren === true) {
                                var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
                                if (isDefined(value)) {
                                    animateChildren = value;
                                }
                            }
                            if (parentAnimationDetected && animateChildren === false) break;
                            if (!bodyNodeDetected) {
                                bodyNodeDetected = parentNode === bodyNode;
                            }
                            if (bodyNodeDetected && rootNodeDetected) {
                                break;
                            }
                            if (!rootNodeDetected) {
                                parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);
                                if (parentHost) {
                                    parentNode = getDomNode(parentHost);
                                    continue;
                                }
                            }
                            parentNode = parentNode.parentNode;
                        }
                        var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
                        return allowAnimation && rootNodeDetected && bodyNodeDetected;
                    }
                    function markElementAnimationState(node, state, details) {
                        details = details || {};
                        details.state = state;
                        node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                        var oldValue = activeAnimationsLookup.get(node);
                        var newValue = oldValue ? extend(oldValue, details) : details;
                        activeAnimationsLookup.set(node, newValue);
                    }
                } ];
            } ];
            var $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
                var NG_ANIMATE_REF_ATTR = "ng-animate-ref";
                var drivers = this.drivers = [];
                var RUNNER_STORAGE_KEY = "$$animationRunner";
                function setRunner(element, runner) {
                    element.data(RUNNER_STORAGE_KEY, runner);
                }
                function removeRunner(element) {
                    element.removeData(RUNNER_STORAGE_KEY);
                }
                function getRunner(element) {
                    return element.data(RUNNER_STORAGE_KEY);
                }
                this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler) {
                    var animationQueue = [];
                    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    function sortAnimations(animations) {
                        var tree = {
                            children: []
                        };
                        var i, lookup = new $$Map();
                        for (i = 0; i < animations.length; i++) {
                            var animation = animations[i];
                            lookup.set(animation.domNode, animations[i] = {
                                domNode: animation.domNode,
                                fn: animation.fn,
                                children: []
                            });
                        }
                        for (i = 0; i < animations.length; i++) {
                            processNode(animations[i]);
                        }
                        return flatten(tree);
                        function processNode(entry) {
                            if (entry.processed) return entry;
                            entry.processed = true;
                            var elementNode = entry.domNode;
                            var parentNode = elementNode.parentNode;
                            lookup.set(elementNode, entry);
                            var parentEntry;
                            while (parentNode) {
                                parentEntry = lookup.get(parentNode);
                                if (parentEntry) {
                                    if (!parentEntry.processed) {
                                        parentEntry = processNode(parentEntry);
                                    }
                                    break;
                                }
                                parentNode = parentNode.parentNode;
                            }
                            (parentEntry || tree).children.push(entry);
                            return entry;
                        }
                        function flatten(tree) {
                            var result = [];
                            var queue = [];
                            var i;
                            for (i = 0; i < tree.children.length; i++) {
                                queue.push(tree.children[i]);
                            }
                            var remainingLevelEntries = queue.length;
                            var nextLevelEntries = 0;
                            var row = [];
                            for (i = 0; i < queue.length; i++) {
                                var entry = queue[i];
                                if (remainingLevelEntries <= 0) {
                                    remainingLevelEntries = nextLevelEntries;
                                    nextLevelEntries = 0;
                                    result.push(row);
                                    row = [];
                                }
                                row.push(entry.fn);
                                entry.children.forEach(function(childEntry) {
                                    nextLevelEntries++;
                                    queue.push(childEntry);
                                });
                                remainingLevelEntries--;
                            }
                            if (row.length) {
                                result.push(row);
                            }
                            return result;
                        }
                    }
                    return function(element, event, options) {
                        options = prepareAnimationOptions(options);
                        var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0;
                        var runner = new $$AnimateRunner({
                            end: function() {
                                close();
                            },
                            cancel: function() {
                                close(true);
                            }
                        });
                        if (!drivers.length) {
                            close();
                            return runner;
                        }
                        setRunner(element, runner);
                        var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass));
                        var tempClasses = options.tempClasses;
                        if (tempClasses) {
                            classes += " " + tempClasses;
                            options.tempClasses = null;
                        }
                        var prepareClassName;
                        if (isStructural) {
                            prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX;
                            $$jqLite.addClass(element, prepareClassName);
                        }
                        animationQueue.push({
                            element: element,
                            classes: classes,
                            event: event,
                            structural: isStructural,
                            options: options,
                            beforeStart: beforeStart,
                            close: close
                        });
                        element.on("$destroy", handleDestroyedElement);
                        if (animationQueue.length > 1) return runner;
                        $rootScope.$$postDigest(function() {
                            var animations = [];
                            forEach(animationQueue, function(entry) {
                                if (getRunner(entry.element)) {
                                    animations.push(entry);
                                } else {
                                    entry.close();
                                }
                            });
                            animationQueue.length = 0;
                            var groupedAnimations = groupAnimations(animations);
                            var toBeSortedAnimations = [];
                            forEach(groupedAnimations, function(animationEntry) {
                                toBeSortedAnimations.push({
                                    domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                                    fn: function triggerAnimationStart() {
                                        animationEntry.beforeStart();
                                        var startAnimationFn, closeFn = animationEntry.close;
                                        var targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                        if (getRunner(targetElement)) {
                                            var operation = invokeFirstDriver(animationEntry);
                                            if (operation) {
                                                startAnimationFn = operation.start;
                                            }
                                        }
                                        if (!startAnimationFn) {
                                            closeFn();
                                        } else {
                                            var animationRunner = startAnimationFn();
                                            animationRunner.done(function(status) {
                                                closeFn(!status);
                                            });
                                            updateAnimationRunners(animationEntry, animationRunner);
                                        }
                                    }
                                });
                            });
                            $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                        });
                        return runner;
                        function getAnchorNodes(node) {
                            var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]";
                            var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR);
                            var anchors = [];
                            forEach(items, function(node) {
                                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                                if (attr && attr.length) {
                                    anchors.push(node);
                                }
                            });
                            return anchors;
                        }
                        function groupAnimations(animations) {
                            var preparedAnimations = [];
                            var refLookup = {};
                            forEach(animations, function(animation, index) {
                                var element = animation.element;
                                var node = getDomNode(element);
                                var event = animation.event;
                                var enterOrMove = [ "enter", "move" ].indexOf(event) >= 0;
                                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                                if (anchorNodes.length) {
                                    var direction = enterOrMove ? "to" : "from";
                                    forEach(anchorNodes, function(anchor) {
                                        var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                        refLookup[key] = refLookup[key] || {};
                                        refLookup[key][direction] = {
                                            animationID: index,
                                            element: jqLite(anchor)
                                        };
                                    });
                                } else {
                                    preparedAnimations.push(animation);
                                }
                            });
                            var usedIndicesLookup = {};
                            var anchorGroups = {};
                            forEach(refLookup, function(operations, key) {
                                var from = operations.from;
                                var to = operations.to;
                                if (!from || !to) {
                                    var index = from ? from.animationID : to.animationID;
                                    var indexKey = index.toString();
                                    if (!usedIndicesLookup[indexKey]) {
                                        usedIndicesLookup[indexKey] = true;
                                        preparedAnimations.push(animations[index]);
                                    }
                                    return;
                                }
                                var fromAnimation = animations[from.animationID];
                                var toAnimation = animations[to.animationID];
                                var lookupKey = from.animationID.toString();
                                if (!anchorGroups[lookupKey]) {
                                    var group = anchorGroups[lookupKey] = {
                                        structural: true,
                                        beforeStart: function() {
                                            fromAnimation.beforeStart();
                                            toAnimation.beforeStart();
                                        },
                                        close: function() {
                                            fromAnimation.close();
                                            toAnimation.close();
                                        },
                                        classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                        from: fromAnimation,
                                        to: toAnimation,
                                        anchors: []
                                    };
                                    if (group.classes.length) {
                                        preparedAnimations.push(group);
                                    } else {
                                        preparedAnimations.push(fromAnimation);
                                        preparedAnimations.push(toAnimation);
                                    }
                                }
                                anchorGroups[lookupKey].anchors.push({
                                    out: from.element,
                                    in: to.element
                                });
                            });
                            return preparedAnimations;
                        }
                        function cssClassesIntersection(a, b) {
                            a = a.split(" ");
                            b = b.split(" ");
                            var matches = [];
                            for (var i = 0; i < a.length; i++) {
                                var aa = a[i];
                                if (aa.substring(0, 3) === "ng-") continue;
                                for (var j = 0; j < b.length; j++) {
                                    if (aa === b[j]) {
                                        matches.push(aa);
                                        break;
                                    }
                                }
                            }
                            return matches.join(" ");
                        }
                        function invokeFirstDriver(animationDetails) {
                            for (var i = drivers.length - 1; i >= 0; i--) {
                                var driverName = drivers[i];
                                var factory = $injector.get(driverName);
                                var driver = factory(animationDetails);
                                if (driver) {
                                    return driver;
                                }
                            }
                        }
                        function beforeStart() {
                            element.addClass(NG_ANIMATE_CLASSNAME);
                            if (tempClasses) {
                                $$jqLite.addClass(element, tempClasses);
                            }
                            if (prepareClassName) {
                                $$jqLite.removeClass(element, prepareClassName);
                                prepareClassName = null;
                            }
                        }
                        function updateAnimationRunners(animation, newRunner) {
                            if (animation.from && animation.to) {
                                update(animation.from.element);
                                update(animation.to.element);
                            } else {
                                update(animation.element);
                            }
                            function update(element) {
                                var runner = getRunner(element);
                                if (runner) runner.setHost(newRunner);
                            }
                        }
                        function handleDestroyedElement() {
                            var runner = getRunner(element);
                            if (runner && (event !== "leave" || !options.$$domOperationFired)) {
                                runner.end();
                            }
                        }
                        function close(rejected) {
                            element.off("$destroy", handleDestroyedElement);
                            removeRunner(element);
                            applyAnimationClasses(element, options);
                            applyAnimationStyles(element, options);
                            options.domOperation();
                            if (tempClasses) {
                                $$jqLite.removeClass(element, tempClasses);
                            }
                            element.removeClass(NG_ANIMATE_CLASSNAME);
                            runner.complete(!rejected);
                        }
                    };
                } ];
            } ];
            var ngAnimateSwapDirective = [ "$animate", "$rootScope", function($animate, $rootScope) {
                return {
                    restrict: "A",
                    transclude: "element",
                    terminal: true,
                    priority: 600,
                    link: function(scope, $element, attrs, ctrl, $transclude) {
                        var previousElement, previousScope;
                        scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function(value) {
                            if (previousElement) {
                                $animate.leave(previousElement);
                            }
                            if (previousScope) {
                                previousScope.$destroy();
                                previousScope = null;
                            }
                            if (value || value === 0) {
                                previousScope = scope.$new();
                                $transclude(previousScope, function(element) {
                                    previousElement = element;
                                    $animate.enter(element, null, $element);
                                });
                            }
                        });
                    }
                };
            } ];
            var copy;
            var extend;
            var forEach;
            var isArray;
            var isDefined;
            var isElement;
            var isFunction;
            var isObject;
            var isString;
            var isUndefined;
            var jqLite;
            var noop;
            angular.module("ngAnimate", [], function initAngularHelpers() {
                noop = angular.noop;
                copy = angular.copy;
                extend = angular.extend;
                jqLite = angular.element;
                forEach = angular.forEach;
                isArray = angular.isArray;
                isString = angular.isString;
                isObject = angular.isObject;
                isUndefined = angular.isUndefined;
                isDefined = angular.isDefined;
                isFunction = angular.isFunction;
                isElement = angular.isElement;
            }).info({
                angularVersion: "1.6.8"
            }).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
        })(window, window.angular);
    }, {} ],
    88: [ function(require, module, exports) {
        require("./angular-animate");
        module.exports = "ngAnimate";
    }, {
        "./angular-animate": 87
    } ],
    89: [ function(require, module, exports) {
        (function(window, angular) {
            "use strict";
            var $resourceMinErr = angular.$$minErr("$resource");
            var MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
            function isValidDottedPath(path) {
                return path != null && path !== "" && path !== "hasOwnProperty" && MEMBER_NAME_REGEX.test("." + path);
            }
            function lookupDottedPath(obj, path) {
                if (!isValidDottedPath(path)) {
                    throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
                }
                var keys = path.split(".");
                for (var i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {
                    var key = keys[i];
                    obj = obj !== null ? obj[key] : undefined;
                }
                return obj;
            }
            function shallowClearAndCopy(src, dst) {
                dst = dst || {};
                angular.forEach(dst, function(value, key) {
                    delete dst[key];
                });
                for (var key in src) {
                    if (src.hasOwnProperty(key) && !(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                        dst[key] = src[key];
                    }
                }
                return dst;
            }
            angular.module("ngResource", [ "ng" ]).info({
                angularVersion: "1.6.8"
            }).provider("$resource", function ResourceProvider() {
                var PROTOCOL_AND_IPV6_REGEX = /^https?:\/\/\[[^\]]*][^\/]*/;
                var provider = this;
                this.defaults = {
                    stripTrailingSlashes: true,
                    cancellable: false,
                    actions: {
                        get: {
                            method: "GET"
                        },
                        save: {
                            method: "POST"
                        },
                        query: {
                            method: "GET",
                            isArray: true
                        },
                        remove: {
                            method: "DELETE"
                        },
                        delete: {
                            method: "DELETE"
                        }
                    }
                };
                this.$get = [ "$http", "$log", "$q", "$timeout", function($http, $log, $q, $timeout) {
                    var noop = angular.noop, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, isArray = angular.isArray, isDefined = angular.isDefined, isFunction = angular.isFunction, isNumber = angular.isNumber, encodeUriQuery = angular.$$encodeUriQuery, encodeUriSegment = angular.$$encodeUriSegment;
                    function Route(template, defaults) {
                        this.template = template;
                        this.defaults = extend({}, provider.defaults, defaults);
                        this.urlParams = {};
                    }
                    Route.prototype = {
                        setUrlParams: function(config, params, actionUrl) {
                            var self = this, url = actionUrl || self.template, val, encodedVal, protocolAndIpv6 = "";
                            var urlParams = self.urlParams = Object.create(null);
                            forEach(url.split(/\W/), function(param) {
                                if (param === "hasOwnProperty") {
                                    throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                                }
                                if (!new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url)) {
                                    urlParams[param] = {
                                        isQueryParamValue: new RegExp("\\?.*=:" + param + "(?:\\W|$)").test(url)
                                    };
                                }
                            });
                            url = url.replace(/\\:/g, ":");
                            url = url.replace(PROTOCOL_AND_IPV6_REGEX, function(match) {
                                protocolAndIpv6 = match;
                                return "";
                            });
                            params = params || {};
                            forEach(self.urlParams, function(paramInfo, urlParam) {
                                val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];
                                if (isDefined(val) && val !== null) {
                                    if (paramInfo.isQueryParamValue) {
                                        encodedVal = encodeUriQuery(val, true);
                                    } else {
                                        encodedVal = encodeUriSegment(val);
                                    }
                                    url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                                        return encodedVal + p1;
                                    });
                                } else {
                                    url = url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                                        if (tail.charAt(0) === "/") {
                                            return tail;
                                        } else {
                                            return leadingSlashes + tail;
                                        }
                                    });
                                }
                            });
                            if (self.defaults.stripTrailingSlashes) {
                                url = url.replace(/\/+$/, "") || "/";
                            }
                            url = url.replace(/\/\.(?=\w+($|\?))/, ".");
                            config.url = protocolAndIpv6 + url.replace(/\/(\\|%5C)\./, "/.");
                            forEach(params, function(value, key) {
                                if (!self.urlParams[key]) {
                                    config.params = config.params || {};
                                    config.params[key] = value;
                                }
                            });
                        }
                    };
                    function resourceFactory(url, paramDefaults, actions, options) {
                        var route = new Route(url, options);
                        actions = extend({}, provider.defaults.actions, actions);
                        function extractParams(data, actionParams) {
                            var ids = {};
                            actionParams = extend({}, paramDefaults, actionParams);
                            forEach(actionParams, function(value, key) {
                                if (isFunction(value)) {
                                    value = value(data);
                                }
                                ids[key] = value && value.charAt && value.charAt(0) === "@" ? lookupDottedPath(data, value.substr(1)) : value;
                            });
                            return ids;
                        }
                        function defaultResponseInterceptor(response) {
                            return response.resource;
                        }
                        function Resource(value) {
                            shallowClearAndCopy(value || {}, this);
                        }
                        Resource.prototype.toJSON = function() {
                            var data = extend({}, this);
                            delete data.$promise;
                            delete data.$resolved;
                            delete data.$cancelRequest;
                            return data;
                        };
                        forEach(actions, function(action, name) {
                            var hasBody = action.hasBody === true || action.hasBody !== false && /^(POST|PUT|PATCH)$/i.test(action.method);
                            var numericTimeout = action.timeout;
                            var cancellable = isDefined(action.cancellable) ? action.cancellable : route.defaults.cancellable;
                            if (numericTimeout && !isNumber(numericTimeout)) {
                                $log.debug("ngResource:\n" + "  Only numeric values are allowed as `timeout`.\n" + "  Promises are not supported in $resource, because the same value would " + "be used for multiple requests. If you are looking for a way to cancel " + "requests, you should use the `cancellable` option.");
                                delete action.timeout;
                                numericTimeout = null;
                            }
                            Resource[name] = function(a1, a2, a3, a4) {
                                var params = {}, data, success, error;
                                switch (arguments.length) {
                                  case 4:
                                    error = a4;
                                    success = a3;

                                  case 3:
                                  case 2:
                                    if (isFunction(a2)) {
                                        if (isFunction(a1)) {
                                            success = a1;
                                            error = a2;
                                            break;
                                        }
                                        success = a2;
                                        error = a3;
                                    } else {
                                        params = a1;
                                        data = a2;
                                        success = a3;
                                        break;
                                    }

                                  case 1:
                                    if (isFunction(a1)) success = a1; else if (hasBody) data = a1; else params = a1;
                                    break;

                                  case 0:
                                    break;

                                  default:
                                    throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length);
                                }
                                var isInstanceCall = this instanceof Resource;
                                var value = isInstanceCall ? data : action.isArray ? [] : new Resource(data);
                                var httpConfig = {};
                                var responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor;
                                var responseErrorInterceptor = action.interceptor && action.interceptor.responseError || undefined;
                                var hasError = !!error;
                                var hasResponseErrorInterceptor = !!responseErrorInterceptor;
                                var timeoutDeferred;
                                var numericTimeoutPromise;
                                forEach(action, function(value, key) {
                                    switch (key) {
                                      default:
                                        httpConfig[key] = copy(value);
                                        break;

                                      case "params":
                                      case "isArray":
                                      case "interceptor":
                                      case "cancellable":
                                        break;
                                    }
                                });
                                if (!isInstanceCall && cancellable) {
                                    timeoutDeferred = $q.defer();
                                    httpConfig.timeout = timeoutDeferred.promise;
                                    if (numericTimeout) {
                                        numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout);
                                    }
                                }
                                if (hasBody) httpConfig.data = data;
                                route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                                var promise = $http(httpConfig).then(function(response) {
                                    var data = response.data;
                                    if (data) {
                                        if (isArray(data) !== !!action.isArray) {
                                            throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to " + "contain an {1} but got an {2} (Request: {3} {4})", name, action.isArray ? "array" : "object", isArray(data) ? "array" : "object", httpConfig.method, httpConfig.url);
                                        }
                                        if (action.isArray) {
                                            value.length = 0;
                                            forEach(data, function(item) {
                                                if (typeof item === "object") {
                                                    value.push(new Resource(item));
                                                } else {
                                                    value.push(item);
                                                }
                                            });
                                        } else {
                                            var promise = value.$promise;
                                            shallowClearAndCopy(data, value);
                                            value.$promise = promise;
                                        }
                                    }
                                    response.resource = value;
                                    return response;
                                }, function(response) {
                                    response.resource = value;
                                    return $q.reject(response);
                                });
                                promise = promise["finally"](function() {
                                    value.$resolved = true;
                                    if (!isInstanceCall && cancellable) {
                                        value.$cancelRequest = noop;
                                        $timeout.cancel(numericTimeoutPromise);
                                        timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null;
                                    }
                                });
                                promise = promise.then(function(response) {
                                    var value = responseInterceptor(response);
                                    (success || noop)(value, response.headers, response.status, response.statusText);
                                    return value;
                                }, hasError || hasResponseErrorInterceptor ? function(response) {
                                    if (hasError && !hasResponseErrorInterceptor) {
                                        promise.catch(noop);
                                    }
                                    if (hasError) error(response);
                                    return hasResponseErrorInterceptor ? responseErrorInterceptor(response) : $q.reject(response);
                                } : undefined);
                                if (!isInstanceCall) {
                                    value.$promise = promise;
                                    value.$resolved = false;
                                    if (cancellable) value.$cancelRequest = cancelRequest;
                                    return value;
                                }
                                return promise;
                                function cancelRequest(value) {
                                    promise.catch(noop);
                                    if (timeoutDeferred !== null) {
                                        timeoutDeferred.resolve(value);
                                    }
                                }
                            };
                            Resource.prototype["$" + name] = function(params, success, error) {
                                if (isFunction(params)) {
                                    error = success;
                                    success = params;
                                    params = {};
                                }
                                var result = Resource[name].call(this, params, this, success, error);
                                return result.$promise || result;
                            };
                        });
                        return Resource;
                    }
                    return resourceFactory;
                } ];
            });
        })(window, window.angular);
    }, {} ],
    90: [ function(require, module, exports) {
        require("./angular-resource");
        module.exports = "ngResource";
    }, {
        "./angular-resource": 89
    } ],
    91: [ function(require, module, exports) {
        (function(root, factory) {
            if (typeof define === "function" && define.amd) {
                define([], function() {
                    return factory();
                });
            } else if (typeof module === "object" && module.exports) {
                module.exports = factory();
            } else {
                factory();
            }
        })(this, function() {
            $translateStaticFilesLoader.$inject = [ "$q", "$http" ];
            angular.module("pascalprecht.translate").factory("$translateStaticFilesLoader", $translateStaticFilesLoader);
            function $translateStaticFilesLoader($q, $http) {
                "use strict";
                return function(options) {
                    if (!options || !angular.isArray(options.files) && (!angular.isString(options.prefix) || !angular.isString(options.suffix))) {
                        throw new Error("Couldn't load static files, no files and prefix or suffix specified!");
                    }
                    if (!options.files) {
                        options.files = [ {
                            prefix: options.prefix,
                            suffix: options.suffix
                        } ];
                    }
                    var load = function(file) {
                        if (!file || (!angular.isString(file.prefix) || !angular.isString(file.suffix))) {
                            throw new Error("Couldn't load static file, no prefix or suffix specified!");
                        }
                        var fileUrl = [ file.prefix, options.key, file.suffix ].join("");
                        if (angular.isObject(options.fileMap) && options.fileMap[fileUrl]) {
                            fileUrl = options.fileMap[fileUrl];
                        }
                        return $http(angular.extend({
                            url: fileUrl,
                            method: "GET"
                        }, options.$http)).then(function(result) {
                            return result.data;
                        }, function() {
                            return $q.reject(options.key);
                        });
                    };
                    var promises = [], length = options.files.length;
                    for (var i = 0; i < length; i++) {
                        promises.push(load({
                            prefix: options.files[i].prefix,
                            key: options.key,
                            suffix: options.files[i].suffix
                        }));
                    }
                    return $q.all(promises).then(function(data) {
                        var length = data.length, mergedData = {};
                        for (var i = 0; i < length; i++) {
                            for (var key in data[i]) {
                                mergedData[key] = data[i][key];
                            }
                        }
                        return mergedData;
                    });
                };
            }
            $translateStaticFilesLoader.displayName = "$translateStaticFilesLoader";
            return "pascalprecht.translate";
        });
    }, {} ],
    92: [ function(require, module, exports) {
        (function(root, factory) {
            if (typeof define === "function" && define.amd) {
                define([], function() {
                    return factory();
                });
            } else if (typeof module === "object" && module.exports) {
                module.exports = factory();
            } else {
                factory();
            }
        })(this, function() {
            runTranslate.$inject = [ "$translate" ];
            $translate.$inject = [ "$STORAGE_KEY", "$windowProvider", "$translateSanitizationProvider", "pascalprechtTranslateOverrider" ];
            $translateDefaultInterpolation.$inject = [ "$interpolate", "$translateSanitization" ];
            translateDirective.$inject = [ "$translate", "$interpolate", "$compile", "$parse", "$rootScope" ];
            translateAttrDirective.$inject = [ "$translate", "$rootScope" ];
            translateCloakDirective.$inject = [ "$translate", "$rootScope" ];
            translateFilterFactory.$inject = [ "$parse", "$translate" ];
            $translationCache.$inject = [ "$cacheFactory" ];
            angular.module("pascalprecht.translate", [ "ng" ]).run(runTranslate);
            function runTranslate($translate) {
                "use strict";
                var key = $translate.storageKey(), storage = $translate.storage();
                var fallbackFromIncorrectStorageValue = function() {
                    var preferred = $translate.preferredLanguage();
                    if (angular.isString(preferred)) {
                        $translate.use(preferred);
                    } else {
                        storage.put(key, $translate.use());
                    }
                };
                fallbackFromIncorrectStorageValue.displayName = "fallbackFromIncorrectStorageValue";
                if (storage) {
                    if (!storage.get(key)) {
                        fallbackFromIncorrectStorageValue();
                    } else {
                        $translate.use(storage.get(key))["catch"](fallbackFromIncorrectStorageValue);
                    }
                } else if (angular.isString($translate.preferredLanguage())) {
                    $translate.use($translate.preferredLanguage());
                }
            }
            runTranslate.displayName = "runTranslate";
            angular.module("pascalprecht.translate").provider("$translateSanitization", $translateSanitizationProvider);
            function $translateSanitizationProvider() {
                "use strict";
                var $sanitize, $sce, currentStrategy = null, hasConfiguredStrategy = false, hasShownNoStrategyConfiguredWarning = false, strategies;
                strategies = {
                    sanitize: function(value, mode) {
                        if (mode === "text") {
                            value = htmlSanitizeValue(value);
                        }
                        return value;
                    },
                    escape: function(value, mode) {
                        if (mode === "text") {
                            value = htmlEscapeValue(value);
                        }
                        return value;
                    },
                    sanitizeParameters: function(value, mode) {
                        if (mode === "params") {
                            value = mapInterpolationParameters(value, htmlSanitizeValue);
                        }
                        return value;
                    },
                    escapeParameters: function(value, mode) {
                        if (mode === "params") {
                            value = mapInterpolationParameters(value, htmlEscapeValue);
                        }
                        return value;
                    },
                    sce: function(value, mode, context) {
                        if (mode === "text") {
                            value = htmlTrustValue(value);
                        } else if (mode === "params") {
                            if (context !== "filter") {
                                value = mapInterpolationParameters(value, htmlEscapeValue);
                            }
                        }
                        return value;
                    },
                    sceParameters: function(value, mode) {
                        if (mode === "params") {
                            value = mapInterpolationParameters(value, htmlTrustValue);
                        }
                        return value;
                    }
                };
                strategies.escaped = strategies.escapeParameters;
                this.addStrategy = function(strategyName, strategyFunction) {
                    strategies[strategyName] = strategyFunction;
                    return this;
                };
                this.removeStrategy = function(strategyName) {
                    delete strategies[strategyName];
                    return this;
                };
                this.useStrategy = function(strategy) {
                    hasConfiguredStrategy = true;
                    currentStrategy = strategy;
                    return this;
                };
                this.$get = [ "$injector", "$log", function($injector, $log) {
                    var cachedStrategyMap = {};
                    var applyStrategies = function(value, mode, context, selectedStrategies) {
                        angular.forEach(selectedStrategies, function(selectedStrategy) {
                            if (angular.isFunction(selectedStrategy)) {
                                value = selectedStrategy(value, mode, context);
                            } else if (angular.isFunction(strategies[selectedStrategy])) {
                                value = strategies[selectedStrategy](value, mode, context);
                            } else if (angular.isString(strategies[selectedStrategy])) {
                                if (!cachedStrategyMap[strategies[selectedStrategy]]) {
                                    try {
                                        cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy]);
                                    } catch (e) {
                                        cachedStrategyMap[strategies[selectedStrategy]] = function() {};
                                        throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                                    }
                                }
                                value = cachedStrategyMap[strategies[selectedStrategy]](value, mode, context);
                            } else {
                                throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                            }
                        });
                        return value;
                    };
                    var showNoStrategyConfiguredWarning = function() {
                        if (!hasConfiguredStrategy && !hasShownNoStrategyConfiguredWarning) {
                            $log.warn("pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details.");
                            hasShownNoStrategyConfiguredWarning = true;
                        }
                    };
                    if ($injector.has("$sanitize")) {
                        $sanitize = $injector.get("$sanitize");
                    }
                    if ($injector.has("$sce")) {
                        $sce = $injector.get("$sce");
                    }
                    return {
                        useStrategy: function(self) {
                            return function(strategy) {
                                self.useStrategy(strategy);
                            };
                        }(this),
                        sanitize: function(value, mode, strategy, context) {
                            if (!currentStrategy) {
                                showNoStrategyConfiguredWarning();
                            }
                            if (!strategy && strategy !== null) {
                                strategy = currentStrategy;
                            }
                            if (!strategy) {
                                return value;
                            }
                            if (!context) {
                                context = "service";
                            }
                            var selectedStrategies = angular.isArray(strategy) ? strategy : [ strategy ];
                            return applyStrategies(value, mode, context, selectedStrategies);
                        }
                    };
                } ];
                var htmlEscapeValue = function(value) {
                    var element = angular.element("<div></div>");
                    element.text(value);
                    return element.html();
                };
                var htmlSanitizeValue = function(value) {
                    if (!$sanitize) {
                        throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'.");
                    }
                    return $sanitize(value);
                };
                var htmlTrustValue = function(value) {
                    if (!$sce) {
                        throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sce service.");
                    }
                    return $sce.trustAsHtml(value);
                };
                var mapInterpolationParameters = function(value, iteratee, stack) {
                    if (angular.isDate(value)) {
                        return value;
                    } else if (angular.isObject(value)) {
                        var result = angular.isArray(value) ? [] : {};
                        if (!stack) {
                            stack = [];
                        } else {
                            if (stack.indexOf(value) > -1) {
                                throw new Error("pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object");
                            }
                        }
                        stack.push(value);
                        angular.forEach(value, function(propertyValue, propertyKey) {
                            if (angular.isFunction(propertyValue)) {
                                return;
                            }
                            result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack);
                        });
                        stack.splice(-1, 1);
                        return result;
                    } else if (angular.isNumber(value)) {
                        return value;
                    } else if (value === true || value === false) {
                        return value;
                    } else if (!angular.isUndefined(value) && value !== null) {
                        return iteratee(value);
                    } else {
                        return value;
                    }
                };
            }
            angular.module("pascalprecht.translate").constant("pascalprechtTranslateOverrider", {}).provider("$translate", $translate);
            function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {
                "use strict";
                var $translationTable = {}, $preferredLanguage, $availableLanguageKeys = [], $languageKeyAliases, $fallbackLanguage, $fallbackWasString, $uses, $nextLang, $storageFactory, $storageKey = $STORAGE_KEY, $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $interpolatorFactories = [], $loaderFactory, $cloakClassName = "translate-cloak", $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, $postCompilingEnabled = false, $forceAsyncReloadEnabled = false, $nestedObjectDelimeter = ".", $isReady = false, $keepContent = false, loaderCache, directivePriority = 0, statefulFilter = true, postProcessFn, uniformLanguageTagResolver = "default", languageTagResolver = {
                    default: function(tag) {
                        return (tag || "").split("-").join("_");
                    },
                    java: function(tag) {
                        var temp = (tag || "").split("-").join("_");
                        var parts = temp.split("_");
                        return parts.length > 1 ? parts[0].toLowerCase() + "_" + parts[1].toUpperCase() : temp;
                    },
                    bcp47: function(tag) {
                        var temp = (tag || "").split("_").join("-");
                        var parts = temp.split("-");
                        switch (parts.length) {
                          case 1:
                            parts[0] = parts[0].toLowerCase();
                            break;

                          case 2:
                            parts[0] = parts[0].toLowerCase();
                            if (parts[1].length === 4) {
                                parts[1] = parts[1].charAt(0).toUpperCase() + parts[1].slice(1).toLowerCase();
                            } else {
                                parts[1] = parts[1].toUpperCase();
                            }
                            break;

                          case 3:
                            parts[0] = parts[0].toLowerCase();
                            parts[1] = parts[1].charAt(0).toUpperCase() + parts[1].slice(1).toLowerCase();
                            parts[2] = parts[2].toUpperCase();
                            break;

                          default:
                            return temp;
                        }
                        return parts.join("-");
                    },
                    "iso639-1": function(tag) {
                        var temp = (tag || "").split("_").join("-");
                        var parts = temp.split("-");
                        return parts[0].toLowerCase();
                    }
                };
                var version = "2.17.0";
                var getFirstBrowserLanguage = function() {
                    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) {
                        return pascalprechtTranslateOverrider.getLocale();
                    }
                    var nav = $windowProvider.$get().navigator, browserLanguagePropertyKeys = [ "language", "browserLanguage", "systemLanguage", "userLanguage" ], i, language;
                    if (angular.isArray(nav.languages)) {
                        for (i = 0; i < nav.languages.length; i++) {
                            language = nav.languages[i];
                            if (language && language.length) {
                                return language;
                            }
                        }
                    }
                    for (i = 0; i < browserLanguagePropertyKeys.length; i++) {
                        language = nav[browserLanguagePropertyKeys[i]];
                        if (language && language.length) {
                            return language;
                        }
                    }
                    return null;
                };
                getFirstBrowserLanguage.displayName = "angular-translate/service: getFirstBrowserLanguage";
                var getLocale = function() {
                    var locale = getFirstBrowserLanguage() || "";
                    if (languageTagResolver[uniformLanguageTagResolver]) {
                        locale = languageTagResolver[uniformLanguageTagResolver](locale);
                    }
                    return locale;
                };
                getLocale.displayName = "angular-translate/service: getLocale";
                var indexOf = function(array, searchElement) {
                    for (var i = 0, len = array.length; i < len; i++) {
                        if (array[i] === searchElement) {
                            return i;
                        }
                    }
                    return -1;
                };
                var trim = function() {
                    return this.toString().replace(/^\s+|\s+$/g, "");
                };
                var lowercase = function(string) {
                    return angular.isString(string) ? string.toLowerCase() : string;
                };
                var negotiateLocale = function(preferred) {
                    if (!preferred) {
                        return;
                    }
                    var avail = [], locale = lowercase(preferred), i = 0, n = $availableLanguageKeys.length;
                    for (;i < n; i++) {
                        avail.push(lowercase($availableLanguageKeys[i]));
                    }
                    i = indexOf(avail, locale);
                    if (i > -1) {
                        return $availableLanguageKeys[i];
                    }
                    if ($languageKeyAliases) {
                        var alias;
                        for (var langKeyAlias in $languageKeyAliases) {
                            if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {
                                var hasWildcardKey = false;
                                var hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && lowercase(langKeyAlias) === lowercase(preferred);
                                if (langKeyAlias.slice(-1) === "*") {
                                    hasWildcardKey = lowercase(langKeyAlias.slice(0, -1)) === lowercase(preferred.slice(0, langKeyAlias.length - 1));
                                }
                                if (hasExactKey || hasWildcardKey) {
                                    alias = $languageKeyAliases[langKeyAlias];
                                    if (indexOf(avail, lowercase(alias)) > -1) {
                                        return alias;
                                    }
                                }
                            }
                        }
                    }
                    var parts = preferred.split("_");
                    if (parts.length > 1 && indexOf(avail, lowercase(parts[0])) > -1) {
                        return parts[0];
                    }
                    return;
                };
                var translations = function(langKey, translationTable) {
                    if (!langKey && !translationTable) {
                        return $translationTable;
                    }
                    if (langKey && !translationTable) {
                        if (angular.isString(langKey)) {
                            return $translationTable[langKey];
                        }
                    } else {
                        if (!angular.isObject($translationTable[langKey])) {
                            $translationTable[langKey] = {};
                        }
                        angular.extend($translationTable[langKey], flatObject(translationTable));
                    }
                    return this;
                };
                this.translations = translations;
                this.cloakClassName = function(name) {
                    if (!name) {
                        return $cloakClassName;
                    }
                    $cloakClassName = name;
                    return this;
                };
                this.nestedObjectDelimeter = function(delimiter) {
                    if (!delimiter) {
                        return $nestedObjectDelimeter;
                    }
                    $nestedObjectDelimeter = delimiter;
                    return this;
                };
                var flatObject = function(data, path, result, prevKey) {
                    var key, keyWithPath, keyWithShortPath, val;
                    if (!path) {
                        path = [];
                    }
                    if (!result) {
                        result = {};
                    }
                    for (key in data) {
                        if (!Object.prototype.hasOwnProperty.call(data, key)) {
                            continue;
                        }
                        val = data[key];
                        if (angular.isObject(val)) {
                            flatObject(val, path.concat(key), result, key);
                        } else {
                            keyWithPath = path.length ? "" + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key : key;
                            if (path.length && key === prevKey) {
                                keyWithShortPath = "" + path.join($nestedObjectDelimeter);
                                result[keyWithShortPath] = "@:" + keyWithPath;
                            }
                            result[keyWithPath] = val;
                        }
                    }
                    return result;
                };
                flatObject.displayName = "flatObject";
                this.addInterpolation = function(factory) {
                    $interpolatorFactories.push(factory);
                    return this;
                };
                this.useMessageFormatInterpolation = function() {
                    return this.useInterpolation("$translateMessageFormatInterpolation");
                };
                this.useInterpolation = function(factory) {
                    $interpolationFactory = factory;
                    return this;
                };
                this.useSanitizeValueStrategy = function(value) {
                    $translateSanitizationProvider.useStrategy(value);
                    return this;
                };
                this.preferredLanguage = function(langKey) {
                    if (langKey) {
                        setupPreferredLanguage(langKey);
                        return this;
                    }
                    return $preferredLanguage;
                };
                var setupPreferredLanguage = function(langKey) {
                    if (langKey) {
                        $preferredLanguage = langKey;
                    }
                    return $preferredLanguage;
                };
                this.translationNotFoundIndicator = function(indicator) {
                    this.translationNotFoundIndicatorLeft(indicator);
                    this.translationNotFoundIndicatorRight(indicator);
                    return this;
                };
                this.translationNotFoundIndicatorLeft = function(indicator) {
                    if (!indicator) {
                        return $notFoundIndicatorLeft;
                    }
                    $notFoundIndicatorLeft = indicator;
                    return this;
                };
                this.translationNotFoundIndicatorRight = function(indicator) {
                    if (!indicator) {
                        return $notFoundIndicatorRight;
                    }
                    $notFoundIndicatorRight = indicator;
                    return this;
                };
                this.fallbackLanguage = function(langKey) {
                    fallbackStack(langKey);
                    return this;
                };
                var fallbackStack = function(langKey) {
                    if (langKey) {
                        if (angular.isString(langKey)) {
                            $fallbackWasString = true;
                            $fallbackLanguage = [ langKey ];
                        } else if (angular.isArray(langKey)) {
                            $fallbackWasString = false;
                            $fallbackLanguage = langKey;
                        }
                        if (angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                            $fallbackLanguage.push($preferredLanguage);
                        }
                        return this;
                    } else {
                        if ($fallbackWasString) {
                            return $fallbackLanguage[0];
                        } else {
                            return $fallbackLanguage;
                        }
                    }
                };
                this.use = function(langKey) {
                    if (langKey) {
                        if (!$translationTable[langKey] && !$loaderFactory) {
                            throw new Error("$translateProvider couldn't find translationTable for langKey: '" + langKey + "'");
                        }
                        $uses = langKey;
                        return this;
                    }
                    return $uses;
                };
                this.resolveClientLocale = function() {
                    return getLocale();
                };
                var storageKey = function(key) {
                    if (!key) {
                        if ($storagePrefix) {
                            return $storagePrefix + $storageKey;
                        }
                        return $storageKey;
                    }
                    $storageKey = key;
                    return this;
                };
                this.storageKey = storageKey;
                this.useUrlLoader = function(url, options) {
                    return this.useLoader("$translateUrlLoader", angular.extend({
                        url: url
                    }, options));
                };
                this.useStaticFilesLoader = function(options) {
                    return this.useLoader("$translateStaticFilesLoader", options);
                };
                this.useLoader = function(loaderFactory, options) {
                    $loaderFactory = loaderFactory;
                    $loaderOptions = options || {};
                    return this;
                };
                this.useLocalStorage = function() {
                    return this.useStorage("$translateLocalStorage");
                };
                this.useCookieStorage = function() {
                    return this.useStorage("$translateCookieStorage");
                };
                this.useStorage = function(storageFactory) {
                    $storageFactory = storageFactory;
                    return this;
                };
                this.storagePrefix = function(prefix) {
                    if (!prefix) {
                        return prefix;
                    }
                    $storagePrefix = prefix;
                    return this;
                };
                this.useMissingTranslationHandlerLog = function() {
                    return this.useMissingTranslationHandler("$translateMissingTranslationHandlerLog");
                };
                this.useMissingTranslationHandler = function(factory) {
                    $missingTranslationHandlerFactory = factory;
                    return this;
                };
                this.usePostCompiling = function(value) {
                    $postCompilingEnabled = !!value;
                    return this;
                };
                this.forceAsyncReload = function(value) {
                    $forceAsyncReloadEnabled = !!value;
                    return this;
                };
                this.uniformLanguageTag = function(options) {
                    if (!options) {
                        options = {};
                    } else if (angular.isString(options)) {
                        options = {
                            standard: options
                        };
                    }
                    uniformLanguageTagResolver = options.standard;
                    return this;
                };
                this.determinePreferredLanguage = function(fn) {
                    var locale = fn && angular.isFunction(fn) ? fn() : getLocale();
                    if (!$availableLanguageKeys.length) {
                        $preferredLanguage = locale;
                    } else {
                        $preferredLanguage = negotiateLocale(locale) || locale;
                    }
                    return this;
                };
                this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
                    if (languageKeys) {
                        $availableLanguageKeys = languageKeys;
                        if (aliases) {
                            $languageKeyAliases = aliases;
                        }
                        return this;
                    }
                    return $availableLanguageKeys;
                };
                this.useLoaderCache = function(cache) {
                    if (cache === false) {
                        loaderCache = undefined;
                    } else if (cache === true) {
                        loaderCache = true;
                    } else if (typeof cache === "undefined") {
                        loaderCache = "$translationCache";
                    } else if (cache) {
                        loaderCache = cache;
                    }
                    return this;
                };
                this.directivePriority = function(priority) {
                    if (priority === undefined) {
                        return directivePriority;
                    } else {
                        directivePriority = priority;
                        return this;
                    }
                };
                this.statefulFilter = function(state) {
                    if (state === undefined) {
                        return statefulFilter;
                    } else {
                        statefulFilter = state;
                        return this;
                    }
                };
                this.postProcess = function(fn) {
                    if (fn) {
                        postProcessFn = fn;
                    } else {
                        postProcessFn = undefined;
                    }
                    return this;
                };
                this.keepContent = function(value) {
                    $keepContent = !!value;
                    return this;
                };
                this.$get = [ "$log", "$injector", "$rootScope", "$q", function($log, $injector, $rootScope, $q) {
                    var Storage, defaultInterpolator = $injector.get($interpolationFactory || "$translateDefaultInterpolation"), pendingLoader = false, interpolatorHashMap = {}, langPromises = {}, fallbackIndex, startFallbackIteration;
                    var $translate = function(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy) {
                        if (!$uses && $preferredLanguage) {
                            $uses = $preferredLanguage;
                        }
                        var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                        if (forceLanguage) {
                            loadTranslationsIfMissing(forceLanguage);
                        }
                        if (angular.isArray(translationId)) {
                            var translateAll = function(translationIds) {
                                var results = {};
                                var promises = [];
                                var translate = function(translationId) {
                                    var deferred = $q.defer();
                                    var regardless = function(value) {
                                        results[translationId] = value;
                                        deferred.resolve([ translationId, value ]);
                                    };
                                    $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy).then(regardless, regardless);
                                    return deferred.promise;
                                };
                                for (var i = 0, c = translationIds.length; i < c; i++) {
                                    promises.push(translate(translationIds[i]));
                                }
                                return $q.all(promises).then(function() {
                                    return results;
                                });
                            };
                            return translateAll(translationId);
                        }
                        var deferred = $q.defer();
                        if (translationId) {
                            translationId = trim.apply(translationId);
                        }
                        var promiseToWaitFor = function() {
                            var promise = langPromises[uses] || langPromises[$preferredLanguage];
                            fallbackIndex = 0;
                            if ($storageFactory && !promise) {
                                var langKey = Storage.get($storageKey);
                                promise = langPromises[langKey];
                                if ($fallbackLanguage && $fallbackLanguage.length) {
                                    var index = indexOf($fallbackLanguage, langKey);
                                    fallbackIndex = index === 0 ? 1 : 0;
                                    if (indexOf($fallbackLanguage, $preferredLanguage) < 0) {
                                        $fallbackLanguage.push($preferredLanguage);
                                    }
                                }
                            }
                            return promise;
                        }();
                        if (!promiseToWaitFor) {
                            determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                        } else {
                            var promiseResolved = function() {
                                if (!forceLanguage) {
                                    uses = $uses;
                                }
                                determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                            };
                            promiseResolved.displayName = "promiseResolved";
                            promiseToWaitFor["finally"](promiseResolved)["catch"](angular.noop);
                        }
                        return deferred.promise;
                    };
                    var applyNotFoundIndicators = function(translationId) {
                        if ($notFoundIndicatorLeft) {
                            translationId = [ $notFoundIndicatorLeft, translationId ].join(" ");
                        }
                        if ($notFoundIndicatorRight) {
                            translationId = [ translationId, $notFoundIndicatorRight ].join(" ");
                        }
                        return translationId;
                    };
                    var useLanguage = function(key) {
                        $uses = key;
                        if ($storageFactory) {
                            Storage.put($translate.storageKey(), $uses);
                        }
                        $rootScope.$emit("$translateChangeSuccess", {
                            language: key
                        });
                        defaultInterpolator.setLocale($uses);
                        var eachInterpolator = function(interpolator, id) {
                            interpolatorHashMap[id].setLocale($uses);
                        };
                        eachInterpolator.displayName = "eachInterpolatorLocaleSetter";
                        angular.forEach(interpolatorHashMap, eachInterpolator);
                        $rootScope.$emit("$translateChangeEnd", {
                            language: key
                        });
                    };
                    var loadAsync = function(key) {
                        if (!key) {
                            throw "No language key specified for loading.";
                        }
                        var deferred = $q.defer();
                        $rootScope.$emit("$translateLoadingStart", {
                            language: key
                        });
                        pendingLoader = true;
                        var cache = loaderCache;
                        if (typeof cache === "string") {
                            cache = $injector.get(cache);
                        }
                        var loaderOptions = angular.extend({}, $loaderOptions, {
                            key: key,
                            $http: angular.extend({}, {
                                cache: cache
                            }, $loaderOptions.$http)
                        });
                        var onLoaderSuccess = function(data) {
                            var translationTable = {};
                            $rootScope.$emit("$translateLoadingSuccess", {
                                language: key
                            });
                            if (angular.isArray(data)) {
                                angular.forEach(data, function(table) {
                                    angular.extend(translationTable, flatObject(table));
                                });
                            } else {
                                angular.extend(translationTable, flatObject(data));
                            }
                            pendingLoader = false;
                            deferred.resolve({
                                key: key,
                                table: translationTable
                            });
                            $rootScope.$emit("$translateLoadingEnd", {
                                language: key
                            });
                        };
                        onLoaderSuccess.displayName = "onLoaderSuccess";
                        var onLoaderError = function(key) {
                            $rootScope.$emit("$translateLoadingError", {
                                language: key
                            });
                            deferred.reject(key);
                            $rootScope.$emit("$translateLoadingEnd", {
                                language: key
                            });
                        };
                        onLoaderError.displayName = "onLoaderError";
                        $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError);
                        return deferred.promise;
                    };
                    if ($storageFactory) {
                        Storage = $injector.get($storageFactory);
                        if (!Storage.get || !Storage.put) {
                            throw new Error("Couldn't use storage '" + $storageFactory + "', missing get() or put() method!");
                        }
                    }
                    if ($interpolatorFactories.length) {
                        var eachInterpolationFactory = function(interpolatorFactory) {
                            var interpolator = $injector.get(interpolatorFactory);
                            interpolator.setLocale($preferredLanguage || $uses);
                            interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator;
                        };
                        eachInterpolationFactory.displayName = "interpolationFactoryAdder";
                        angular.forEach($interpolatorFactories, eachInterpolationFactory);
                    }
                    var getTranslationTable = function(langKey) {
                        var deferred = $q.defer();
                        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) {
                            deferred.resolve($translationTable[langKey]);
                        } else if (langPromises[langKey]) {
                            var onResolve = function(data) {
                                translations(data.key, data.table);
                                deferred.resolve(data.table);
                            };
                            onResolve.displayName = "translationTableResolver";
                            langPromises[langKey].then(onResolve, deferred.reject);
                        } else {
                            deferred.reject();
                        }
                        return deferred.promise;
                    };
                    var getFallbackTranslation = function(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        var deferred = $q.defer();
                        var onResolve = function(translationTable) {
                            if (Object.prototype.hasOwnProperty.call(translationTable, translationId) && translationTable[translationId] !== null) {
                                Interpolator.setLocale(langKey);
                                var translation = translationTable[translationId];
                                if (translation.substr(0, 2) === "@:") {
                                    getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                                } else {
                                    var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams, "service", sanitizeStrategy, translationId);
                                    interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey);
                                    deferred.resolve(interpolatedValue);
                                }
                                Interpolator.setLocale($uses);
                            } else {
                                deferred.reject();
                            }
                        };
                        onResolve.displayName = "fallbackTranslationResolver";
                        getTranslationTable(langKey).then(onResolve, deferred.reject);
                        return deferred.promise;
                    };
                    var getFallbackTranslationInstant = function(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        var result, translationTable = $translationTable[langKey];
                        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId) && translationTable[translationId] !== null) {
                            Interpolator.setLocale(langKey);
                            result = Interpolator.interpolate(translationTable[translationId], interpolateParams, "filter", sanitizeStrategy, translationId);
                            result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey, sanitizeStrategy);
                            if (!angular.isString(result) && angular.isFunction(result.$$unwrapTrustedValue)) {
                                var result2 = result.$$unwrapTrustedValue();
                                if (result2.substr(0, 2) === "@:") {
                                    return getFallbackTranslationInstant(langKey, result2.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                                }
                            } else if (result.substr(0, 2) === "@:") {
                                return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                            }
                            Interpolator.setLocale($uses);
                        }
                        return result;
                    };
                    var translateByHandler = function(translationId, interpolateParams, defaultTranslationText, sanitizeStrategy) {
                        if ($missingTranslationHandlerFactory) {
                            return $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText, sanitizeStrategy);
                        } else {
                            return translationId;
                        }
                    };
                    var resolveForFallbackLanguage = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                        var deferred = $q.defer();
                        if (fallbackLanguageIndex < $fallbackLanguage.length) {
                            var langKey = $fallbackLanguage[fallbackLanguageIndex];
                            getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy).then(function(data) {
                                deferred.resolve(data);
                            }, function() {
                                return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                            });
                        } else {
                            if (defaultTranslationText) {
                                deferred.resolve(defaultTranslationText);
                            } else {
                                var missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
                                if ($missingTranslationHandlerFactory && missingTranslationHandlerTranslation) {
                                    deferred.resolve(missingTranslationHandlerTranslation);
                                } else {
                                    deferred.reject(applyNotFoundIndicators(translationId));
                                }
                            }
                        }
                        return deferred.promise;
                    };
                    var resolveForFallbackLanguageInstant = function(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        var result;
                        if (fallbackLanguageIndex < $fallbackLanguage.length) {
                            var langKey = $fallbackLanguage[fallbackLanguageIndex];
                            result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy);
                            if (!result && result !== "") {
                                result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator);
                            }
                        }
                        return result;
                    };
                    var fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                        return resolveForFallbackLanguage(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy);
                    };
                    var fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        return resolveForFallbackLanguageInstant(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy);
                    };
                    var determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy) {
                        var deferred = $q.defer();
                        var table = uses ? $translationTable[uses] : $translationTable, Interpolator = interpolationId ? interpolatorHashMap[interpolationId] : defaultInterpolator;
                        if (table && Object.prototype.hasOwnProperty.call(table, translationId) && table[translationId] !== null) {
                            var translation = table[translationId];
                            if (translation.substr(0, 2) === "@:") {
                                $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                            } else {
                                var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams, "service", sanitizeStrategy, translationId);
                                resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses);
                                deferred.resolve(resolvedTranslation);
                            }
                        } else {
                            var missingTranslationHandlerTranslation;
                            if ($missingTranslationHandlerFactory && !pendingLoader) {
                                missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
                            }
                            if (uses && $fallbackLanguage && $fallbackLanguage.length) {
                                fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(function(translation) {
                                    deferred.resolve(translation);
                                }, function(_translationId) {
                                    deferred.reject(applyNotFoundIndicators(_translationId));
                                });
                            } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                                if (defaultTranslationText) {
                                    deferred.resolve(defaultTranslationText);
                                } else {
                                    deferred.resolve(missingTranslationHandlerTranslation);
                                }
                            } else {
                                if (defaultTranslationText) {
                                    deferred.resolve(defaultTranslationText);
                                } else {
                                    deferred.reject(applyNotFoundIndicators(translationId));
                                }
                            }
                        }
                        return deferred.promise;
                    };
                    var determineTranslationInstant = function(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy) {
                        var result, table = uses ? $translationTable[uses] : $translationTable, Interpolator = defaultInterpolator;
                        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId)) {
                            Interpolator = interpolatorHashMap[interpolationId];
                        }
                        if (table && Object.prototype.hasOwnProperty.call(table, translationId) && table[translationId] !== null) {
                            var translation = table[translationId];
                            if (translation.substr(0, 2) === "@:") {
                                result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses, sanitizeStrategy);
                            } else {
                                result = Interpolator.interpolate(translation, interpolateParams, "filter", sanitizeStrategy, translationId);
                                result = applyPostProcessing(translationId, translation, result, interpolateParams, uses, sanitizeStrategy);
                            }
                        } else {
                            var missingTranslationHandlerTranslation;
                            if ($missingTranslationHandlerFactory && !pendingLoader) {
                                missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy);
                            }
                            if (uses && $fallbackLanguage && $fallbackLanguage.length) {
                                fallbackIndex = 0;
                                result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator, sanitizeStrategy);
                            } else if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                                result = missingTranslationHandlerTranslation;
                            } else {
                                result = applyNotFoundIndicators(translationId);
                            }
                        }
                        return result;
                    };
                    var clearNextLangAndPromise = function(key) {
                        if ($nextLang === key) {
                            $nextLang = undefined;
                        }
                        langPromises[key] = undefined;
                    };
                    var applyPostProcessing = function(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) {
                        var fn = postProcessFn;
                        if (fn) {
                            if (typeof fn === "string") {
                                fn = $injector.get(fn);
                            }
                            if (fn) {
                                return fn(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy);
                            }
                        }
                        return resolvedTranslation;
                    };
                    var loadTranslationsIfMissing = function(key) {
                        if (!$translationTable[key] && $loaderFactory && !langPromises[key]) {
                            langPromises[key] = loadAsync(key).then(function(translation) {
                                translations(translation.key, translation.table);
                                return translation;
                            });
                        }
                    };
                    $translate.preferredLanguage = function(langKey) {
                        if (langKey) {
                            setupPreferredLanguage(langKey);
                        }
                        return $preferredLanguage;
                    };
                    $translate.cloakClassName = function() {
                        return $cloakClassName;
                    };
                    $translate.nestedObjectDelimeter = function() {
                        return $nestedObjectDelimeter;
                    };
                    $translate.fallbackLanguage = function(langKey) {
                        if (langKey !== undefined && langKey !== null) {
                            fallbackStack(langKey);
                            if ($loaderFactory) {
                                if ($fallbackLanguage && $fallbackLanguage.length) {
                                    for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                                        if (!langPromises[$fallbackLanguage[i]]) {
                                            langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]);
                                        }
                                    }
                                }
                            }
                            $translate.use($translate.use());
                        }
                        if ($fallbackWasString) {
                            return $fallbackLanguage[0];
                        } else {
                            return $fallbackLanguage;
                        }
                    };
                    $translate.useFallbackLanguage = function(langKey) {
                        if (langKey !== undefined && langKey !== null) {
                            if (!langKey) {
                                startFallbackIteration = 0;
                            } else {
                                var langKeyPosition = indexOf($fallbackLanguage, langKey);
                                if (langKeyPosition > -1) {
                                    startFallbackIteration = langKeyPosition;
                                }
                            }
                        }
                    };
                    $translate.proposedLanguage = function() {
                        return $nextLang;
                    };
                    $translate.storage = function() {
                        return Storage;
                    };
                    $translate.negotiateLocale = negotiateLocale;
                    $translate.use = function(key) {
                        if (!key) {
                            return $uses;
                        }
                        var deferred = $q.defer();
                        deferred.promise.then(null, angular.noop);
                        $rootScope.$emit("$translateChangeStart", {
                            language: key
                        });
                        var aliasedKey = negotiateLocale(key);
                        if ($availableLanguageKeys.length > 0 && !aliasedKey) {
                            return $q.reject(key);
                        }
                        if (aliasedKey) {
                            key = aliasedKey;
                        }
                        $nextLang = key;
                        if (($forceAsyncReloadEnabled || !$translationTable[key]) && $loaderFactory && !langPromises[key]) {
                            langPromises[key] = loadAsync(key).then(function(translation) {
                                translations(translation.key, translation.table);
                                deferred.resolve(translation.key);
                                if ($nextLang === key) {
                                    useLanguage(translation.key);
                                }
                                return translation;
                            }, function(key) {
                                $rootScope.$emit("$translateChangeError", {
                                    language: key
                                });
                                deferred.reject(key);
                                $rootScope.$emit("$translateChangeEnd", {
                                    language: key
                                });
                                return $q.reject(key);
                            });
                            langPromises[key]["finally"](function() {
                                clearNextLangAndPromise(key);
                            })["catch"](angular.noop);
                        } else if (langPromises[key]) {
                            langPromises[key].then(function(translation) {
                                if ($nextLang === translation.key) {
                                    useLanguage(translation.key);
                                }
                                deferred.resolve(translation.key);
                                return translation;
                            }, function(key) {
                                if (!$uses && $fallbackLanguage && $fallbackLanguage.length > 0 && $fallbackLanguage[0] !== key) {
                                    return $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject);
                                } else {
                                    return deferred.reject(key);
                                }
                            });
                        } else {
                            deferred.resolve(key);
                            useLanguage(key);
                        }
                        return deferred.promise;
                    };
                    $translate.resolveClientLocale = function() {
                        return getLocale();
                    };
                    $translate.storageKey = function() {
                        return storageKey();
                    };
                    $translate.isPostCompilingEnabled = function() {
                        return $postCompilingEnabled;
                    };
                    $translate.isForceAsyncReloadEnabled = function() {
                        return $forceAsyncReloadEnabled;
                    };
                    $translate.isKeepContent = function() {
                        return $keepContent;
                    };
                    $translate.refresh = function(langKey) {
                        if (!$loaderFactory) {
                            throw new Error("Couldn't refresh translation table, no loader registered!");
                        }
                        $rootScope.$emit("$translateRefreshStart", {
                            language: langKey
                        });
                        var deferred = $q.defer(), updatedLanguages = {};
                        function loadNewData(languageKey) {
                            var promise = loadAsync(languageKey);
                            langPromises[languageKey] = promise;
                            promise.then(function(data) {
                                $translationTable[languageKey] = {};
                                translations(languageKey, data.table);
                                updatedLanguages[languageKey] = true;
                            }, angular.noop);
                            return promise;
                        }
                        deferred.promise.then(function() {
                            for (var key in $translationTable) {
                                if ($translationTable.hasOwnProperty(key)) {
                                    if (!(key in updatedLanguages)) {
                                        delete $translationTable[key];
                                    }
                                }
                            }
                            if ($uses) {
                                useLanguage($uses);
                            }
                        }, angular.noop)["finally"](function() {
                            $rootScope.$emit("$translateRefreshEnd", {
                                language: langKey
                            });
                        });
                        if (!langKey) {
                            var languagesToReload = $fallbackLanguage && $fallbackLanguage.slice() || [];
                            if ($uses && languagesToReload.indexOf($uses) === -1) {
                                languagesToReload.push($uses);
                            }
                            $q.all(languagesToReload.map(loadNewData)).then(deferred.resolve, deferred.reject);
                        } else if ($translationTable[langKey]) {
                            loadNewData(langKey).then(deferred.resolve, deferred.reject);
                        } else {
                            deferred.reject();
                        }
                        return deferred.promise;
                    };
                    $translate.instant = function(translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy) {
                        var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                        if (translationId === null || angular.isUndefined(translationId)) {
                            return translationId;
                        }
                        if (forceLanguage) {
                            loadTranslationsIfMissing(forceLanguage);
                        }
                        if (angular.isArray(translationId)) {
                            var results = {};
                            for (var i = 0, c = translationId.length; i < c; i++) {
                                results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage, sanitizeStrategy);
                            }
                            return results;
                        }
                        if (angular.isString(translationId) && translationId.length < 1) {
                            return translationId;
                        }
                        if (translationId) {
                            translationId = trim.apply(translationId);
                        }
                        var result, possibleLangKeys = [];
                        if ($preferredLanguage) {
                            possibleLangKeys.push($preferredLanguage);
                        }
                        if (uses) {
                            possibleLangKeys.push(uses);
                        }
                        if ($fallbackLanguage && $fallbackLanguage.length) {
                            possibleLangKeys = possibleLangKeys.concat($fallbackLanguage);
                        }
                        for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
                            var possibleLangKey = possibleLangKeys[j];
                            if ($translationTable[possibleLangKey]) {
                                if (typeof $translationTable[possibleLangKey][translationId] !== "undefined") {
                                    result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy);
                                }
                            }
                            if (typeof result !== "undefined") {
                                break;
                            }
                        }
                        if (!result && result !== "") {
                            if ($notFoundIndicatorLeft || $notFoundIndicatorRight) {
                                result = applyNotFoundIndicators(translationId);
                            } else {
                                result = defaultInterpolator.interpolate(translationId, interpolateParams, "filter", sanitizeStrategy);
                                var missingTranslationHandlerTranslation;
                                if ($missingTranslationHandlerFactory && !pendingLoader) {
                                    missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy);
                                }
                                if ($missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation) {
                                    result = missingTranslationHandlerTranslation;
                                }
                            }
                        }
                        return result;
                    };
                    $translate.versionInfo = function() {
                        return version;
                    };
                    $translate.loaderCache = function() {
                        return loaderCache;
                    };
                    $translate.directivePriority = function() {
                        return directivePriority;
                    };
                    $translate.statefulFilter = function() {
                        return statefulFilter;
                    };
                    $translate.isReady = function() {
                        return $isReady;
                    };
                    var $onReadyDeferred = $q.defer();
                    $onReadyDeferred.promise.then(function() {
                        $isReady = true;
                    });
                    $translate.onReady = function(fn) {
                        var deferred = $q.defer();
                        if (angular.isFunction(fn)) {
                            deferred.promise.then(fn);
                        }
                        if ($isReady) {
                            deferred.resolve();
                        } else {
                            $onReadyDeferred.promise.then(deferred.resolve);
                        }
                        return deferred.promise;
                    };
                    $translate.getAvailableLanguageKeys = function() {
                        if ($availableLanguageKeys.length > 0) {
                            return $availableLanguageKeys;
                        }
                        return null;
                    };
                    $translate.getTranslationTable = function(langKey) {
                        langKey = langKey || $translate.use();
                        if (langKey && $translationTable[langKey]) {
                            return angular.copy($translationTable[langKey]);
                        }
                        return null;
                    };
                    var globalOnReadyListener = $rootScope.$on("$translateReady", function() {
                        $onReadyDeferred.resolve();
                        globalOnReadyListener();
                        globalOnReadyListener = null;
                    });
                    var globalOnChangeListener = $rootScope.$on("$translateChangeEnd", function() {
                        $onReadyDeferred.resolve();
                        globalOnChangeListener();
                        globalOnChangeListener = null;
                    });
                    if ($loaderFactory) {
                        if (angular.equals($translationTable, {})) {
                            if ($translate.use()) {
                                $translate.use($translate.use());
                            }
                        }
                        if ($fallbackLanguage && $fallbackLanguage.length) {
                            var processAsyncResult = function(translation) {
                                translations(translation.key, translation.table);
                                $rootScope.$emit("$translateChangeEnd", {
                                    language: translation.key
                                });
                                return translation;
                            };
                            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) {
                                var fallbackLanguageId = $fallbackLanguage[i];
                                if ($forceAsyncReloadEnabled || !$translationTable[fallbackLanguageId]) {
                                    langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult);
                                }
                            }
                        }
                    } else {
                        $rootScope.$emit("$translateReady", {
                            language: $translate.use()
                        });
                    }
                    return $translate;
                } ];
            }
            $translate.displayName = "displayName";
            angular.module("pascalprecht.translate").factory("$translateDefaultInterpolation", $translateDefaultInterpolation);
            function $translateDefaultInterpolation($interpolate, $translateSanitization) {
                "use strict";
                var $translateInterpolator = {}, $locale, $identifier = "default";
                $translateInterpolator.setLocale = function(locale) {
                    $locale = locale;
                };
                $translateInterpolator.getInterpolationIdentifier = function() {
                    return $identifier;
                };
                $translateInterpolator.useSanitizeValueStrategy = function(value) {
                    $translateSanitization.useStrategy(value);
                    return this;
                };
                $translateInterpolator.interpolate = function(value, interpolationParams, context, sanitizeStrategy, translationId) {
                    interpolationParams = interpolationParams || {};
                    interpolationParams = $translateSanitization.sanitize(interpolationParams, "params", sanitizeStrategy, context);
                    var interpolatedText;
                    if (angular.isNumber(value)) {
                        interpolatedText = "" + value;
                    } else if (angular.isString(value)) {
                        interpolatedText = $interpolate(value)(interpolationParams);
                        interpolatedText = $translateSanitization.sanitize(interpolatedText, "text", sanitizeStrategy, context);
                    } else {
                        interpolatedText = "";
                    }
                    return interpolatedText;
                };
                return $translateInterpolator;
            }
            $translateDefaultInterpolation.displayName = "$translateDefaultInterpolation";
            angular.module("pascalprecht.translate").constant("$STORAGE_KEY", "NG_TRANSLATE_LANG_KEY");
            angular.module("pascalprecht.translate").directive("translate", translateDirective);
            function translateDirective($translate, $interpolate, $compile, $parse, $rootScope) {
                "use strict";
                var trim = function() {
                    return this.toString().replace(/^\s+|\s+$/g, "");
                };
                var lowercase = function(string) {
                    return angular.isString(string) ? string.toLowerCase() : string;
                };
                return {
                    restrict: "AE",
                    scope: true,
                    priority: $translate.directivePriority(),
                    compile: function(tElement, tAttr) {
                        var translateValuesExist = tAttr.translateValues ? tAttr.translateValues : undefined;
                        var translateInterpolation = tAttr.translateInterpolation ? tAttr.translateInterpolation : undefined;
                        var translateSanitizeStrategyExist = tAttr.translateSanitizeStrategy ? tAttr.translateSanitizeStrategy : undefined;
                        var translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i);
                        var interpolateRegExp = "^(.*)(" + $interpolate.startSymbol() + ".*" + $interpolate.endSymbol() + ")(.*)", watcherRegExp = "^(.*)" + $interpolate.startSymbol() + "(.*)" + $interpolate.endSymbol() + "(.*)";
                        return function linkFn(scope, iElement, iAttr) {
                            scope.interpolateParams = {};
                            scope.preText = "";
                            scope.postText = "";
                            scope.translateNamespace = getTranslateNamespace(scope);
                            var translationIds = {};
                            var initInterpolationParams = function(interpolateParams, iAttr, tAttr) {
                                if (iAttr.translateValues) {
                                    angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent));
                                }
                                if (translateValueExist) {
                                    for (var attr in tAttr) {
                                        if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === "translateValue" && attr !== "translateValues") {
                                            var attributeName = lowercase(attr.substr(14, 1)) + attr.substr(15);
                                            interpolateParams[attributeName] = tAttr[attr];
                                        }
                                    }
                                }
                            };
                            var observeElementTranslation = function(translationId) {
                                if (angular.isFunction(observeElementTranslation._unwatchOld)) {
                                    observeElementTranslation._unwatchOld();
                                    observeElementTranslation._unwatchOld = undefined;
                                }
                                if (angular.equals(translationId, "") || !angular.isDefined(translationId)) {
                                    var iElementText = trim.apply(iElement.text());
                                    var interpolateMatches = iElementText.match(interpolateRegExp);
                                    if (angular.isArray(interpolateMatches)) {
                                        scope.preText = interpolateMatches[1];
                                        scope.postText = interpolateMatches[3];
                                        translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                                        var watcherMatches = iElementText.match(watcherRegExp);
                                        if (angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length) {
                                            observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                                                translationIds.translate = newValue;
                                                updateTranslations();
                                            });
                                        }
                                    } else {
                                        translationIds.translate = !iElementText ? undefined : iElementText;
                                    }
                                } else {
                                    translationIds.translate = translationId;
                                }
                                updateTranslations();
                            };
                            var observeAttributeTranslation = function(translateAttr) {
                                iAttr.$observe(translateAttr, function(translationId) {
                                    translationIds[translateAttr] = translationId;
                                    updateTranslations();
                                });
                            };
                            initInterpolationParams(scope.interpolateParams, iAttr, tAttr);
                            var firstAttributeChangedEvent = true;
                            iAttr.$observe("translate", function(translationId) {
                                if (typeof translationId === "undefined") {
                                    observeElementTranslation("");
                                } else {
                                    if (translationId !== "" || !firstAttributeChangedEvent) {
                                        translationIds.translate = translationId;
                                        updateTranslations();
                                    }
                                }
                                firstAttributeChangedEvent = false;
                            });
                            for (var translateAttr in iAttr) {
                                if (iAttr.hasOwnProperty(translateAttr) && translateAttr.substr(0, 13) === "translateAttr" && translateAttr.length > 13) {
                                    observeAttributeTranslation(translateAttr);
                                }
                            }
                            iAttr.$observe("translateDefault", function(value) {
                                scope.defaultText = value;
                                updateTranslations();
                            });
                            if (translateSanitizeStrategyExist) {
                                iAttr.$observe("translateSanitizeStrategy", function(value) {
                                    scope.sanitizeStrategy = $parse(value)(scope.$parent);
                                    updateTranslations();
                                });
                            }
                            if (translateValuesExist) {
                                iAttr.$observe("translateValues", function(interpolateParams) {
                                    if (interpolateParams) {
                                        scope.$parent.$watch(function() {
                                            angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent));
                                        });
                                    }
                                });
                            }
                            if (translateValueExist) {
                                var observeValueAttribute = function(attrName) {
                                    iAttr.$observe(attrName, function(value) {
                                        var attributeName = lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                                        scope.interpolateParams[attributeName] = value;
                                    });
                                };
                                for (var attr in iAttr) {
                                    if (Object.prototype.hasOwnProperty.call(iAttr, attr) && attr.substr(0, 14) === "translateValue" && attr !== "translateValues") {
                                        observeValueAttribute(attr);
                                    }
                                }
                            }
                            var updateTranslations = function() {
                                for (var key in translationIds) {
                                    if (translationIds.hasOwnProperty(key) && translationIds[key] !== undefined) {
                                        updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace);
                                    }
                                }
                            };
                            var updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
                                if (translationId) {
                                    if (translateNamespace && translationId.charAt(0) === ".") {
                                        translationId = translateNamespace + translationId;
                                    }
                                    $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage, scope.sanitizeStrategy).then(function(translation) {
                                        applyTranslation(translation, scope, true, translateAttr);
                                    }, function(translationId) {
                                        applyTranslation(translationId, scope, false, translateAttr);
                                    });
                                } else {
                                    applyTranslation(translationId, scope, false, translateAttr);
                                }
                            };
                            var applyTranslation = function(value, scope, successful, translateAttr) {
                                if (!successful) {
                                    if (typeof scope.defaultText !== "undefined") {
                                        value = scope.defaultText;
                                    }
                                }
                                if (translateAttr === "translate") {
                                    if (successful || !successful && !$translate.isKeepContent() && typeof iAttr.translateKeepContent === "undefined") {
                                        iElement.empty().append(scope.preText + value + scope.postText);
                                    }
                                    var globallyEnabled = $translate.isPostCompilingEnabled();
                                    var locallyDefined = typeof tAttr.translateCompile !== "undefined";
                                    var locallyEnabled = locallyDefined && tAttr.translateCompile !== "false";
                                    if (globallyEnabled && !locallyDefined || locallyEnabled) {
                                        $compile(iElement.contents())(scope);
                                    }
                                } else {
                                    var attributeName = iAttr.$attr[translateAttr];
                                    if (attributeName.substr(0, 5) === "data-") {
                                        attributeName = attributeName.substr(5);
                                    }
                                    attributeName = attributeName.substr(15);
                                    iElement.attr(attributeName, value);
                                }
                            };
                            if (translateValuesExist || translateValueExist || iAttr.translateDefault) {
                                scope.$watch("interpolateParams", updateTranslations, true);
                            }
                            scope.$on("translateLanguageChanged", updateTranslations);
                            var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                            if (iElement.text().length) {
                                if (iAttr.translate) {
                                    observeElementTranslation(iAttr.translate);
                                } else {
                                    observeElementTranslation("");
                                }
                            } else if (iAttr.translate) {
                                observeElementTranslation(iAttr.translate);
                            }
                            updateTranslations();
                            scope.$on("$destroy", unbind);
                        };
                    }
                };
            }
            function getTranslateNamespace(scope) {
                "use strict";
                if (scope.translateNamespace) {
                    return scope.translateNamespace;
                }
                if (scope.$parent) {
                    return getTranslateNamespace(scope.$parent);
                }
            }
            translateDirective.displayName = "translateDirective";
            angular.module("pascalprecht.translate").directive("translateAttr", translateAttrDirective);
            function translateAttrDirective($translate, $rootScope) {
                "use strict";
                return {
                    restrict: "A",
                    priority: $translate.directivePriority(),
                    link: function linkFn(scope, element, attr) {
                        var translateAttr, translateValues, translateSanitizeStrategy, previousAttributes = {};
                        var updateTranslations = function() {
                            angular.forEach(translateAttr, function(translationId, attributeName) {
                                if (!translationId) {
                                    return;
                                }
                                previousAttributes[attributeName] = true;
                                if (scope.translateNamespace && translationId.charAt(0) === ".") {
                                    translationId = scope.translateNamespace + translationId;
                                }
                                $translate(translationId, translateValues, attr.translateInterpolation, undefined, scope.translateLanguage, translateSanitizeStrategy).then(function(translation) {
                                    element.attr(attributeName, translation);
                                }, function(translationId) {
                                    element.attr(attributeName, translationId);
                                });
                            });
                            angular.forEach(previousAttributes, function(flag, attributeName) {
                                if (!translateAttr[attributeName]) {
                                    element.removeAttr(attributeName);
                                    delete previousAttributes[attributeName];
                                }
                            });
                        };
                        watchAttribute(scope, attr.translateAttr, function(newValue) {
                            translateAttr = newValue;
                        }, updateTranslations);
                        watchAttribute(scope, attr.translateValues, function(newValue) {
                            translateValues = newValue;
                        }, updateTranslations);
                        watchAttribute(scope, attr.translateSanitizeStrategy, function(newValue) {
                            translateSanitizeStrategy = newValue;
                        }, updateTranslations);
                        if (attr.translateValues) {
                            scope.$watch(attr.translateValues, updateTranslations, true);
                        }
                        scope.$on("translateLanguageChanged", updateTranslations);
                        var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                        updateTranslations();
                        scope.$on("$destroy", unbind);
                    }
                };
            }
            function watchAttribute(scope, attribute, valueCallback, changeCallback) {
                "use strict";
                if (!attribute) {
                    return;
                }
                if (attribute.substr(0, 2) === "::") {
                    attribute = attribute.substr(2);
                } else {
                    scope.$watch(attribute, function(newValue) {
                        valueCallback(newValue);
                        changeCallback();
                    }, true);
                }
                valueCallback(scope.$eval(attribute));
            }
            translateAttrDirective.displayName = "translateAttrDirective";
            angular.module("pascalprecht.translate").directive("translateCloak", translateCloakDirective);
            function translateCloakDirective($translate, $rootScope) {
                "use strict";
                return {
                    compile: function(tElement) {
                        var applyCloak = function(element) {
                            element.addClass($translate.cloakClassName());
                        }, removeCloak = function(element) {
                            element.removeClass($translate.cloakClassName());
                        };
                        applyCloak(tElement);
                        return function linkFn(scope, iElement, iAttr) {
                            var iRemoveCloak = removeCloak.bind(this, iElement), iApplyCloak = applyCloak.bind(this, iElement);
                            if (iAttr.translateCloak && iAttr.translateCloak.length) {
                                iAttr.$observe("translateCloak", function(translationId) {
                                    $translate(translationId).then(iRemoveCloak, iApplyCloak);
                                });
                                $rootScope.$on("$translateChangeSuccess", function() {
                                    $translate(iAttr.translateCloak).then(iRemoveCloak, iApplyCloak);
                                });
                            } else {
                                $translate.onReady(iRemoveCloak);
                            }
                        };
                    }
                };
            }
            translateCloakDirective.displayName = "translateCloakDirective";
            angular.module("pascalprecht.translate").directive("translateNamespace", translateNamespaceDirective);
            function translateNamespaceDirective() {
                "use strict";
                return {
                    restrict: "A",
                    scope: true,
                    compile: function() {
                        return {
                            pre: function(scope, iElement, iAttrs) {
                                scope.translateNamespace = getTranslateNamespace(scope);
                                if (scope.translateNamespace && iAttrs.translateNamespace.charAt(0) === ".") {
                                    scope.translateNamespace += iAttrs.translateNamespace;
                                } else {
                                    scope.translateNamespace = iAttrs.translateNamespace;
                                }
                            }
                        };
                    }
                };
            }
            function getTranslateNamespace(scope) {
                "use strict";
                if (scope.translateNamespace) {
                    return scope.translateNamespace;
                }
                if (scope.$parent) {
                    return getTranslateNamespace(scope.$parent);
                }
            }
            translateNamespaceDirective.displayName = "translateNamespaceDirective";
            angular.module("pascalprecht.translate").directive("translateLanguage", translateLanguageDirective);
            function translateLanguageDirective() {
                "use strict";
                return {
                    restrict: "A",
                    scope: true,
                    compile: function() {
                        return function linkFn(scope, iElement, iAttrs) {
                            iAttrs.$observe("translateLanguage", function(newTranslateLanguage) {
                                scope.translateLanguage = newTranslateLanguage;
                            });
                            scope.$watch("translateLanguage", function() {
                                scope.$broadcast("translateLanguageChanged");
                            });
                        };
                    }
                };
            }
            translateLanguageDirective.displayName = "translateLanguageDirective";
            angular.module("pascalprecht.translate").filter("translate", translateFilterFactory);
            function translateFilterFactory($parse, $translate) {
                "use strict";
                var translateFilter = function(translationId, interpolateParams, interpolation, forceLanguage) {
                    if (!angular.isObject(interpolateParams)) {
                        var ctx = this || {
                            __SCOPE_IS_NOT_AVAILABLE: "More info at https://github.com/angular/angular.js/commit/8863b9d04c722b278fa93c5d66ad1e578ad6eb1f"
                        };
                        interpolateParams = $parse(interpolateParams)(ctx);
                    }
                    return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage);
                };
                if ($translate.statefulFilter()) {
                    translateFilter.$stateful = true;
                }
                return translateFilter;
            }
            translateFilterFactory.displayName = "translateFilterFactory";
            angular.module("pascalprecht.translate").factory("$translationCache", $translationCache);
            function $translationCache($cacheFactory) {
                "use strict";
                return $cacheFactory("translations");
            }
            $translationCache.displayName = "$translationCache";
            return "pascalprecht.translate";
        });
    }, {} ],
    93: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var ng_from_import = require("angular");
        var ng_from_global = angular;
        exports.ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global;
    }, {
        angular: 108
    } ],
    94: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var angular_1 = require("../angular");
        var core_1 = require("@uirouter/core");
        function parseStateRef(ref) {
            var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/), parsed;
            if (paramsOnly) ref = "(" + paramsOnly[1] + ")";
            parsed = ref.replace(/\n/g, " ").match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
            if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
            return {
                state: parsed[1] || null,
                paramExpr: parsed[3] || null
            };
        }
        function stateContext(el) {
            var $uiView = el.parent().inheritedData("$uiView");
            var path = core_1.parse("$cfg.path")($uiView);
            return path ? core_1.tail(path).state.name : undefined;
        }
        function processedDef($state, $element, def) {
            var uiState = def.uiState || $state.current.name;
            var uiStateOpts = core_1.extend(defaultOpts($element, $state), def.uiStateOpts || {});
            var href = $state.href(uiState, def.uiStateParams, uiStateOpts);
            return {
                uiState: uiState,
                uiStateParams: def.uiStateParams,
                uiStateOpts: uiStateOpts,
                href: href
            };
        }
        function getTypeInfo(el) {
            var isSvg = Object.prototype.toString.call(el.prop("href")) === "[object SVGAnimatedString]";
            var isForm = el[0].nodeName === "FORM";
            return {
                attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
                isAnchor: el.prop("tagName").toUpperCase() === "A",
                clickable: !isForm
            };
        }
        function clickHook(el, $state, $timeout, type, getDef) {
            return function(e) {
                var button = e.which || e.button, target = getDef();
                if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target"))) {
                    var transition = $timeout(function() {
                        $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
                    });
                    e.preventDefault();
                    var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                    e.preventDefault = function() {
                        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
                    };
                }
            };
        }
        function defaultOpts(el, $state) {
            return {
                relative: stateContext(el) || $state.$current,
                inherit: true,
                source: "sref"
            };
        }
        function bindEvents(element, scope, hookFn, uiStateOpts) {
            var events;
            if (uiStateOpts) {
                events = uiStateOpts.events;
            }
            if (!core_1.isArray(events)) {
                events = [ "click" ];
            }
            var on = element.on ? "on" : "bind";
            for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
                var event_1 = events_1[_i];
                element[on](event_1, hookFn);
            }
            scope.$on("$destroy", function() {
                var off = element.off ? "off" : "unbind";
                for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {
                    var event_2 = events_2[_i];
                    element[off](event_2, hookFn);
                }
            });
        }
        var uiSref;
        uiSref = [ "$uiRouter", "$timeout", function $StateRefDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: "A",
                require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
                link: function(scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function() {
                        return processedDef($state, element, rawDef);
                    };
                    var ref = parseStateRef(attrs.uiSref);
                    rawDef.uiState = ref.state;
                    rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn) unlinkInfoFn();
                        if (active) unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null) attrs.$set(type.attr, def.href);
                    }
                    if (ref.paramExpr) {
                        scope.$watch(ref.paramExpr, function(val) {
                            rawDef.uiStateParams = core_1.extend({}, val);
                            update();
                        }, true);
                        rawDef.uiStateParams = core_1.extend({}, scope.$eval(ref.paramExpr));
                    }
                    update();
                    scope.$on("$destroy", $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on("$destroy", $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable) return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                }
            };
        } ];
        var uiState;
        uiState = [ "$uiRouter", "$timeout", function $StateRefDynamicDirective($uiRouter, $timeout) {
            var $state = $uiRouter.stateService;
            return {
                restrict: "A",
                require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
                link: function(scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var unlinkInfoFn = null;
                    var hookFn;
                    var rawDef = {};
                    var getDef = function() {
                        return processedDef($state, element, rawDef);
                    };
                    var inputAttrs = [ "uiState", "uiStateParams", "uiStateOpts" ];
                    var watchDeregFns = inputAttrs.reduce(function(acc, attr) {
                        return acc[attr] = core_1.noop, acc;
                    }, {});
                    function update() {
                        var def = getDef();
                        if (unlinkInfoFn) unlinkInfoFn();
                        if (active) unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);
                        if (def.href != null) attrs.$set(type.attr, def.href);
                    }
                    inputAttrs.forEach(function(field) {
                        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
                        attrs.$observe(field, function(expr) {
                            watchDeregFns[field]();
                            watchDeregFns[field] = scope.$watch(expr, function(newval) {
                                rawDef[field] = newval;
                                update();
                            }, true);
                        });
                    });
                    update();
                    scope.$on("$destroy", $uiRouter.stateRegistry.onStatesChanged(update));
                    scope.$on("$destroy", $uiRouter.transitionService.onSuccess({}, update));
                    if (!type.clickable) return;
                    hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts);
                }
            };
        } ];
        var uiSrefActive;
        uiSrefActive = [ "$state", "$stateParams", "$interpolate", "$uiRouter", function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {
            return {
                restrict: "A",
                controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                    var states = [], activeEqClass, uiSrefActive;
                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", false)($scope);
                    try {
                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                    } catch (e) {}
                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", false)($scope);
                    if (core_1.isObject(uiSrefActive)) {
                        core_1.forEach(uiSrefActive, function(stateOrName, activeClass) {
                            if (core_1.isString(stateOrName)) {
                                var ref = parseStateRef(stateOrName);
                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                            }
                        });
                    }
                    this.$$addStateInfo = function(newState, newParams) {
                        if (core_1.isObject(uiSrefActive) && states.length > 0) {
                            return;
                        }
                        var deregister = addState(newState, newParams, uiSrefActive);
                        update();
                        return deregister;
                    };
                    function updateAfterTransition(trans) {
                        trans.promise.then(update);
                    }
                    $scope.$on("$stateChangeSuccess", update);
                    $scope.$on("$destroy", $uiRouter.transitionService.onStart({}, updateAfterTransition));
                    if ($uiRouter.globals.transition) {
                        updateAfterTransition($uiRouter.globals.transition);
                    }
                    function addState(stateName, stateParams, activeClass) {
                        var state = $state.get(stateName, stateContext($element));
                        var stateInfo = {
                            state: state || {
                                name: stateName
                            },
                            params: stateParams,
                            activeClass: activeClass
                        };
                        states.push(stateInfo);
                        return function removeState() {
                            core_1.removeFrom(states)(stateInfo);
                        };
                    }
                    function update() {
                        var splitClasses = function(str) {
                            return str.split(/\s/).filter(core_1.identity);
                        };
                        var getClasses = function(stateList) {
                            return stateList.map(function(x) {
                                return x.activeClass;
                            }).map(splitClasses).reduce(core_1.unnestR, []);
                        };
                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core_1.uniqR, []);
                        var fuzzyClasses = getClasses(states.filter(function(x) {
                            return $state.includes(x.state.name, x.params);
                        }));
                        var exactlyMatchesAny = !!states.filter(function(x) {
                            return $state.is(x.state.name, x.params);
                        }).length;
                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];
                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core_1.uniqR, []);
                        var removeClasses = allClasses.filter(function(cls) {
                            return !core_1.inArray(addClasses, cls);
                        });
                        $scope.$evalAsync(function() {
                            addClasses.forEach(function(className) {
                                return $element.addClass(className);
                            });
                            removeClasses.forEach(function(className) {
                                return $element.removeClass(className);
                            });
                        });
                    }
                    update();
                } ]
            };
        } ];
        angular_1.ng.module("ui.router.state").directive("uiSref", uiSref).directive("uiSrefActive", uiSrefActive).directive("uiSrefActiveEq", uiSrefActive).directive("uiState", uiState);
    }, {
        "../angular": 93,
        "@uirouter/core": 35
    } ],
    95: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var angular_1 = require("../angular");
        var angular_2 = require("angular");
        var core_1 = require("@uirouter/core");
        var views_1 = require("../statebuilders/views");
        var services_1 = require("../services");
        exports.uiView = [ "$view", "$animate", "$uiViewScroll", "$interpolate", "$q", function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {
            function getRenderer(attrs, scope) {
                return {
                    enter: function(element, target, cb) {
                        if (angular_1.ng.version.minor > 2) {
                            $animate.enter(element, null, target).then(cb);
                        } else {
                            $animate.enter(element, null, target, cb);
                        }
                    },
                    leave: function(element, cb) {
                        if (angular_1.ng.version.minor > 2) {
                            $animate.leave(element).then(cb);
                        } else {
                            $animate.leave(element, cb);
                        }
                    }
                };
            }
            function configsEqual(config1, config2) {
                return config1 === config2;
            }
            var rootData = {
                $cfg: {
                    viewDecl: {
                        $context: $view._pluginapi._rootViewContext()
                    }
                },
                $uiView: {}
            };
            var directive = {
                count: 0,
                restrict: "ECA",
                terminal: true,
                priority: 400,
                transclude: "element",
                compile: function(tElement, tAttrs, $transclude) {
                    return function(scope, $element, attrs) {
                        var previousEl, currentEl, currentScope, unregister, onloadExp = attrs["onload"] || "", autoScrollExp = attrs["autoscroll"], renderer = getRenderer(attrs, scope), viewConfig = undefined, inherited = $element.inheritedData("$uiView") || rootData, name = $interpolate(attrs["uiView"] || attrs["name"] || "")(scope) || "$default";
                        var activeUIView = {
                            $type: "ng1",
                            id: directive.count++,
                            name: name,
                            fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + "." + name : name,
                            config: null,
                            configUpdated: configUpdatedCallback,
                            get creationContext() {
                                var fromParentTagConfig = core_1.parse("$cfg.viewDecl.$context")(inherited);
                                var fromParentTag = core_1.parse("$uiView.creationContext")(inherited);
                                return fromParentTagConfig || fromParentTag;
                            }
                        };
                        core_1.trace.traceUIViewEvent("Linking", activeUIView);
                        function configUpdatedCallback(config) {
                            if (config && !(config instanceof views_1.Ng1ViewConfig)) return;
                            if (configsEqual(viewConfig, config)) return;
                            core_1.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);
                            viewConfig = config;
                            updateView(config);
                        }
                        $element.data("$uiView", {
                            $uiView: activeUIView
                        });
                        updateView();
                        unregister = $view.registerUIView(activeUIView);
                        scope.$on("$destroy", function() {
                            core_1.trace.traceUIViewEvent("Destroying/Unregistering", activeUIView);
                            unregister();
                        });
                        function cleanupLastView() {
                            if (previousEl) {
                                core_1.trace.traceUIViewEvent("Removing (previous) el", previousEl.data("$uiView"));
                                previousEl.remove();
                                previousEl = null;
                            }
                            if (currentScope) {
                                core_1.trace.traceUIViewEvent("Destroying scope", activeUIView);
                                currentScope.$destroy();
                                currentScope = null;
                            }
                            if (currentEl) {
                                var _viewData_1 = currentEl.data("$uiViewAnim");
                                core_1.trace.traceUIViewEvent("Animate out", _viewData_1);
                                renderer.leave(currentEl, function() {
                                    _viewData_1.$$animLeave.resolve();
                                    previousEl = null;
                                });
                                previousEl = currentEl;
                                currentEl = null;
                            }
                        }
                        function updateView(config) {
                            var newScope = scope.$new();
                            var animEnter = $q.defer(), animLeave = $q.defer();
                            var $uiViewData = {
                                $cfg: config,
                                $uiView: activeUIView
                            };
                            var $uiViewAnim = {
                                $animEnter: animEnter.promise,
                                $animLeave: animLeave.promise,
                                $$animLeave: animLeave
                            };
                            newScope.$emit("$viewContentLoading", name);
                            var cloned = $transclude(newScope, function(clone) {
                                clone.data("$uiViewAnim", $uiViewAnim);
                                clone.data("$uiView", $uiViewData);
                                renderer.enter(clone, $element, function onUIViewEnter() {
                                    animEnter.resolve();
                                    if (currentScope) currentScope.$emit("$viewContentAnimationEnded");
                                    if (core_1.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                        $uiViewScroll(clone);
                                    }
                                });
                                cleanupLastView();
                            });
                            currentEl = cloned;
                            currentScope = newScope;
                            currentScope.$emit("$viewContentLoaded", config || viewConfig);
                            currentScope.$eval(onloadExp);
                        }
                    };
                }
            };
            return directive;
        } ];
        $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$transitions", "$view", "$q", "$timeout" ];
        function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {
            var getControllerAs = core_1.parse("viewDecl.controllerAs");
            var getResolveAs = core_1.parse("viewDecl.resolveAs");
            return {
                restrict: "ECA",
                priority: -400,
                compile: function(tElement) {
                    var initial = tElement.html();
                    tElement.empty();
                    return function(scope, $element) {
                        var data = $element.data("$uiView");
                        if (!data) {
                            $element.html(initial);
                            $compile($element.contents())(scope);
                            return;
                        }
                        var cfg = data.$cfg || {
                            viewDecl: {},
                            getTemplate: angular_2.noop
                        };
                        var resolveCtx = cfg.path && new core_1.ResolveContext(cfg.path);
                        $element.html(cfg.getTemplate($element, resolveCtx) || initial);
                        core_1.trace.traceUIViewFill(data.$uiView, $element.html());
                        var link = $compile($element.contents());
                        var controller = cfg.controller;
                        var controllerAs = getControllerAs(cfg);
                        var resolveAs = getResolveAs(cfg);
                        var locals = resolveCtx && services_1.getLocals(resolveCtx);
                        scope[resolveAs] = locals;
                        if (controller) {
                            var controllerInstance = $controller(controller, core_1.extend({}, locals, {
                                $scope: scope,
                                $element: $element
                            }));
                            if (controllerAs) {
                                scope[controllerAs] = controllerInstance;
                                scope[controllerAs][resolveAs] = locals;
                            }
                            $element.data("$ngControllerController", controllerInstance);
                            $element.children().data("$ngControllerController", controllerInstance);
                            registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);
                        }
                        if (core_1.isString(cfg.viewDecl.component)) {
                            var cmp_1 = cfg.viewDecl.component;
                            var kebobName = core_1.kebobString(cmp_1);
                            var tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", "i");
                            var getComponentController = function() {
                                var directiveEl = [].slice.call($element[0].children).filter(function(el) {
                                    return el && el.tagName && tagRegexp_1.exec(el.tagName);
                                });
                                return directiveEl && angular_1.ng.element(directiveEl).data("$" + cmp_1 + "Controller");
                            };
                            var deregisterWatch_1 = scope.$watch(getComponentController, function(ctrlInstance) {
                                if (!ctrlInstance) return;
                                registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);
                                deregisterWatch_1();
                            });
                        }
                        link(scope);
                    };
                }
            };
        }
        var hasComponentImpl = typeof angular_1.ng.module("ui.router")["component"] === "function";
        var _uiCanExitId = 0;
        function registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {
            if (core_1.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {
                controllerInstance.$onInit();
            }
            var viewState = core_1.tail(cfg.path).state.self;
            var hookOptions = {
                bind: controllerInstance
            };
            if (core_1.isFunction(controllerInstance.uiOnParamsChanged)) {
                var resolveContext = new core_1.ResolveContext(cfg.path);
                var viewCreationTrans_1 = resolveContext.getResolvable("$transition$").data;
                var paramsUpdated = function($transition$) {
                    if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1) return;
                    var toParams = $transition$.params("to");
                    var fromParams = $transition$.params("from");
                    var toSchema = $transition$.treeChanges().to.map(function(node) {
                        return node.paramSchema;
                    }).reduce(core_1.unnestR, []);
                    var fromSchema = $transition$.treeChanges().from.map(function(node) {
                        return node.paramSchema;
                    }).reduce(core_1.unnestR, []);
                    var changedToParams = toSchema.filter(function(param) {
                        var idx = fromSchema.indexOf(param);
                        return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
                    });
                    if (changedToParams.length) {
                        var changedKeys_1 = changedToParams.map(function(x) {
                            return x.id;
                        });
                        var newValues = core_1.filter(toParams, function(val, key) {
                            return changedKeys_1.indexOf(key) !== -1;
                        });
                        controllerInstance.uiOnParamsChanged(newValues, $transition$);
                    }
                };
                $scope.$on("$destroy", $transitions.onSuccess({}, paramsUpdated, hookOptions));
            }
            if (core_1.isFunction(controllerInstance.uiCanExit)) {
                var id_1 = _uiCanExitId++;
                var cacheProp_1 = "_uiCanExitIds";
                var prevTruthyAnswer_1 = function(trans) {
                    return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));
                };
                var wrappedHook = function(trans) {
                    var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};
                    if (!prevTruthyAnswer_1(trans)) {
                        promise = $q.when(controllerInstance.uiCanExit(trans));
                        promise.then(function(val) {
                            return ids[id_1] = val !== false;
                        });
                    }
                    return promise;
                };
                var criteria = {
                    exiting: viewState.name
                };
                $scope.$on("$destroy", $transitions.onBefore(criteria, wrappedHook, hookOptions));
            }
        }
        angular_1.ng.module("ui.router.state").directive("uiView", exports.uiView);
        angular_1.ng.module("ui.router.state").directive("uiView", $ViewDirectiveFill);
    }, {
        "../angular": 93,
        "../services": 99,
        "../statebuilders/views": 103,
        "@uirouter/core": 35,
        angular: 108
    } ],
    96: [ function(require, module, exports) {
        "use strict";
        function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var core = require("@uirouter/core");
        exports.core = core;
        __export(require("@uirouter/core"));
        __export(require("./services"));
        __export(require("./statebuilders/views"));
        __export(require("./stateProvider"));
        __export(require("./urlRouterProvider"));
        require("./injectables");
        require("./directives/stateDirectives");
        require("./stateFilters");
        require("./directives/viewDirective");
        require("./viewScroll");
        exports.default = "ui.router";
    }, {
        "./directives/stateDirectives": 94,
        "./directives/viewDirective": 95,
        "./injectables": 97,
        "./services": 99,
        "./stateFilters": 100,
        "./stateProvider": 101,
        "./statebuilders/views": 103,
        "./urlRouterProvider": 105,
        "./viewScroll": 106,
        "@uirouter/core": 35
    } ],
    97: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var $stateParams;
        var $uiRouterGlobals;
        var $uiRouter;
        var $uiRouterProvider;
        var $trace;
        var $transitions;
        var $transitionsProvider;
        var $transition$;
        var $state;
        var $stateRegistry;
        var $stateRegistryProvider;
        var $uiViewScrollProvider;
        var $uiViewScroll;
        var $stateProvider;
        var $urlServiceProvider;
        var $urlService;
        var $urlRouterProvider;
        var $urlRouter;
        var $urlMatcherFactory;
        var $urlMatcherFactoryProvider;
    }, {} ],
    98: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var core_1 = require("@uirouter/core");
        var Ng1LocationServices = function() {
            function Ng1LocationServices($locationProvider) {
                this._urlListeners = [];
                this.$locationProvider = $locationProvider;
                var _lp = core_1.val($locationProvider);
                core_1.createProxyFunctions(_lp, this, _lp, [ "hashPrefix" ]);
            }
            Ng1LocationServices.prototype.dispose = function() {};
            Ng1LocationServices.prototype.onChange = function(callback) {
                var _this = this;
                this._urlListeners.push(callback);
                return function() {
                    return core_1.removeFrom(_this._urlListeners)(callback);
                };
            };
            Ng1LocationServices.prototype.html5Mode = function() {
                var html5Mode = this.$locationProvider.html5Mode();
                html5Mode = core_1.isObject(html5Mode) ? html5Mode.enabled : html5Mode;
                return html5Mode && this.$sniffer.history;
            };
            Ng1LocationServices.prototype.url = function(newUrl, replace, state) {
                if (replace === void 0) {
                    replace = false;
                }
                if (newUrl) this.$location.url(newUrl);
                if (replace) this.$location.replace();
                if (state) this.$location.state(state);
                return this.$location.url();
            };
            Ng1LocationServices.prototype._runtimeServices = function($rootScope, $location, $sniffer, $browser) {
                var _this = this;
                this.$location = $location;
                this.$sniffer = $sniffer;
                $rootScope.$on("$locationChangeSuccess", function(evt) {
                    return _this._urlListeners.forEach(function(fn) {
                        return fn(evt);
                    });
                });
                var _loc = core_1.val($location);
                var _browser = core_1.val($browser);
                core_1.createProxyFunctions(_loc, this, _loc, [ "replace", "path", "search", "hash" ]);
                core_1.createProxyFunctions(_loc, this, _loc, [ "port", "protocol", "host" ]);
                core_1.createProxyFunctions(_browser, this, _browser, [ "baseHref" ]);
            };
            Ng1LocationServices.monkeyPatchPathParameterType = function(router) {
                var pathType = router.urlMatcherFactory.type("path");
                pathType.encode = function(val) {
                    return val != null ? val.toString().replace(/(~|\/)/g, function(m) {
                        return {
                            "~": "~~",
                            "/": "~2F"
                        }[m];
                    }) : val;
                };
                pathType.decode = function(val) {
                    return val != null ? val.toString().replace(/(~~|~2F)/g, function(m) {
                        return {
                            "~~": "~",
                            "~2F": "/"
                        }[m];
                    }) : val;
                };
            };
            return Ng1LocationServices;
        }();
        exports.Ng1LocationServices = Ng1LocationServices;
    }, {
        "@uirouter/core": 35
    } ],
    99: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var angular_1 = require("./angular");
        var core_1 = require("@uirouter/core");
        var views_1 = require("./statebuilders/views");
        var templateFactory_1 = require("./templateFactory");
        var stateProvider_1 = require("./stateProvider");
        var onEnterExitRetain_1 = require("./statebuilders/onEnterExitRetain");
        var locationServices_1 = require("./locationServices");
        var urlRouterProvider_1 = require("./urlRouterProvider");
        angular_1.ng.module("ui.router.angular1", []);
        var mod_init = angular_1.ng.module("ui.router.init", []);
        var mod_util = angular_1.ng.module("ui.router.util", [ "ng", "ui.router.init" ]);
        var mod_rtr = angular_1.ng.module("ui.router.router", [ "ui.router.util" ]);
        var mod_state = angular_1.ng.module("ui.router.state", [ "ui.router.router", "ui.router.util", "ui.router.angular1" ]);
        var mod_main = angular_1.ng.module("ui.router", [ "ui.router.init", "ui.router.state", "ui.router.angular1" ]);
        var mod_cmpt = angular_1.ng.module("ui.router.compat", [ "ui.router" ]);
        var router = null;
        $uiRouter.$inject = [ "$locationProvider" ];
        function $uiRouter($locationProvider) {
            router = this.router = new core_1.UIRouter();
            router.stateProvider = new stateProvider_1.StateProvider(router.stateRegistry, router.stateService);
            router.stateRegistry.decorator("views", views_1.ng1ViewsBuilder);
            router.stateRegistry.decorator("onExit", onEnterExitRetain_1.getStateHookBuilder("onExit"));
            router.stateRegistry.decorator("onRetain", onEnterExitRetain_1.getStateHookBuilder("onRetain"));
            router.stateRegistry.decorator("onEnter", onEnterExitRetain_1.getStateHookBuilder("onEnter"));
            router.viewService._pluginapi._viewConfigFactory("ng1", views_1.getNg1ViewConfigFactory());
            var ng1LocationService = router.locationService = router.locationConfig = new locationServices_1.Ng1LocationServices($locationProvider);
            locationServices_1.Ng1LocationServices.monkeyPatchPathParameterType(router);
            router["router"] = router;
            router["$get"] = $get;
            $get.$inject = [ "$location", "$browser", "$sniffer", "$rootScope", "$http", "$templateCache" ];
            function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {
                ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);
                delete router["router"];
                delete router["$get"];
                return router;
            }
            return router;
        }
        var getProviderFor = function(serviceName) {
            return [ "$uiRouterProvider", function($urp) {
                var service = $urp.router[serviceName];
                service["$get"] = function() {
                    return service;
                };
                return service;
            } ];
        };
        runBlock.$inject = [ "$injector", "$q", "$uiRouter" ];
        function runBlock($injector, $q, $uiRouter) {
            core_1.services.$injector = $injector;
            core_1.services.$q = $q;
            $uiRouter.stateRegistry.get().map(function(x) {
                return x.$$state().resolvables;
            }).reduce(core_1.unnestR, []).filter(function(x) {
                return x.deps === "deferred";
            }).forEach(function(resolvable) {
                return resolvable.deps = $injector.annotate(resolvable.resolveFn);
            });
        }
        var getUrlRouterProvider = function(uiRouter) {
            return uiRouter.urlRouterProvider = new urlRouterProvider_1.UrlRouterProvider(uiRouter);
        };
        var getStateProvider = function() {
            return core_1.extend(router.stateProvider, {
                $get: function() {
                    return router.stateService;
                }
            });
        };
        watchDigests.$inject = [ "$rootScope" ];
        function watchDigests($rootScope) {
            $rootScope.$watch(function() {
                core_1.trace.approximateDigests++;
            });
        }
        exports.watchDigests = watchDigests;
        mod_init.provider("$uiRouter", $uiRouter);
        mod_rtr.provider("$urlRouter", [ "$uiRouterProvider", getUrlRouterProvider ]);
        mod_util.provider("$urlService", getProviderFor("urlService"));
        mod_util.provider("$urlMatcherFactory", function() {
            return router.urlMatcherFactory;
        });
        mod_util.provider("$templateFactory", function() {
            return new templateFactory_1.TemplateFactory();
        });
        mod_state.provider("$stateRegistry", getProviderFor("stateRegistry"));
        mod_state.provider("$uiRouterGlobals", getProviderFor("globals"));
        mod_state.provider("$transitions", getProviderFor("transitionService"));
        mod_state.provider("$state", [ "$uiRouterProvider", getStateProvider ]);
        mod_state.factory("$stateParams", [ "$uiRouter", function($uiRouter) {
            return $uiRouter.globals.params;
        } ]);
        mod_main.factory("$view", function() {
            return router.viewService;
        });
        mod_main.service("$trace", function() {
            return core_1.trace;
        });
        mod_main.run(watchDigests);
        mod_util.run([ "$urlMatcherFactory", function($urlMatcherFactory) {} ]);
        mod_state.run([ "$state", function($state) {} ]);
        mod_rtr.run([ "$urlRouter", function($urlRouter) {} ]);
        mod_init.run(runBlock);
        exports.getLocals = function(ctx) {
            var tokens = ctx.getTokens().filter(core_1.isString);
            var tuples = tokens.map(function(key) {
                var resolvable = ctx.getResolvable(key);
                var waitPolicy = ctx.getPolicy(resolvable).async;
                return [ key, waitPolicy === "NOWAIT" ? resolvable.promise : resolvable.data ];
            });
            return tuples.reduce(core_1.applyPairs, {});
        };
    }, {
        "./angular": 93,
        "./locationServices": 98,
        "./stateProvider": 101,
        "./statebuilders/onEnterExitRetain": 102,
        "./statebuilders/views": 103,
        "./templateFactory": 104,
        "./urlRouterProvider": 105,
        "@uirouter/core": 35
    } ],
    100: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var angular_1 = require("./angular");
        $IsStateFilter.$inject = [ "$state" ];
        function $IsStateFilter($state) {
            var isFilter = function(state, params, options) {
                return $state.is(state, params, options);
            };
            isFilter.$stateful = true;
            return isFilter;
        }
        exports.$IsStateFilter = $IsStateFilter;
        $IncludedByStateFilter.$inject = [ "$state" ];
        function $IncludedByStateFilter($state) {
            var includesFilter = function(state, params, options) {
                return $state.includes(state, params, options);
            };
            includesFilter.$stateful = true;
            return includesFilter;
        }
        exports.$IncludedByStateFilter = $IncludedByStateFilter;
        angular_1.ng.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
    }, {
        "./angular": 93
    } ],
    101: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var core_1 = require("@uirouter/core");
        var StateProvider = function() {
            function StateProvider(stateRegistry, stateService) {
                this.stateRegistry = stateRegistry;
                this.stateService = stateService;
                core_1.createProxyFunctions(core_1.val(StateProvider.prototype), this, core_1.val(this));
            }
            StateProvider.prototype.decorator = function(name, func) {
                return this.stateRegistry.decorator(name, func) || this;
            };
            StateProvider.prototype.state = function(name, definition) {
                if (core_1.isObject(name)) {
                    definition = name;
                } else {
                    definition.name = name;
                }
                this.stateRegistry.register(definition);
                return this;
            };
            StateProvider.prototype.onInvalid = function(callback) {
                return this.stateService.onInvalid(callback);
            };
            return StateProvider;
        }();
        exports.StateProvider = StateProvider;
    }, {
        "@uirouter/core": 35
    } ],
    102: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var core_1 = require("@uirouter/core");
        var services_1 = require("../services");
        exports.getStateHookBuilder = function(hookName) {
            return function stateHookBuilder(state, parentFn) {
                var hook = state[hookName];
                var pathname = hookName === "onExit" ? "from" : "to";
                function decoratedNg1Hook(trans, state) {
                    var resolveContext = new core_1.ResolveContext(trans.treeChanges(pathname));
                    var locals = core_1.extend(services_1.getLocals(resolveContext), {
                        $state$: state,
                        $transition$: trans
                    });
                    return core_1.services.$injector.invoke(hook, this, locals);
                }
                return hook ? decoratedNg1Hook : undefined;
            };
        };
    }, {
        "../services": 99,
        "@uirouter/core": 35
    } ],
    103: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var core_1 = require("@uirouter/core");
        function getNg1ViewConfigFactory() {
            var templateFactory = null;
            return function(path, view) {
                templateFactory = templateFactory || core_1.services.$injector.get("$templateFactory");
                return [ new Ng1ViewConfig(path, view, templateFactory) ];
            };
        }
        exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;
        var hasAnyKey = function(keys, obj) {
            return keys.reduce(function(acc, key) {
                return acc || core_1.isDefined(obj[key]);
            }, false);
        };
        function ng1ViewsBuilder(state) {
            if (!state.parent) return {};
            var tplKeys = [ "templateProvider", "templateUrl", "template", "notify", "async" ], ctrlKeys = [ "controller", "controllerProvider", "controllerAs", "resolveAs" ], compKeys = [ "component", "bindings", "componentProvider" ], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
            if (core_1.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
                throw new Error("State '" + state.name + "' has a 'views' object. " + 'It cannot also have "view properties" at the state level.  ' + "Move the following properties into a view (in the 'views' object): " + (" " + allViewKeys.filter(function(key) {
                    return core_1.isDefined(state[key]);
                }).join(", ")));
            }
            var views = {}, viewsObject = state.views || {
                $default: core_1.pick(state, allViewKeys)
            };
            core_1.forEach(viewsObject, function(config, name) {
                name = name || "$default";
                if (core_1.isString(config)) config = {
                    component: config
                };
                config = core_1.extend({}, config);
                if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
                    throw new Error("Cannot combine: " + compKeys.join("|") + " with: " + nonCompKeys.join("|") + " in stateview: '" + name + "@" + state.name + "'");
                }
                config.resolveAs = config.resolveAs || "$resolve";
                config.$type = "ng1";
                config.$context = state;
                config.$name = name;
                var normalized = core_1.ViewService.normalizeUIViewTarget(config.$context, config.$name);
                config.$uiViewName = normalized.uiViewName;
                config.$uiViewContextAnchor = normalized.uiViewContextAnchor;
                views[name] = config;
            });
            return views;
        }
        exports.ng1ViewsBuilder = ng1ViewsBuilder;
        var id = 0;
        var Ng1ViewConfig = function() {
            function Ng1ViewConfig(path, viewDecl, factory) {
                var _this = this;
                this.path = path;
                this.viewDecl = viewDecl;
                this.factory = factory;
                this.$id = id++;
                this.loaded = false;
                this.getTemplate = function(uiView, context) {
                    return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;
                };
            }
            Ng1ViewConfig.prototype.load = function() {
                var _this = this;
                var $q = core_1.services.$q;
                var context = new core_1.ResolveContext(this.path);
                var params = this.path.reduce(function(acc, node) {
                    return core_1.extend(acc, node.paramValues);
                }, {});
                var promises = {
                    template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),
                    controller: $q.when(this.getController(context))
                };
                return $q.all(promises).then(function(results) {
                    core_1.trace.traceViewServiceEvent("Loaded", _this);
                    _this.controller = results.controller;
                    core_1.extend(_this, results.template);
                    return _this;
                });
            };
            Ng1ViewConfig.prototype.getController = function(context) {
                var provider = this.viewDecl.controllerProvider;
                if (!core_1.isInjectable(provider)) return this.viewDecl.controller;
                var deps = core_1.services.$injector.annotate(provider);
                var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;
                var resolvable = new core_1.Resolvable("", providerFn, deps);
                return resolvable.get(context);
            };
            return Ng1ViewConfig;
        }();
        exports.Ng1ViewConfig = Ng1ViewConfig;
    }, {
        "@uirouter/core": 35
    } ],
    104: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var angular_1 = require("./angular");
        var core_1 = require("@uirouter/core");
        var TemplateFactory = function() {
            function TemplateFactory() {
                var _this = this;
                this._useHttp = angular_1.ng.version.minor < 3;
                this.$get = [ "$http", "$templateCache", "$injector", function($http, $templateCache, $injector) {
                    _this.$templateRequest = $injector.has && $injector.has("$templateRequest") && $injector.get("$templateRequest");
                    _this.$http = $http;
                    _this.$templateCache = $templateCache;
                    return _this;
                } ];
            }
            TemplateFactory.prototype.useHttpService = function(value) {
                this._useHttp = value;
            };
            TemplateFactory.prototype.fromConfig = function(config, params, context) {
                var defaultTemplate = "<ui-view></ui-view>";
                var asTemplate = function(result) {
                    return core_1.services.$q.when(result).then(function(str) {
                        return {
                            template: str
                        };
                    });
                };
                var asComponent = function(result) {
                    return core_1.services.$q.when(result).then(function(str) {
                        return {
                            component: str
                        };
                    });
                };
                return core_1.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) : core_1.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) : core_1.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) : core_1.isDefined(config.component) ? asComponent(config.component) : core_1.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) : asTemplate(defaultTemplate);
            };
            TemplateFactory.prototype.fromString = function(template, params) {
                return core_1.isFunction(template) ? template(params) : template;
            };
            TemplateFactory.prototype.fromUrl = function(url, params) {
                if (core_1.isFunction(url)) url = url(params);
                if (url == null) return null;
                if (this._useHttp) {
                    return this.$http.get(url, {
                        cache: this.$templateCache,
                        headers: {
                            Accept: "text/html"
                        }
                    }).then(function(response) {
                        return response.data;
                    });
                }
                return this.$templateRequest(url);
            };
            TemplateFactory.prototype.fromProvider = function(provider, params, context) {
                var deps = core_1.services.$injector.annotate(provider);
                var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;
                var resolvable = new core_1.Resolvable("", providerFn, deps);
                return resolvable.get(context);
            };
            TemplateFactory.prototype.fromComponentProvider = function(provider, params, context) {
                var deps = core_1.services.$injector.annotate(provider);
                var providerFn = core_1.isArray(provider) ? core_1.tail(provider) : provider;
                var resolvable = new core_1.Resolvable("", providerFn, deps);
                return resolvable.get(context);
            };
            TemplateFactory.prototype.makeComponentTemplate = function(uiView, context, component, bindings) {
                bindings = bindings || {};
                var prefix = angular_1.ng.version.minor >= 3 ? "::" : "";
                var kebob = function(camelCase) {
                    var kebobed = core_1.kebobString(camelCase);
                    return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
                };
                var attributeTpl = function(input) {
                    var name = input.name, type = input.type;
                    var attrName = kebob(name);
                    if (uiView.attr(attrName) && !bindings[name]) return attrName + "='" + uiView.attr(attrName) + "'";
                    var resolveName = bindings[name] || name;
                    if (type === "@") return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                    if (type === "&") {
                        var res = context.getResolvable(resolveName);
                        var fn = res && res.data;
                        var args = fn && core_1.services.$injector.annotate(fn) || [];
                        var arrayIdxStr = core_1.isArray(fn) ? "[" + (fn.length - 1) + "]" : "";
                        return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(",") + ")'";
                    }
                    return attrName + "='" + prefix + "$resolve." + resolveName + "'";
                };
                var attrs = getComponentBindings(component).map(attributeTpl).join(" ");
                var kebobName = kebob(component);
                return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
            };
            return TemplateFactory;
        }();
        exports.TemplateFactory = TemplateFactory;
        function getComponentBindings(name) {
            var cmpDefs = core_1.services.$injector.get(name + "Directive");
            if (!cmpDefs || !cmpDefs.length) throw new Error("Unable to find component named '" + name + "'");
            return cmpDefs.map(getBindings).reduce(core_1.unnestR, []);
        }
        var getBindings = function(def) {
            if (core_1.isObject(def.bindToController)) return scopeBindings(def.bindToController);
            return scopeBindings(def.scope);
        };
        var scopeBindings = function(bindingsObj) {
            return Object.keys(bindingsObj || {}).map(function(key) {
                return [ key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key]) ];
            }).filter(function(tuple) {
                return core_1.isDefined(tuple) && core_1.isArray(tuple[1]);
            }).map(function(tuple) {
                return {
                    name: tuple[1][2] || tuple[0],
                    type: tuple[1][1]
                };
            });
        };
    }, {
        "./angular": 93,
        "@uirouter/core": 35
    } ],
    105: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var core_1 = require("@uirouter/core");
        var core_2 = require("@uirouter/core");
        var UrlRouterProvider = function() {
            function UrlRouterProvider(router) {
                this._router = router;
                this._urlRouter = router.urlRouter;
            }
            UrlRouterProvider.prototype.$get = function() {
                var urlRouter = this._urlRouter;
                urlRouter.update(true);
                if (!urlRouter.interceptDeferred) urlRouter.listen();
                return urlRouter;
            };
            UrlRouterProvider.prototype.rule = function(ruleFn) {
                var _this = this;
                if (!core_2.isFunction(ruleFn)) throw new Error("'rule' must be a function");
                var match = function() {
                    return ruleFn(core_2.services.$injector, _this._router.locationService);
                };
                var rule = new core_1.BaseUrlRule(match, core_2.identity);
                this._urlRouter.rule(rule);
                return this;
            };
            UrlRouterProvider.prototype.otherwise = function(rule) {
                var _this = this;
                var urlRouter = this._urlRouter;
                if (core_2.isString(rule)) {
                    urlRouter.otherwise(rule);
                } else if (core_2.isFunction(rule)) {
                    urlRouter.otherwise(function() {
                        return rule(core_2.services.$injector, _this._router.locationService);
                    });
                } else {
                    throw new Error("'rule' must be a string or function");
                }
                return this;
            };
            UrlRouterProvider.prototype.when = function(what, handler) {
                if (core_2.isArray(handler) || core_2.isFunction(handler)) {
                    handler = UrlRouterProvider.injectableHandler(this._router, handler);
                }
                this._urlRouter.when(what, handler);
                return this;
            };
            UrlRouterProvider.injectableHandler = function(router, handler) {
                return function(match) {
                    return core_2.services.$injector.invoke(handler, null, {
                        $match: match,
                        $stateParams: router.globals.params
                    });
                };
            };
            UrlRouterProvider.prototype.deferIntercept = function(defer) {
                this._urlRouter.deferIntercept(defer);
            };
            return UrlRouterProvider;
        }();
        exports.UrlRouterProvider = UrlRouterProvider;
    }, {
        "@uirouter/core": 35
    } ],
    106: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var angular_1 = require("./angular");
        function $ViewScrollProvider() {
            var useAnchorScroll = false;
            this.useAnchorScroll = function() {
                useAnchorScroll = true;
            };
            this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
                if (useAnchorScroll) {
                    return $anchorScroll;
                }
                return function($element) {
                    return $timeout(function() {
                        $element[0].scrollIntoView();
                    }, 0, false);
                };
            } ];
        }
        angular_1.ng.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
    }, {
        "./angular": 93
    } ],
    107: [ function(require, module, exports) {
        (function(window) {
            "use strict";
            var minErrConfig = {
                objectMaxDepth: 5
            };
            function errorHandlingConfig(config) {
                if (isObject(config)) {
                    if (isDefined(config.objectMaxDepth)) {
                        minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN;
                    }
                } else {
                    return minErrConfig;
                }
            }
            function isValidObjectMaxDepth(maxDepth) {
                return isNumber(maxDepth) && maxDepth > 0;
            }
            function minErr(module, ErrorConstructor) {
                ErrorConstructor = ErrorConstructor || Error;
                return function() {
                    var code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                        return toDebugString(arg, minErrConfig.objectMaxDepth);
                    }), paramPrefix, i;
                    message += template.replace(/\{\d+\}/g, function(match) {
                        var index = +match.slice(1, -1);
                        if (index < templateArgs.length) {
                            return templateArgs[index];
                        }
                        return match;
                    });
                    message += "\nhttp://errors.angularjs.org/1.6.8/" + (module ? module + "/" : "") + code;
                    for (i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") {
                        message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                    }
                    return new ErrorConstructor(message);
                };
            }
            var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
            var VALIDITY_STATE_PROPERTY = "validity";
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var lowercase = function(string) {
                return isString(string) ? string.toLowerCase() : string;
            };
            var uppercase = function(string) {
                return isString(string) ? string.toUpperCase() : string;
            };
            var manualLowercase = function(s) {
                return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
                    return String.fromCharCode(ch.charCodeAt(0) | 32);
                }) : s;
            };
            var manualUppercase = function(s) {
                return isString(s) ? s.replace(/[a-z]/g, function(ch) {
                    return String.fromCharCode(ch.charCodeAt(0) & ~32);
                }) : s;
            };
            if ("i" !== "I".toLowerCase()) {
                lowercase = manualLowercase;
                uppercase = manualUppercase;
            }
            var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
            msie = window.document.documentMode;
            function isArrayLike(obj) {
                if (obj == null || isWindow(obj)) return false;
                if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return true;
                var length = "length" in Object(obj) && obj.length;
                return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || typeof obj.item === "function");
            }
            function forEach(obj, iterator, context) {
                var key, length;
                if (obj) {
                    if (isFunction(obj)) {
                        for (key in obj) {
                            if (key !== "prototype" && key !== "length" && key !== "name" && obj.hasOwnProperty(key)) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    } else if (isArray(obj) || isArrayLike(obj)) {
                        var isPrimitive = typeof obj !== "object";
                        for (key = 0, length = obj.length; key < length; key++) {
                            if (isPrimitive || key in obj) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    } else if (obj.forEach && obj.forEach !== forEach) {
                        obj.forEach(iterator, context, obj);
                    } else if (isBlankObject(obj)) {
                        for (key in obj) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    } else if (typeof obj.hasOwnProperty === "function") {
                        for (key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    } else {
                        for (key in obj) {
                            if (hasOwnProperty.call(obj, key)) {
                                iterator.call(context, obj[key], key, obj);
                            }
                        }
                    }
                }
                return obj;
            }
            function forEachSorted(obj, iterator, context) {
                var keys = Object.keys(obj).sort();
                for (var i = 0; i < keys.length; i++) {
                    iterator.call(context, obj[keys[i]], keys[i]);
                }
                return keys;
            }
            function reverseParams(iteratorFn) {
                return function(value, key) {
                    iteratorFn(key, value);
                };
            }
            function nextUid() {
                return ++uid;
            }
            function setHashKey(obj, h) {
                if (h) {
                    obj.$$hashKey = h;
                } else {
                    delete obj.$$hashKey;
                }
            }
            function baseExtend(dst, objs, deep) {
                var h = dst.$$hashKey;
                for (var i = 0, ii = objs.length; i < ii; ++i) {
                    var obj = objs[i];
                    if (!isObject(obj) && !isFunction(obj)) continue;
                    var keys = Object.keys(obj);
                    for (var j = 0, jj = keys.length; j < jj; j++) {
                        var key = keys[j];
                        var src = obj[key];
                        if (deep && isObject(src)) {
                            if (isDate(src)) {
                                dst[key] = new Date(src.valueOf());
                            } else if (isRegExp(src)) {
                                dst[key] = new RegExp(src);
                            } else if (src.nodeName) {
                                dst[key] = src.cloneNode(true);
                            } else if (isElement(src)) {
                                dst[key] = src.clone();
                            } else {
                                if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
                                baseExtend(dst[key], [ src ], true);
                            }
                        } else {
                            dst[key] = src;
                        }
                    }
                }
                setHashKey(dst, h);
                return dst;
            }
            function extend(dst) {
                return baseExtend(dst, slice.call(arguments, 1), false);
            }
            function merge(dst) {
                return baseExtend(dst, slice.call(arguments, 1), true);
            }
            function toInt(str) {
                return parseInt(str, 10);
            }
            var isNumberNaN = Number.isNaN || function isNumberNaN(num) {
                return num !== num;
            };
            function inherit(parent, extra) {
                return extend(Object.create(parent), extra);
            }
            function noop() {}
            noop.$inject = [];
            function identity($) {
                return $;
            }
            identity.$inject = [];
            function valueFn(value) {
                return function valueRef() {
                    return value;
                };
            }
            function hasCustomToString(obj) {
                return isFunction(obj.toString) && obj.toString !== toString;
            }
            function isUndefined(value) {
                return typeof value === "undefined";
            }
            function isDefined(value) {
                return typeof value !== "undefined";
            }
            function isObject(value) {
                return value !== null && typeof value === "object";
            }
            function isBlankObject(value) {
                return value !== null && typeof value === "object" && !getPrototypeOf(value);
            }
            function isString(value) {
                return typeof value === "string";
            }
            function isNumber(value) {
                return typeof value === "number";
            }
            function isDate(value) {
                return toString.call(value) === "[object Date]";
            }
            var isArray = Array.isArray;
            function isError(value) {
                var tag = toString.call(value);
                switch (tag) {
                  case "[object Error]":
                    return true;

                  case "[object Exception]":
                    return true;

                  case "[object DOMException]":
                    return true;

                  default:
                    return value instanceof Error;
                }
            }
            function isFunction(value) {
                return typeof value === "function";
            }
            function isRegExp(value) {
                return toString.call(value) === "[object RegExp]";
            }
            function isWindow(obj) {
                return obj && obj.window === obj;
            }
            function isScope(obj) {
                return obj && obj.$evalAsync && obj.$watch;
            }
            function isFile(obj) {
                return toString.call(obj) === "[object File]";
            }
            function isFormData(obj) {
                return toString.call(obj) === "[object FormData]";
            }
            function isBlob(obj) {
                return toString.call(obj) === "[object Blob]";
            }
            function isBoolean(value) {
                return typeof value === "boolean";
            }
            function isPromiseLike(obj) {
                return obj && isFunction(obj.then);
            }
            var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
            function isTypedArray(value) {
                return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
            }
            function isArrayBuffer(obj) {
                return toString.call(obj) === "[object ArrayBuffer]";
            }
            var trim = function(value) {
                return isString(value) ? value.trim() : value;
            };
            var escapeForRegexp = function(s) {
                return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
            };
            function isElement(node) {
                return !!(node && (node.nodeName || node.prop && node.attr && node.find));
            }
            function makeMap(str) {
                var obj = {}, items = str.split(","), i;
                for (i = 0; i < items.length; i++) {
                    obj[items[i]] = true;
                }
                return obj;
            }
            function nodeName_(element) {
                return lowercase(element.nodeName || element[0] && element[0].nodeName);
            }
            function includes(array, obj) {
                return Array.prototype.indexOf.call(array, obj) !== -1;
            }
            function arrayRemove(array, value) {
                var index = array.indexOf(value);
                if (index >= 0) {
                    array.splice(index, 1);
                }
                return index;
            }
            function copy(source, destination, maxDepth) {
                var stackSource = [];
                var stackDest = [];
                maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN;
                if (destination) {
                    if (isTypedArray(destination) || isArrayBuffer(destination)) {
                        throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                    }
                    if (source === destination) {
                        throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                    }
                    if (isArray(destination)) {
                        destination.length = 0;
                    } else {
                        forEach(destination, function(value, key) {
                            if (key !== "$$hashKey") {
                                delete destination[key];
                            }
                        });
                    }
                    stackSource.push(source);
                    stackDest.push(destination);
                    return copyRecurse(source, destination, maxDepth);
                }
                return copyElement(source, maxDepth);
                function copyRecurse(source, destination, maxDepth) {
                    maxDepth--;
                    if (maxDepth < 0) {
                        return "...";
                    }
                    var h = destination.$$hashKey;
                    var key;
                    if (isArray(source)) {
                        for (var i = 0, ii = source.length; i < ii; i++) {
                            destination.push(copyElement(source[i], maxDepth));
                        }
                    } else if (isBlankObject(source)) {
                        for (key in source) {
                            destination[key] = copyElement(source[key], maxDepth);
                        }
                    } else if (source && typeof source.hasOwnProperty === "function") {
                        for (key in source) {
                            if (source.hasOwnProperty(key)) {
                                destination[key] = copyElement(source[key], maxDepth);
                            }
                        }
                    } else {
                        for (key in source) {
                            if (hasOwnProperty.call(source, key)) {
                                destination[key] = copyElement(source[key], maxDepth);
                            }
                        }
                    }
                    setHashKey(destination, h);
                    return destination;
                }
                function copyElement(source, maxDepth) {
                    if (!isObject(source)) {
                        return source;
                    }
                    var index = stackSource.indexOf(source);
                    if (index !== -1) {
                        return stackDest[index];
                    }
                    if (isWindow(source) || isScope(source)) {
                        throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                    }
                    var needsRecurse = false;
                    var destination = copyType(source);
                    if (destination === undefined) {
                        destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
                        needsRecurse = true;
                    }
                    stackSource.push(source);
                    stackDest.push(destination);
                    return needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
                }
                function copyType(source) {
                    switch (toString.call(source)) {
                      case "[object Int8Array]":
                      case "[object Int16Array]":
                      case "[object Int32Array]":
                      case "[object Float32Array]":
                      case "[object Float64Array]":
                      case "[object Uint8Array]":
                      case "[object Uint8ClampedArray]":
                      case "[object Uint16Array]":
                      case "[object Uint32Array]":
                        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

                      case "[object ArrayBuffer]":
                        if (!source.slice) {
                            var copied = new ArrayBuffer(source.byteLength);
                            new Uint8Array(copied).set(new Uint8Array(source));
                            return copied;
                        }
                        return source.slice(0);

                      case "[object Boolean]":
                      case "[object Number]":
                      case "[object String]":
                      case "[object Date]":
                        return new source.constructor(source.valueOf());

                      case "[object RegExp]":
                        var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                        re.lastIndex = source.lastIndex;
                        return re;

                      case "[object Blob]":
                        return new source.constructor([ source ], {
                            type: source.type
                        });
                    }
                    if (isFunction(source.cloneNode)) {
                        return source.cloneNode(true);
                    }
                }
            }
            function simpleCompare(a, b) {
                return a === b || a !== a && b !== b;
            }
            function equals(o1, o2) {
                if (o1 === o2) return true;
                if (o1 === null || o2 === null) return false;
                if (o1 !== o1 && o2 !== o2) return true;
                var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
                if (t1 === t2 && t1 === "object") {
                    if (isArray(o1)) {
                        if (!isArray(o2)) return false;
                        if ((length = o1.length) === o2.length) {
                            for (key = 0; key < length; key++) {
                                if (!equals(o1[key], o2[key])) return false;
                            }
                            return true;
                        }
                    } else if (isDate(o1)) {
                        if (!isDate(o2)) return false;
                        return simpleCompare(o1.getTime(), o2.getTime());
                    } else if (isRegExp(o1)) {
                        if (!isRegExp(o2)) return false;
                        return o1.toString() === o2.toString();
                    } else {
                        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
                        keySet = createMap();
                        for (key in o1) {
                            if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
                            if (!equals(o1[key], o2[key])) return false;
                            keySet[key] = true;
                        }
                        for (key in o2) {
                            if (!(key in keySet) && key.charAt(0) !== "$" && isDefined(o2[key]) && !isFunction(o2[key])) return false;
                        }
                        return true;
                    }
                }
                return false;
            }
            var csp = function() {
                if (!isDefined(csp.rules)) {
                    var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                    if (ngCspElement) {
                        var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                        csp.rules = {
                            noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
                            noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1
                        };
                    } else {
                        csp.rules = {
                            noUnsafeEval: noUnsafeEval(),
                            noInlineStyle: false
                        };
                    }
                }
                return csp.rules;
                function noUnsafeEval() {
                    try {
                        new Function("");
                        return false;
                    } catch (e) {
                        return true;
                    }
                }
            };
            var jq = function() {
                if (isDefined(jq.name_)) return jq.name_;
                var el;
                var i, ii = ngAttrPrefixes.length, prefix, name;
                for (i = 0; i < ii; ++i) {
                    prefix = ngAttrPrefixes[i];
                    el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]");
                    if (el) {
                        name = el.getAttribute(prefix + "jq");
                        break;
                    }
                }
                return jq.name_ = name;
            };
            function concat(array1, array2, index) {
                return array1.concat(slice.call(array2, index));
            }
            function sliceArgs(args, startIndex) {
                return slice.call(args, startIndex || 0);
            }
            function bind(self, fn) {
                var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
                if (isFunction(fn) && !(fn instanceof RegExp)) {
                    return curryArgs.length ? function() {
                        return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                    } : function() {
                        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                    };
                } else {
                    return fn;
                }
            }
            function toJsonReplacer(key, value) {
                var val = value;
                if (typeof key === "string" && key.charAt(0) === "$" && key.charAt(1) === "$") {
                    val = undefined;
                } else if (isWindow(value)) {
                    val = "$WINDOW";
                } else if (value && window.document === value) {
                    val = "$DOCUMENT";
                } else if (isScope(value)) {
                    val = "$SCOPE";
                }
                return val;
            }
            function toJson(obj, pretty) {
                if (isUndefined(obj)) return undefined;
                if (!isNumber(pretty)) {
                    pretty = pretty ? 2 : null;
                }
                return JSON.stringify(obj, toJsonReplacer, pretty);
            }
            function fromJson(json) {
                return isString(json) ? JSON.parse(json) : json;
            }
            var ALL_COLONS = /:/g;
            function timezoneToOffset(timezone, fallback) {
                timezone = timezone.replace(ALL_COLONS, "");
                var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
                return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
            }
            function addDateMinutes(date, minutes) {
                date = new Date(date.getTime());
                date.setMinutes(date.getMinutes() + minutes);
                return date;
            }
            function convertTimezoneToLocal(date, timezone, reverse) {
                reverse = reverse ? -1 : 1;
                var dateTimezoneOffset = date.getTimezoneOffset();
                var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
            }
            function startingTag(element) {
                element = jqLite(element).clone().empty();
                var elemHtml = jqLite("<div>").append(element).html();
                try {
                    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                        return "<" + lowercase(nodeName);
                    });
                } catch (e) {
                    return lowercase(elemHtml);
                }
            }
            function tryDecodeURIComponent(value) {
                try {
                    return decodeURIComponent(value);
                } catch (e) {}
            }
            function parseKeyValue(keyValue) {
                var obj = {};
                forEach((keyValue || "").split("&"), function(keyValue) {
                    var splitPoint, key, val;
                    if (keyValue) {
                        key = keyValue = keyValue.replace(/\+/g, "%20");
                        splitPoint = keyValue.indexOf("=");
                        if (splitPoint !== -1) {
                            key = keyValue.substring(0, splitPoint);
                            val = keyValue.substring(splitPoint + 1);
                        }
                        key = tryDecodeURIComponent(key);
                        if (isDefined(key)) {
                            val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                            if (!hasOwnProperty.call(obj, key)) {
                                obj[key] = val;
                            } else if (isArray(obj[key])) {
                                obj[key].push(val);
                            } else {
                                obj[key] = [ obj[key], val ];
                            }
                        }
                    }
                });
                return obj;
            }
            function toKeyValue(obj) {
                var parts = [];
                forEach(obj, function(value, key) {
                    if (isArray(value)) {
                        forEach(value, function(arrayValue) {
                            parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)));
                        });
                    } else {
                        parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)));
                    }
                });
                return parts.length ? parts.join("&") : "";
            }
            function encodeUriSegment(val) {
                return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
            }
            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
            }
            var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
            function getNgAttribute(element, ngAttr) {
                var attr, i, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i) {
                    attr = ngAttrPrefixes[i] + ngAttr;
                    if (isString(attr = element.getAttribute(attr))) {
                        return attr;
                    }
                }
                return null;
            }
            function allowAutoBootstrap(document) {
                var script = document.currentScript;
                if (!script) {
                    return true;
                }
                if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) {
                    return false;
                }
                var attributes = script.attributes;
                var srcs = [ attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href") ];
                return srcs.every(function(src) {
                    if (!src) {
                        return true;
                    }
                    if (!src.value) {
                        return false;
                    }
                    var link = document.createElement("a");
                    link.href = src.value;
                    if (document.location.origin === link.origin) {
                        return true;
                    }
                    switch (link.protocol) {
                      case "http:":
                      case "https:":
                      case "ftp:":
                      case "blob:":
                      case "file:":
                      case "data:":
                        return true;

                      default:
                        return false;
                    }
                });
            }
            var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
            function angularInit(element, bootstrap) {
                var appElement, module, config = {};
                forEach(ngAttrPrefixes, function(prefix) {
                    var name = prefix + "app";
                    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                        appElement = element;
                        module = element.getAttribute(name);
                    }
                });
                forEach(ngAttrPrefixes, function(prefix) {
                    var name = prefix + "app";
                    var candidate;
                    if (!appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]"))) {
                        appElement = candidate;
                        module = candidate.getAttribute(name);
                    }
                });
                if (appElement) {
                    if (!isAutoBootstrapAllowed) {
                        window.console.error("Angular: disabling automatic bootstrap. <script> protocol indicates " + "an extension, document.location.href does not match.");
                        return;
                    }
                    config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
                    bootstrap(appElement, module ? [ module ] : [], config);
                }
            }
            function bootstrap(element, modules, config) {
                if (!isObject(config)) config = {};
                var defaultConfig = {
                    strictDi: false
                };
                config = extend(defaultConfig, config);
                var doBootstrap = function() {
                    element = jqLite(element);
                    if (element.injector()) {
                        var tag = element[0] === window.document ? "document" : startingTag(element);
                        throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
                    }
                    modules = modules || [];
                    modules.unshift([ "$provide", function($provide) {
                        $provide.value("$rootElement", element);
                    } ]);
                    if (config.debugInfoEnabled) {
                        modules.push([ "$compileProvider", function($compileProvider) {
                            $compileProvider.debugInfoEnabled(true);
                        } ]);
                    }
                    modules.unshift("ng");
                    var injector = createInjector(modules, config.strictDi);
                    injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function bootstrapApply(scope, element, compile, injector) {
                        scope.$apply(function() {
                            element.data("$injector", injector);
                            compile(element)(scope);
                        });
                    } ]);
                    return injector;
                };
                var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
                var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
                if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
                    config.debugInfoEnabled = true;
                    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "");
                }
                if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
                    return doBootstrap();
                }
                window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "");
                angular.resumeBootstrap = function(extraModules) {
                    forEach(extraModules, function(module) {
                        modules.push(module);
                    });
                    return doBootstrap();
                };
                if (isFunction(angular.resumeDeferredBootstrap)) {
                    angular.resumeDeferredBootstrap();
                }
            }
            function reloadWithDebugInfo() {
                window.name = "NG_ENABLE_DEBUG_INFO!" + window.name;
                window.location.reload();
            }
            function getTestability(rootElement) {
                var injector = angular.element(rootElement).injector();
                if (!injector) {
                    throw ngMinErr("test", "no injector found for element argument to getTestability");
                }
                return injector.get("$$testability");
            }
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            function snake_case(name, separator) {
                separator = separator || "_";
                return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                    return (pos ? separator : "") + letter.toLowerCase();
                });
            }
            var bindJQueryFired = false;
            function bindJQuery() {
                var originalCleanData;
                if (bindJQueryFired) {
                    return;
                }
                var jqName = jq();
                jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
                if (jQuery && jQuery.fn.on) {
                    jqLite = jQuery;
                    extend(jQuery.fn, {
                        scope: JQLitePrototype.scope,
                        isolateScope: JQLitePrototype.isolateScope,
                        controller: JQLitePrototype.controller,
                        injector: JQLitePrototype.injector,
                        inheritedData: JQLitePrototype.inheritedData
                    });
                    originalCleanData = jQuery.cleanData;
                    jQuery.cleanData = function(elems) {
                        var events;
                        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                            events = jQuery._data(elem, "events");
                            if (events && events.$destroy) {
                                jQuery(elem).triggerHandler("$destroy");
                            }
                        }
                        originalCleanData(elems);
                    };
                } else {
                    jqLite = JQLite;
                }
                angular.element = jqLite;
                bindJQueryFired = true;
            }
            function assertArg(arg, name, reason) {
                if (!arg) {
                    throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
                }
                return arg;
            }
            function assertArgFn(arg, name, acceptArrayAnnotation) {
                if (acceptArrayAnnotation && isArray(arg)) {
                    arg = arg[arg.length - 1];
                }
                assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg));
                return arg;
            }
            function assertNotHasOwnProperty(name, context) {
                if (name === "hasOwnProperty") {
                    throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                }
            }
            function getter(obj, path, bindFnToScope) {
                if (!path) return obj;
                var keys = path.split(".");
                var key;
                var lastInstance = obj;
                var len = keys.length;
                for (var i = 0; i < len; i++) {
                    key = keys[i];
                    if (obj) {
                        obj = (lastInstance = obj)[key];
                    }
                }
                if (!bindFnToScope && isFunction(obj)) {
                    return bind(lastInstance, obj);
                }
                return obj;
            }
            function getBlockNodes(nodes) {
                var node = nodes[0];
                var endNode = nodes[nodes.length - 1];
                var blockNodes;
                for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
                    if (blockNodes || nodes[i] !== node) {
                        if (!blockNodes) {
                            blockNodes = jqLite(slice.call(nodes, 0, i));
                        }
                        blockNodes.push(node);
                    }
                }
                return blockNodes || nodes;
            }
            function createMap() {
                return Object.create(null);
            }
            function stringify(value) {
                if (value == null) {
                    return "";
                }
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
                        value = value.toString();
                    } else {
                        value = toJson(value);
                    }
                }
                return value;
            }
            var NODE_TYPE_ELEMENT = 1;
            var NODE_TYPE_ATTRIBUTE = 2;
            var NODE_TYPE_TEXT = 3;
            var NODE_TYPE_COMMENT = 8;
            var NODE_TYPE_DOCUMENT = 9;
            var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
            function setupModuleLoader(window) {
                var $injectorMinErr = minErr("$injector");
                var ngMinErr = minErr("ng");
                function ensure(obj, name, factory) {
                    return obj[name] || (obj[name] = factory());
                }
                var angular = ensure(window, "angular", Object);
                angular.$$minErr = angular.$$minErr || minErr;
                return ensure(angular, "module", function() {
                    var modules = {};
                    return function module(name, requires, configFn) {
                        var info = {};
                        var assertNotHasOwnProperty = function(name, context) {
                            if (name === "hasOwnProperty") {
                                throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                            }
                        };
                        assertNotHasOwnProperty(name, "module");
                        if (requires && modules.hasOwnProperty(name)) {
                            modules[name] = null;
                        }
                        return ensure(modules, name, function() {
                            if (!requires) {
                                throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
                            }
                            var invokeQueue = [];
                            var configBlocks = [];
                            var runBlocks = [];
                            var config = invokeLater("$injector", "invoke", "push", configBlocks);
                            var moduleInstance = {
                                _invokeQueue: invokeQueue,
                                _configBlocks: configBlocks,
                                _runBlocks: runBlocks,
                                info: function(value) {
                                    if (isDefined(value)) {
                                        if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                        info = value;
                                        return this;
                                    }
                                    return info;
                                },
                                requires: requires,
                                name: name,
                                provider: invokeLaterAndSetModuleName("$provide", "provider"),
                                factory: invokeLaterAndSetModuleName("$provide", "factory"),
                                service: invokeLaterAndSetModuleName("$provide", "service"),
                                value: invokeLater("$provide", "value"),
                                constant: invokeLater("$provide", "constant", "unshift"),
                                decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                                animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                                filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                                controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                                directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                                component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                                config: config,
                                run: function(block) {
                                    runBlocks.push(block);
                                    return this;
                                }
                            };
                            if (configFn) {
                                config(configFn);
                            }
                            return moduleInstance;
                            function invokeLater(provider, method, insertMethod, queue) {
                                if (!queue) queue = invokeQueue;
                                return function() {
                                    queue[insertMethod || "push"]([ provider, method, arguments ]);
                                    return moduleInstance;
                                };
                            }
                            function invokeLaterAndSetModuleName(provider, method, queue) {
                                if (!queue) queue = invokeQueue;
                                return function(recipeName, factoryFunction) {
                                    if (factoryFunction && isFunction(factoryFunction)) factoryFunction.$$moduleName = name;
                                    queue.push([ provider, method, arguments ]);
                                    return moduleInstance;
                                };
                            }
                        });
                    };
                });
            }
            function shallowCopy(src, dst) {
                if (isArray(src)) {
                    dst = dst || [];
                    for (var i = 0, ii = src.length; i < ii; i++) {
                        dst[i] = src[i];
                    }
                } else if (isObject(src)) {
                    dst = dst || {};
                    for (var key in src) {
                        if (!(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                            dst[key] = src[key];
                        }
                    }
                }
                return dst || src;
            }
            function serializeObject(obj, maxDepth) {
                var seen = [];
                if (isValidObjectMaxDepth(maxDepth)) {
                    obj = angular.copy(obj, null, maxDepth);
                }
                return JSON.stringify(obj, function(key, val) {
                    val = toJsonReplacer(key, val);
                    if (isObject(val)) {
                        if (seen.indexOf(val) >= 0) return "...";
                        seen.push(val);
                    }
                    return val;
                });
            }
            function toDebugString(obj, maxDepth) {
                if (typeof obj === "function") {
                    return obj.toString().replace(/ \{[\s\S]*$/, "");
                } else if (isUndefined(obj)) {
                    return "undefined";
                } else if (typeof obj !== "string") {
                    return serializeObject(obj, maxDepth);
                }
                return obj;
            }
            var version = {
                full: "1.6.8",
                major: 1,
                minor: 6,
                dot: 8,
                codeName: "beneficial-tincture"
            };
            function publishExternalAPI(angular) {
                extend(angular, {
                    errorHandlingConfig: errorHandlingConfig,
                    bootstrap: bootstrap,
                    copy: copy,
                    extend: extend,
                    merge: merge,
                    equals: equals,
                    element: jqLite,
                    forEach: forEach,
                    injector: createInjector,
                    noop: noop,
                    bind: bind,
                    toJson: toJson,
                    fromJson: fromJson,
                    identity: identity,
                    isUndefined: isUndefined,
                    isDefined: isDefined,
                    isString: isString,
                    isFunction: isFunction,
                    isObject: isObject,
                    isNumber: isNumber,
                    isElement: isElement,
                    isArray: isArray,
                    version: version,
                    isDate: isDate,
                    lowercase: lowercase,
                    uppercase: uppercase,
                    callbacks: {
                        $$counter: 0
                    },
                    getTestability: getTestability,
                    reloadWithDebugInfo: reloadWithDebugInfo,
                    $$minErr: minErr,
                    $$csp: csp,
                    $$encodeUriSegment: encodeUriSegment,
                    $$encodeUriQuery: encodeUriQuery,
                    $$stringify: stringify
                });
                angularModule = setupModuleLoader(window);
                angularModule("ng", [ "ngLocale" ], [ "$provide", function ngModule($provide) {
                    $provide.provider({
                        $$sanitizeUri: $$SanitizeUriProvider
                    });
                    $provide.provider("$compile", $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        pattern: patternDirective,
                        ngPattern: patternDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        minlength: minlengthDirective,
                        ngMinlength: minlengthDirective,
                        maxlength: maxlengthDirective,
                        ngMaxlength: maxlengthDirective,
                        ngValue: ngValueDirective,
                        ngModelOptions: ngModelOptionsDirective
                    }).directive({
                        ngInclude: ngIncludeFillContentDirective
                    }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
                    $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $animateCss: $CoreAnimateCssProvider,
                        $$animateJs: $$CoreAnimateJsProvider,
                        $$animateQueue: $$CoreAnimateQueueProvider,
                        $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                        $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $$isDocumentHidden: $$IsDocumentHiddenProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $$forceReflow: $$ForceReflowProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $http: $HttpProvider,
                        $httpParamSerializer: $HttpParamSerializerProvider,
                        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                        $httpBackend: $HttpBackendProvider,
                        $xhrFactory: $xhrFactoryProvider,
                        $jsonpCallbacks: $jsonpCallbacksProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $$q: $$QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $templateCache: $TemplateCacheProvider,
                        $templateRequest: $TemplateRequestProvider,
                        $$testability: $$TestabilityProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider,
                        $$rAF: $$RAFProvider,
                        $$jqLite: $$jqLiteProvider,
                        $$Map: $$MapProvider,
                        $$cookieReader: $$CookieReaderProvider
                    });
                } ]).info({
                    angularVersion: "1.6.8"
                });
            }
            JQLite.expando = "ng339";
            var jqCache = JQLite.cache = {}, jqId = 1;
            JQLite._data = function(node) {
                return this.cache[node[this.expando]] || {};
            };
            function jqNextId() {
                return ++jqId;
            }
            var DASH_LOWERCASE_REGEXP = /-([a-z])/g;
            var MS_HACK_REGEXP = /^-ms-/;
            var MOUSE_EVENT_MAP = {
                mouseleave: "mouseout",
                mouseenter: "mouseover"
            };
            var jqLiteMinErr = minErr("jqLite");
            function cssKebabToCamel(name) {
                return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
            }
            function fnCamelCaseReplace(all, letter) {
                return letter.toUpperCase();
            }
            function kebabToCamel(name) {
                return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
            }
            var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
            var HTML_REGEXP = /<|&#?\w+;/;
            var TAG_NAME_REGEXP = /<([\w:-]+)/;
            var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
            var wrapMap = {
                option: [ 1, '<select multiple="multiple">', "</select>" ],
                thead: [ 1, "<table>", "</table>" ],
                col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
                _default: [ 0, "", "" ]
            };
            wrapMap.optgroup = wrapMap.option;
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;
            function jqLiteIsTextNode(html) {
                return !HTML_REGEXP.test(html);
            }
            function jqLiteAcceptsData(node) {
                var nodeType = node.nodeType;
                return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
            }
            function jqLiteHasData(node) {
                for (var key in jqCache[node.ng339]) {
                    return true;
                }
                return false;
            }
            function jqLiteBuildFragment(html, context) {
                var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
                if (jqLiteIsTextNode(html)) {
                    nodes.push(context.createTextNode(html));
                } else {
                    tmp = fragment.appendChild(context.createElement("div"));
                    tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
                    i = wrap[0];
                    while (i--) {
                        tmp = tmp.lastChild;
                    }
                    nodes = concat(nodes, tmp.childNodes);
                    tmp = fragment.firstChild;
                    tmp.textContent = "";
                }
                fragment.textContent = "";
                fragment.innerHTML = "";
                forEach(nodes, function(node) {
                    fragment.appendChild(node);
                });
                return fragment;
            }
            function jqLiteParseHTML(html, context) {
                context = context || window.document;
                var parsed;
                if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
                    return [ context.createElement(parsed[1]) ];
                }
                if (parsed = jqLiteBuildFragment(html, context)) {
                    return parsed.childNodes;
                }
                return [];
            }
            function jqLiteWrapNode(node, wrapper) {
                var parent = node.parentNode;
                if (parent) {
                    parent.replaceChild(wrapper, node);
                }
                wrapper.appendChild(node);
            }
            var jqLiteContains = window.Node.prototype.contains || function(arg) {
                return !!(this.compareDocumentPosition(arg) & 16);
            };
            function JQLite(element) {
                if (element instanceof JQLite) {
                    return element;
                }
                var argIsString;
                if (isString(element)) {
                    element = trim(element);
                    argIsString = true;
                }
                if (!(this instanceof JQLite)) {
                    if (argIsString && element.charAt(0) !== "<") {
                        throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                    }
                    return new JQLite(element);
                }
                if (argIsString) {
                    jqLiteAddNodes(this, jqLiteParseHTML(element));
                } else if (isFunction(element)) {
                    jqLiteReady(element);
                } else {
                    jqLiteAddNodes(this, element);
                }
            }
            function jqLiteClone(element) {
                return element.cloneNode(true);
            }
            function jqLiteDealoc(element, onlyDescendants) {
                if (!onlyDescendants && jqLiteAcceptsData(element)) jqLite.cleanData([ element ]);
                if (element.querySelectorAll) {
                    jqLite.cleanData(element.querySelectorAll("*"));
                }
            }
            function jqLiteOff(element, type, fn, unsupported) {
                if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
                var expandoStore = jqLiteExpandoStore(element);
                var events = expandoStore && expandoStore.events;
                var handle = expandoStore && expandoStore.handle;
                if (!handle) return;
                if (!type) {
                    for (type in events) {
                        if (type !== "$destroy") {
                            element.removeEventListener(type, handle);
                        }
                        delete events[type];
                    }
                } else {
                    var removeHandler = function(type) {
                        var listenerFns = events[type];
                        if (isDefined(fn)) {
                            arrayRemove(listenerFns || [], fn);
                        }
                        if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                            element.removeEventListener(type, handle);
                            delete events[type];
                        }
                    };
                    forEach(type.split(" "), function(type) {
                        removeHandler(type);
                        if (MOUSE_EVENT_MAP[type]) {
                            removeHandler(MOUSE_EVENT_MAP[type]);
                        }
                    });
                }
            }
            function jqLiteRemoveData(element, name) {
                var expandoId = element.ng339;
                var expandoStore = expandoId && jqCache[expandoId];
                if (expandoStore) {
                    if (name) {
                        delete expandoStore.data[name];
                        return;
                    }
                    if (expandoStore.handle) {
                        if (expandoStore.events.$destroy) {
                            expandoStore.handle({}, "$destroy");
                        }
                        jqLiteOff(element);
                    }
                    delete jqCache[expandoId];
                    element.ng339 = undefined;
                }
            }
            function jqLiteExpandoStore(element, createIfNecessary) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
                if (createIfNecessary && !expandoStore) {
                    element.ng339 = expandoId = jqNextId();
                    expandoStore = jqCache[expandoId] = {
                        events: {},
                        data: {},
                        handle: undefined
                    };
                }
                return expandoStore;
            }
            function jqLiteData(element, key, value) {
                if (jqLiteAcceptsData(element)) {
                    var prop;
                    var isSimpleSetter = isDefined(value);
                    var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
                    var massGetter = !key;
                    var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
                    var data = expandoStore && expandoStore.data;
                    if (isSimpleSetter) {
                        data[kebabToCamel(key)] = value;
                    } else {
                        if (massGetter) {
                            return data;
                        } else {
                            if (isSimpleGetter) {
                                return data && data[kebabToCamel(key)];
                            } else {
                                for (prop in key) {
                                    data[kebabToCamel(prop)] = key[prop];
                                }
                            }
                        }
                    }
                }
            }
            function jqLiteHasClass(element, selector) {
                if (!element.getAttribute) return false;
                return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
            }
            function jqLiteRemoveClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
                    var newClasses = existingClasses;
                    forEach(cssClasses.split(" "), function(cssClass) {
                        cssClass = trim(cssClass);
                        newClasses = newClasses.replace(" " + cssClass + " ", " ");
                    });
                    if (newClasses !== existingClasses) {
                        element.setAttribute("class", trim(newClasses));
                    }
                }
            }
            function jqLiteAddClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
                    var newClasses = existingClasses;
                    forEach(cssClasses.split(" "), function(cssClass) {
                        cssClass = trim(cssClass);
                        if (newClasses.indexOf(" " + cssClass + " ") === -1) {
                            newClasses += cssClass + " ";
                        }
                    });
                    if (newClasses !== existingClasses) {
                        element.setAttribute("class", trim(newClasses));
                    }
                }
            }
            function jqLiteAddNodes(root, elements) {
                if (elements) {
                    if (elements.nodeType) {
                        root[root.length++] = elements;
                    } else {
                        var length = elements.length;
                        if (typeof length === "number" && elements.window !== elements) {
                            if (length) {
                                for (var i = 0; i < length; i++) {
                                    root[root.length++] = elements[i];
                                }
                            }
                        } else {
                            root[root.length++] = elements;
                        }
                    }
                }
            }
            function jqLiteController(element, name) {
                return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
            }
            function jqLiteInheritedData(element, name, value) {
                if (element.nodeType === NODE_TYPE_DOCUMENT) {
                    element = element.documentElement;
                }
                var names = isArray(name) ? name : [ name ];
                while (element) {
                    for (var i = 0, ii = names.length; i < ii; i++) {
                        if (isDefined(value = jqLite.data(element, names[i]))) return value;
                    }
                    element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
                }
            }
            function jqLiteEmpty(element) {
                jqLiteDealoc(element, true);
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }
            }
            function jqLiteRemove(element, keepData) {
                if (!keepData) jqLiteDealoc(element);
                var parent = element.parentNode;
                if (parent) parent.removeChild(element);
            }
            function jqLiteDocumentLoaded(action, win) {
                win = win || window;
                if (win.document.readyState === "complete") {
                    win.setTimeout(action);
                } else {
                    jqLite(win).on("load", action);
                }
            }
            function jqLiteReady(fn) {
                function trigger() {
                    window.document.removeEventListener("DOMContentLoaded", trigger);
                    window.removeEventListener("load", trigger);
                    fn();
                }
                if (window.document.readyState === "complete") {
                    window.setTimeout(fn);
                } else {
                    window.document.addEventListener("DOMContentLoaded", trigger);
                    window.addEventListener("load", trigger);
                }
            }
            var JQLitePrototype = JQLite.prototype = {
                ready: jqLiteReady,
                toString: function() {
                    var value = [];
                    forEach(this, function(e) {
                        value.push("" + e);
                    });
                    return "[" + value.join(", ") + "]";
                },
                eq: function(index) {
                    return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
                },
                length: 0,
                push: push,
                sort: [].sort,
                splice: [].splice
            };
            var BOOLEAN_ATTR = {};
            forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
                BOOLEAN_ATTR[lowercase(value)] = value;
            });
            var BOOLEAN_ELEMENTS = {};
            forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
                BOOLEAN_ELEMENTS[value] = true;
            });
            var ALIASED_ATTR = {
                ngMinlength: "minlength",
                ngMaxlength: "maxlength",
                ngMin: "min",
                ngMax: "max",
                ngPattern: "pattern",
                ngStep: "step"
            };
            function getBooleanAttrName(element, name) {
                var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
                return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
            }
            function getAliasedAttrName(name) {
                return ALIASED_ATTR[name];
            }
            forEach({
                data: jqLiteData,
                removeData: jqLiteRemoveData,
                hasData: jqLiteHasData,
                cleanData: function jqLiteCleanData(nodes) {
                    for (var i = 0, ii = nodes.length; i < ii; i++) {
                        jqLiteRemoveData(nodes[i]);
                    }
                }
            }, function(fn, name) {
                JQLite[name] = fn;
            });
            forEach({
                data: jqLiteData,
                inheritedData: jqLiteInheritedData,
                scope: function(element) {
                    return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
                },
                isolateScope: function(element) {
                    return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
                },
                controller: jqLiteController,
                injector: function(element) {
                    return jqLiteInheritedData(element, "$injector");
                },
                removeAttr: function(element, name) {
                    element.removeAttribute(name);
                },
                hasClass: jqLiteHasClass,
                css: function(element, name, value) {
                    name = cssKebabToCamel(name);
                    if (isDefined(value)) {
                        element.style[name] = value;
                    } else {
                        return element.style[name];
                    }
                },
                attr: function(element, name, value) {
                    var ret;
                    var nodeType = element.nodeType;
                    if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT || !element.getAttribute) {
                        return;
                    }
                    var lowercasedName = lowercase(name);
                    var isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                    if (isDefined(value)) {
                        if (value === null || value === false && isBooleanAttr) {
                            element.removeAttribute(name);
                        } else {
                            element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
                        }
                    } else {
                        ret = element.getAttribute(name);
                        if (isBooleanAttr && ret !== null) {
                            ret = lowercasedName;
                        }
                        return ret === null ? undefined : ret;
                    }
                },
                prop: function(element, name, value) {
                    if (isDefined(value)) {
                        element[name] = value;
                    } else {
                        return element[name];
                    }
                },
                text: function() {
                    getText.$dv = "";
                    return getText;
                    function getText(element, value) {
                        if (isUndefined(value)) {
                            var nodeType = element.nodeType;
                            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                        }
                        element.textContent = value;
                    }
                }(),
                val: function(element, value) {
                    if (isUndefined(value)) {
                        if (element.multiple && nodeName_(element) === "select") {
                            var result = [];
                            forEach(element.options, function(option) {
                                if (option.selected) {
                                    result.push(option.value || option.text);
                                }
                            });
                            return result;
                        }
                        return element.value;
                    }
                    element.value = value;
                },
                html: function(element, value) {
                    if (isUndefined(value)) {
                        return element.innerHTML;
                    }
                    jqLiteDealoc(element, true);
                    element.innerHTML = value;
                },
                empty: jqLiteEmpty
            }, function(fn, name) {
                JQLite.prototype[name] = function(arg1, arg2) {
                    var i, key;
                    var nodeCount = this.length;
                    if (fn !== jqLiteEmpty && isUndefined(fn.length === 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
                        if (isObject(arg1)) {
                            for (i = 0; i < nodeCount; i++) {
                                if (fn === jqLiteData) {
                                    fn(this[i], arg1);
                                } else {
                                    for (key in arg1) {
                                        fn(this[i], key, arg1[key]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            var value = fn.$dv;
                            var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                            for (var j = 0; j < jj; j++) {
                                var nodeValue = fn(this[j], arg1, arg2);
                                value = value ? value + nodeValue : nodeValue;
                            }
                            return value;
                        }
                    } else {
                        for (i = 0; i < nodeCount; i++) {
                            fn(this[i], arg1, arg2);
                        }
                        return this;
                    }
                };
            });
            function createEventHandler(element, events) {
                var eventHandler = function(event, type) {
                    event.isDefaultPrevented = function() {
                        return event.defaultPrevented;
                    };
                    var eventFns = events[type || event.type];
                    var eventFnsLength = eventFns ? eventFns.length : 0;
                    if (!eventFnsLength) return;
                    if (isUndefined(event.immediatePropagationStopped)) {
                        var originalStopImmediatePropagation = event.stopImmediatePropagation;
                        event.stopImmediatePropagation = function() {
                            event.immediatePropagationStopped = true;
                            if (event.stopPropagation) {
                                event.stopPropagation();
                            }
                            if (originalStopImmediatePropagation) {
                                originalStopImmediatePropagation.call(event);
                            }
                        };
                    }
                    event.isImmediatePropagationStopped = function() {
                        return event.immediatePropagationStopped === true;
                    };
                    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                    if (eventFnsLength > 1) {
                        eventFns = shallowCopy(eventFns);
                    }
                    for (var i = 0; i < eventFnsLength; i++) {
                        if (!event.isImmediatePropagationStopped()) {
                            handlerWrapper(element, event, eventFns[i]);
                        }
                    }
                };
                eventHandler.elem = element;
                return eventHandler;
            }
            function defaultHandlerWrapper(element, event, handler) {
                handler.call(element, event);
            }
            function specialMouseHandlerWrapper(target, event, handler) {
                var related = event.relatedTarget;
                if (!related || related !== target && !jqLiteContains.call(target, related)) {
                    handler.call(target, event);
                }
            }
            forEach({
                removeData: jqLiteRemoveData,
                on: function jqLiteOn(element, type, fn, unsupported) {
                    if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                    if (!jqLiteAcceptsData(element)) {
                        return;
                    }
                    var expandoStore = jqLiteExpandoStore(element, true);
                    var events = expandoStore.events;
                    var handle = expandoStore.handle;
                    if (!handle) {
                        handle = expandoStore.handle = createEventHandler(element, events);
                    }
                    var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ];
                    var i = types.length;
                    var addHandler = function(type, specialHandlerWrapper, noEventListener) {
                        var eventFns = events[type];
                        if (!eventFns) {
                            eventFns = events[type] = [];
                            eventFns.specialHandlerWrapper = specialHandlerWrapper;
                            if (type !== "$destroy" && !noEventListener) {
                                element.addEventListener(type, handle);
                            }
                        }
                        eventFns.push(fn);
                    };
                    while (i--) {
                        type = types[i];
                        if (MOUSE_EVENT_MAP[type]) {
                            addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                            addHandler(type, undefined, true);
                        } else {
                            addHandler(type);
                        }
                    }
                },
                off: jqLiteOff,
                one: function(element, type, fn) {
                    element = jqLite(element);
                    element.on(type, function onFn() {
                        element.off(type, fn);
                        element.off(type, onFn);
                    });
                    element.on(type, fn);
                },
                replaceWith: function(element, replaceNode) {
                    var index, parent = element.parentNode;
                    jqLiteDealoc(element);
                    forEach(new JQLite(replaceNode), function(node) {
                        if (index) {
                            parent.insertBefore(node, index.nextSibling);
                        } else {
                            parent.replaceChild(node, element);
                        }
                        index = node;
                    });
                },
                children: function(element) {
                    var children = [];
                    forEach(element.childNodes, function(element) {
                        if (element.nodeType === NODE_TYPE_ELEMENT) {
                            children.push(element);
                        }
                    });
                    return children;
                },
                contents: function(element) {
                    return element.contentDocument || element.childNodes || [];
                },
                append: function(element, node) {
                    var nodeType = element.nodeType;
                    if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT) return;
                    node = new JQLite(node);
                    for (var i = 0, ii = node.length; i < ii; i++) {
                        var child = node[i];
                        element.appendChild(child);
                    }
                },
                prepend: function(element, node) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        var index = element.firstChild;
                        forEach(new JQLite(node), function(child) {
                            element.insertBefore(child, index);
                        });
                    }
                },
                wrap: function(element, wrapNode) {
                    jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
                },
                remove: jqLiteRemove,
                detach: function(element) {
                    jqLiteRemove(element, true);
                },
                after: function(element, newElement) {
                    var index = element, parent = element.parentNode;
                    if (parent) {
                        newElement = new JQLite(newElement);
                        for (var i = 0, ii = newElement.length; i < ii; i++) {
                            var node = newElement[i];
                            parent.insertBefore(node, index.nextSibling);
                            index = node;
                        }
                    }
                },
                addClass: jqLiteAddClass,
                removeClass: jqLiteRemoveClass,
                toggleClass: function(element, selector, condition) {
                    if (selector) {
                        forEach(selector.split(" "), function(className) {
                            var classCondition = condition;
                            if (isUndefined(classCondition)) {
                                classCondition = !jqLiteHasClass(element, className);
                            }
                            (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                        });
                    }
                },
                parent: function(element) {
                    var parent = element.parentNode;
                    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
                },
                next: function(element) {
                    return element.nextElementSibling;
                },
                find: function(element, selector) {
                    if (element.getElementsByTagName) {
                        return element.getElementsByTagName(selector);
                    } else {
                        return [];
                    }
                },
                clone: jqLiteClone,
                triggerHandler: function(element, event, extraParameters) {
                    var dummyEvent, eventFnsCopy, handlerArgs;
                    var eventName = event.type || event;
                    var expandoStore = jqLiteExpandoStore(element);
                    var events = expandoStore && expandoStore.events;
                    var eventFns = events && events[eventName];
                    if (eventFns) {
                        dummyEvent = {
                            preventDefault: function() {
                                this.defaultPrevented = true;
                            },
                            isDefaultPrevented: function() {
                                return this.defaultPrevented === true;
                            },
                            stopImmediatePropagation: function() {
                                this.immediatePropagationStopped = true;
                            },
                            isImmediatePropagationStopped: function() {
                                return this.immediatePropagationStopped === true;
                            },
                            stopPropagation: noop,
                            type: eventName,
                            target: element
                        };
                        if (event.type) {
                            dummyEvent = extend(dummyEvent, event);
                        }
                        eventFnsCopy = shallowCopy(eventFns);
                        handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ];
                        forEach(eventFnsCopy, function(fn) {
                            if (!dummyEvent.isImmediatePropagationStopped()) {
                                fn.apply(element, handlerArgs);
                            }
                        });
                    }
                }
            }, function(fn, name) {
                JQLite.prototype[name] = function(arg1, arg2, arg3) {
                    var value;
                    for (var i = 0, ii = this.length; i < ii; i++) {
                        if (isUndefined(value)) {
                            value = fn(this[i], arg1, arg2, arg3);
                            if (isDefined(value)) {
                                value = jqLite(value);
                            }
                        } else {
                            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                        }
                    }
                    return isDefined(value) ? value : this;
                };
            });
            JQLite.prototype.bind = JQLite.prototype.on;
            JQLite.prototype.unbind = JQLite.prototype.off;
            function $$jqLiteProvider() {
                this.$get = function $$jqLite() {
                    return extend(JQLite, {
                        hasClass: function(node, classes) {
                            if (node.attr) node = node[0];
                            return jqLiteHasClass(node, classes);
                        },
                        addClass: function(node, classes) {
                            if (node.attr) node = node[0];
                            return jqLiteAddClass(node, classes);
                        },
                        removeClass: function(node, classes) {
                            if (node.attr) node = node[0];
                            return jqLiteRemoveClass(node, classes);
                        }
                    });
                };
            }
            function hashKey(obj, nextUidFn) {
                var key = obj && obj.$$hashKey;
                if (key) {
                    if (typeof key === "function") {
                        key = obj.$$hashKey();
                    }
                    return key;
                }
                var objType = typeof obj;
                if (objType === "function" || objType === "object" && obj !== null) {
                    key = obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)();
                } else {
                    key = objType + ":" + obj;
                }
                return key;
            }
            var nanKey = Object.create(null);
            function NgMapShim() {
                this._keys = [];
                this._values = [];
                this._lastKey = NaN;
                this._lastIndex = -1;
            }
            NgMapShim.prototype = {
                _idx: function(key) {
                    if (key === this._lastKey) {
                        return this._lastIndex;
                    }
                    this._lastKey = key;
                    this._lastIndex = this._keys.indexOf(key);
                    return this._lastIndex;
                },
                _transformKey: function(key) {
                    return isNumberNaN(key) ? nanKey : key;
                },
                get: function(key) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    if (idx !== -1) {
                        return this._values[idx];
                    }
                },
                set: function(key, value) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    if (idx === -1) {
                        idx = this._lastIndex = this._keys.length;
                    }
                    this._keys[idx] = key;
                    this._values[idx] = value;
                },
                delete: function(key) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    if (idx === -1) {
                        return false;
                    }
                    this._keys.splice(idx, 1);
                    this._values.splice(idx, 1);
                    this._lastKey = NaN;
                    this._lastIndex = -1;
                    return true;
                }
            };
            var NgMap = NgMapShim;
            var $$MapProvider = [ function() {
                this.$get = [ function() {
                    return NgMap;
                } ];
            } ];
            var ARROW_ARG = /^([^(]+?)=>/;
            var FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;
            var FN_ARG_SPLIT = /,/;
            var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
            var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
            var $injectorMinErr = minErr("$injector");
            function stringifyFn(fn) {
                return Function.prototype.toString.call(fn);
            }
            function extractArgs(fn) {
                var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
                return args;
            }
            function anonFn(fn) {
                var args = extractArgs(fn);
                if (args) {
                    return "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")";
                }
                return "fn";
            }
            function annotate(fn, strictDi, name) {
                var $inject, argDecl, last;
                if (typeof fn === "function") {
                    if (!($inject = fn.$inject)) {
                        $inject = [];
                        if (fn.length) {
                            if (strictDi) {
                                if (!isString(name) || !name) {
                                    name = fn.name || anonFn(fn);
                                }
                                throw $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                            }
                            argDecl = extractArgs(fn);
                            forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                                arg.replace(FN_ARG, function(all, underscore, name) {
                                    $inject.push(name);
                                });
                            });
                        }
                        fn.$inject = $inject;
                    }
                } else if (isArray(fn)) {
                    last = fn.length - 1;
                    assertArgFn(fn[last], "fn");
                    $inject = fn.slice(0, last);
                } else {
                    assertArgFn(fn, "fn", true);
                }
                return $inject;
            }
            function createInjector(modulesToLoad, strictDi) {
                strictDi = strictDi === true;
                var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject(service),
                        value: supportObject(value),
                        constant: supportObject(constant),
                        decorator: decorator
                    }
                }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
                    if (angular.isString(caller)) {
                        path.push(caller);
                    }
                    throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
                }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
                }), instanceInjector = protoInstanceInjector;
                providerCache["$injector" + providerSuffix] = {
                    $get: valueFn(protoInstanceInjector)
                };
                instanceInjector.modules = providerInjector.modules = createMap();
                var runBlocks = loadModules(modulesToLoad);
                instanceInjector = protoInstanceInjector.get("$injector");
                instanceInjector.strictDi = strictDi;
                forEach(runBlocks, function(fn) {
                    if (fn) instanceInjector.invoke(fn);
                });
                instanceInjector.loadNewModules = function(mods) {
                    forEach(loadModules(mods), function(fn) {
                        if (fn) instanceInjector.invoke(fn);
                    });
                };
                return instanceInjector;
                function supportObject(delegate) {
                    return function(key, value) {
                        if (isObject(key)) {
                            forEach(key, reverseParams(delegate));
                        } else {
                            return delegate(key, value);
                        }
                    };
                }
                function provider(name, provider_) {
                    assertNotHasOwnProperty(name, "service");
                    if (isFunction(provider_) || isArray(provider_)) {
                        provider_ = providerInjector.instantiate(provider_);
                    }
                    if (!provider_.$get) {
                        throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                    }
                    return providerCache[name + providerSuffix] = provider_;
                }
                function enforceReturnValue(name, factory) {
                    return function enforcedReturnValue() {
                        var result = instanceInjector.invoke(factory, this);
                        if (isUndefined(result)) {
                            throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                        }
                        return result;
                    };
                }
                function factory(name, factoryFn, enforce) {
                    return provider(name, {
                        $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn
                    });
                }
                function service(name, constructor) {
                    return factory(name, [ "$injector", function($injector) {
                        return $injector.instantiate(constructor);
                    } ]);
                }
                function value(name, val) {
                    return factory(name, valueFn(val), false);
                }
                function constant(name, value) {
                    assertNotHasOwnProperty(name, "constant");
                    providerCache[name] = value;
                    instanceCache[name] = value;
                }
                function decorator(serviceName, decorFn) {
                    var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                    origProvider.$get = function() {
                        var origInstance = instanceInjector.invoke(orig$get, origProvider);
                        return instanceInjector.invoke(decorFn, null, {
                            $delegate: origInstance
                        });
                    };
                }
                function loadModules(modulesToLoad) {
                    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                    var runBlocks = [], moduleFn;
                    forEach(modulesToLoad, function(module) {
                        if (loadedModules.get(module)) return;
                        loadedModules.set(module, true);
                        function runInvokeQueue(queue) {
                            var i, ii;
                            for (i = 0, ii = queue.length; i < ii; i++) {
                                var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                            }
                        }
                        try {
                            if (isString(module)) {
                                moduleFn = angularModule(module);
                                instanceInjector.modules[module] = moduleFn;
                                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                                runInvokeQueue(moduleFn._invokeQueue);
                                runInvokeQueue(moduleFn._configBlocks);
                            } else if (isFunction(module)) {
                                runBlocks.push(providerInjector.invoke(module));
                            } else if (isArray(module)) {
                                runBlocks.push(providerInjector.invoke(module));
                            } else {
                                assertArgFn(module, "module");
                            }
                        } catch (e) {
                            if (isArray(module)) {
                                module = module[module.length - 1];
                            }
                            if (e.message && e.stack && e.stack.indexOf(e.message) === -1) {
                                e = e.message + "\n" + e.stack;
                            }
                            throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                        }
                    });
                    return runBlocks;
                }
                function createInternalInjector(cache, factory) {
                    function getService(serviceName, caller) {
                        if (cache.hasOwnProperty(serviceName)) {
                            if (cache[serviceName] === INSTANTIATING) {
                                throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                            }
                            return cache[serviceName];
                        } else {
                            try {
                                path.unshift(serviceName);
                                cache[serviceName] = INSTANTIATING;
                                cache[serviceName] = factory(serviceName, caller);
                                return cache[serviceName];
                            } catch (err) {
                                if (cache[serviceName] === INSTANTIATING) {
                                    delete cache[serviceName];
                                }
                                throw err;
                            } finally {
                                path.shift();
                            }
                        }
                    }
                    function injectionArgs(fn, locals, serviceName) {
                        var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                        for (var i = 0, length = $inject.length; i < length; i++) {
                            var key = $inject[i];
                            if (typeof key !== "string") {
                                throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                            }
                            args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                        }
                        return args;
                    }
                    function isClass(func) {
                        if (msie || typeof func !== "function") {
                            return false;
                        }
                        var result = func.$$ngIsClass;
                        if (!isBoolean(result)) {
                            result = func.$$ngIsClass = /^(?:class\b|constructor\()/.test(stringifyFn(func));
                        }
                        return result;
                    }
                    function invoke(fn, self, locals, serviceName) {
                        if (typeof locals === "string") {
                            serviceName = locals;
                            locals = null;
                        }
                        var args = injectionArgs(fn, locals, serviceName);
                        if (isArray(fn)) {
                            fn = fn[fn.length - 1];
                        }
                        if (!isClass(fn)) {
                            return fn.apply(self, args);
                        } else {
                            args.unshift(null);
                            return new (Function.prototype.bind.apply(fn, args))();
                        }
                    }
                    function instantiate(Type, locals, serviceName) {
                        var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
                        var args = injectionArgs(Type, locals, serviceName);
                        args.unshift(null);
                        return new (Function.prototype.bind.apply(ctor, args))();
                    }
                    return {
                        invoke: invoke,
                        instantiate: instantiate,
                        get: getService,
                        annotate: createInjector.$$annotate,
                        has: function(name) {
                            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                        }
                    };
                }
            }
            createInjector.$$annotate = annotate;
            function $AnchorScrollProvider() {
                var autoScrollingEnabled = true;
                this.disableAutoScrolling = function() {
                    autoScrollingEnabled = false;
                };
                this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
                    var document = $window.document;
                    function getFirstAnchor(list) {
                        var result = null;
                        Array.prototype.some.call(list, function(element) {
                            if (nodeName_(element) === "a") {
                                result = element;
                                return true;
                            }
                        });
                        return result;
                    }
                    function getYOffset() {
                        var offset = scroll.yOffset;
                        if (isFunction(offset)) {
                            offset = offset();
                        } else if (isElement(offset)) {
                            var elem = offset[0];
                            var style = $window.getComputedStyle(elem);
                            if (style.position !== "fixed") {
                                offset = 0;
                            } else {
                                offset = elem.getBoundingClientRect().bottom;
                            }
                        } else if (!isNumber(offset)) {
                            offset = 0;
                        }
                        return offset;
                    }
                    function scrollTo(elem) {
                        if (elem) {
                            elem.scrollIntoView();
                            var offset = getYOffset();
                            if (offset) {
                                var elemTop = elem.getBoundingClientRect().top;
                                $window.scrollBy(0, elemTop - offset);
                            }
                        } else {
                            $window.scrollTo(0, 0);
                        }
                    }
                    function scroll(hash) {
                        hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                        var elm;
                        if (!hash) scrollTo(null); else if (elm = document.getElementById(hash)) scrollTo(elm); else if (elm = getFirstAnchor(document.getElementsByName(hash))) scrollTo(elm); else if (hash === "top") scrollTo(null);
                    }
                    if (autoScrollingEnabled) {
                        $rootScope.$watch(function autoScrollWatch() {
                            return $location.hash();
                        }, function autoScrollWatchAction(newVal, oldVal) {
                            if (newVal === oldVal && newVal === "") return;
                            jqLiteDocumentLoaded(function() {
                                $rootScope.$evalAsync(scroll);
                            });
                        });
                    }
                    return scroll;
                } ];
            }
            var $animateMinErr = minErr("$animate");
            var ELEMENT_NODE = 1;
            var NG_ANIMATE_CLASSNAME = "ng-animate";
            function mergeClasses(a, b) {
                if (!a && !b) return "";
                if (!a) return b;
                if (!b) return a;
                if (isArray(a)) a = a.join(" ");
                if (isArray(b)) b = b.join(" ");
                return a + " " + b;
            }
            function extractElementNode(element) {
                for (var i = 0; i < element.length; i++) {
                    var elm = element[i];
                    if (elm.nodeType === ELEMENT_NODE) {
                        return elm;
                    }
                }
            }
            function splitClasses(classes) {
                if (isString(classes)) {
                    classes = classes.split(" ");
                }
                var obj = createMap();
                forEach(classes, function(klass) {
                    if (klass.length) {
                        obj[klass] = true;
                    }
                });
                return obj;
            }
            function prepareAnimateOptions(options) {
                return isObject(options) ? options : {};
            }
            var $$CoreAnimateJsProvider = function() {
                this.$get = noop;
            };
            var $$CoreAnimateQueueProvider = function() {
                var postDigestQueue = new NgMap();
                var postDigestElements = [];
                this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function(element, event, options, domOperation) {
                            if (domOperation) {
                                domOperation();
                            }
                            options = options || {};
                            if (options.from) {
                                element.css(options.from);
                            }
                            if (options.to) {
                                element.css(options.to);
                            }
                            if (options.addClass || options.removeClass) {
                                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                            }
                            var runner = new $$AnimateRunner();
                            runner.complete();
                            return runner;
                        }
                    };
                    function updateData(data, classes, value) {
                        var changed = false;
                        if (classes) {
                            classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [];
                            forEach(classes, function(className) {
                                if (className) {
                                    changed = true;
                                    data[className] = value;
                                }
                            });
                        }
                        return changed;
                    }
                    function handleCSSClassChanges() {
                        forEach(postDigestElements, function(element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = splitClasses(element.attr("class"));
                                var toAdd = "";
                                var toRemove = "";
                                forEach(data, function(status, className) {
                                    var hasClass = !!existing[className];
                                    if (status !== hasClass) {
                                        if (status) {
                                            toAdd += (toAdd.length ? " " : "") + className;
                                        } else {
                                            toRemove += (toRemove.length ? " " : "") + className;
                                        }
                                    }
                                });
                                forEach(element, function(elm) {
                                    if (toAdd) {
                                        jqLiteAddClass(elm, toAdd);
                                    }
                                    if (toRemove) {
                                        jqLiteRemoveClass(elm, toRemove);
                                    }
                                });
                                postDigestQueue.delete(element);
                            }
                        });
                        postDigestElements.length = 0;
                    }
                    function addRemoveClassesPostDigest(element, add, remove) {
                        var data = postDigestQueue.get(element) || {};
                        var classesAdded = updateData(data, add, true);
                        var classesRemoved = updateData(data, remove, false);
                        if (classesAdded || classesRemoved) {
                            postDigestQueue.set(element, data);
                            postDigestElements.push(element);
                            if (postDigestElements.length === 1) {
                                $rootScope.$$postDigest(handleCSSClassChanges);
                            }
                        }
                    }
                } ];
            };
            var $AnimateProvider = [ "$provide", function($provide) {
                var provider = this;
                var classNameFilter = null;
                var customFilter = null;
                this.$$registeredAnimations = Object.create(null);
                this.register = function(name, factory) {
                    if (name && name.charAt(0) !== ".") {
                        throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                    }
                    var key = name + "-animation";
                    provider.$$registeredAnimations[name.substr(1)] = key;
                    $provide.factory(key, factory);
                };
                this.customFilter = function(filterFn) {
                    if (arguments.length === 1) {
                        customFilter = isFunction(filterFn) ? filterFn : null;
                    }
                    return customFilter;
                };
                this.classNameFilter = function(expression) {
                    if (arguments.length === 1) {
                        classNameFilter = expression instanceof RegExp ? expression : null;
                        if (classNameFilter) {
                            var reservedRegex = new RegExp("[(\\s|\\/)]" + NG_ANIMATE_CLASSNAME + "[(\\s|\\/)]");
                            if (reservedRegex.test(classNameFilter.toString())) {
                                classNameFilter = null;
                                throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                            }
                        }
                    }
                    return classNameFilter;
                };
                this.$get = [ "$$animateQueue", function($$animateQueue) {
                    function domInsert(element, parentElement, afterElement) {
                        if (afterElement) {
                            var afterNode = extractElementNode(afterElement);
                            if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                                afterElement = null;
                            }
                        }
                        if (afterElement) {
                            afterElement.after(element);
                        } else {
                            parentElement.prepend(element);
                        }
                    }
                    return {
                        on: $$animateQueue.on,
                        off: $$animateQueue.off,
                        pin: $$animateQueue.pin,
                        enabled: $$animateQueue.enabled,
                        cancel: function(runner) {
                            if (runner.end) {
                                runner.end();
                            }
                        },
                        enter: function(element, parent, after, options) {
                            parent = parent && jqLite(parent);
                            after = after && jqLite(after);
                            parent = parent || after.parent();
                            domInsert(element, parent, after);
                            return $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                        },
                        move: function(element, parent, after, options) {
                            parent = parent && jqLite(parent);
                            after = after && jqLite(after);
                            parent = parent || after.parent();
                            domInsert(element, parent, after);
                            return $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                        },
                        leave: function(element, options) {
                            return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                                element.remove();
                            });
                        },
                        addClass: function(element, className, options) {
                            options = prepareAnimateOptions(options);
                            options.addClass = mergeClasses(options.addclass, className);
                            return $$animateQueue.push(element, "addClass", options);
                        },
                        removeClass: function(element, className, options) {
                            options = prepareAnimateOptions(options);
                            options.removeClass = mergeClasses(options.removeClass, className);
                            return $$animateQueue.push(element, "removeClass", options);
                        },
                        setClass: function(element, add, remove, options) {
                            options = prepareAnimateOptions(options);
                            options.addClass = mergeClasses(options.addClass, add);
                            options.removeClass = mergeClasses(options.removeClass, remove);
                            return $$animateQueue.push(element, "setClass", options);
                        },
                        animate: function(element, from, to, className, options) {
                            options = prepareAnimateOptions(options);
                            options.from = options.from ? extend(options.from, from) : from;
                            options.to = options.to ? extend(options.to, to) : to;
                            className = className || "ng-inline-animate";
                            options.tempClasses = mergeClasses(options.tempClasses, className);
                            return $$animateQueue.push(element, "animate", options);
                        }
                    };
                } ];
            } ];
            var $$AnimateAsyncRunFactoryProvider = function() {
                this.$get = [ "$$rAF", function($$rAF) {
                    var waitQueue = [];
                    function waitForTick(fn) {
                        waitQueue.push(fn);
                        if (waitQueue.length > 1) return;
                        $$rAF(function() {
                            for (var i = 0; i < waitQueue.length; i++) {
                                waitQueue[i]();
                            }
                            waitQueue = [];
                        });
                    }
                    return function() {
                        var passed = false;
                        waitForTick(function() {
                            passed = true;
                        });
                        return function(callback) {
                            if (passed) {
                                callback();
                            } else {
                                waitForTick(callback);
                            }
                        };
                    };
                } ];
            };
            var $$AnimateRunnerFactoryProvider = function() {
                this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
                    var INITIAL_STATE = 0;
                    var DONE_PENDING_STATE = 1;
                    var DONE_COMPLETE_STATE = 2;
                    AnimateRunner.chain = function(chain, callback) {
                        var index = 0;
                        next();
                        function next() {
                            if (index === chain.length) {
                                callback(true);
                                return;
                            }
                            chain[index](function(response) {
                                if (response === false) {
                                    callback(false);
                                    return;
                                }
                                index++;
                                next();
                            });
                        }
                    };
                    AnimateRunner.all = function(runners, callback) {
                        var count = 0;
                        var status = true;
                        forEach(runners, function(runner) {
                            runner.done(onProgress);
                        });
                        function onProgress(response) {
                            status = status && response;
                            if (++count === runners.length) {
                                callback(status);
                            }
                        }
                    };
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun();
                        var timeoutTick = function(fn) {
                            $timeout(fn, 0, false);
                        };
                        this._doneCallbacks = [];
                        this._tick = function(fn) {
                            if ($$isDocumentHidden()) {
                                timeoutTick(fn);
                            } else {
                                rafTick(fn);
                            }
                        };
                        this._state = 0;
                    }
                    AnimateRunner.prototype = {
                        setHost: function(host) {
                            this.host = host || {};
                        },
                        done: function(fn) {
                            if (this._state === DONE_COMPLETE_STATE) {
                                fn();
                            } else {
                                this._doneCallbacks.push(fn);
                            }
                        },
                        progress: noop,
                        getPromise: function() {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q(function(resolve, reject) {
                                    self.done(function(status) {
                                        if (status === false) {
                                            reject();
                                        } else {
                                            resolve();
                                        }
                                    });
                                });
                            }
                            return this.promise;
                        },
                        then: function(resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler);
                        },
                        catch: function(handler) {
                            return this.getPromise()["catch"](handler);
                        },
                        finally: function(handler) {
                            return this.getPromise()["finally"](handler);
                        },
                        pause: function() {
                            if (this.host.pause) {
                                this.host.pause();
                            }
                        },
                        resume: function() {
                            if (this.host.resume) {
                                this.host.resume();
                            }
                        },
                        end: function() {
                            if (this.host.end) {
                                this.host.end();
                            }
                            this._resolve(true);
                        },
                        cancel: function() {
                            if (this.host.cancel) {
                                this.host.cancel();
                            }
                            this._resolve(false);
                        },
                        complete: function(response) {
                            var self = this;
                            if (self._state === INITIAL_STATE) {
                                self._state = DONE_PENDING_STATE;
                                self._tick(function() {
                                    self._resolve(response);
                                });
                            }
                        },
                        _resolve: function(response) {
                            if (this._state !== DONE_COMPLETE_STATE) {
                                forEach(this._doneCallbacks, function(fn) {
                                    fn(response);
                                });
                                this._doneCallbacks.length = 0;
                                this._state = DONE_COMPLETE_STATE;
                            }
                        }
                    };
                    return AnimateRunner;
                } ];
            };
            var $CoreAnimateCssProvider = function() {
                this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
                    return function(element, initialOptions) {
                        var options = initialOptions || {};
                        if (!options.$$prepared) {
                            options = copy(options);
                        }
                        if (options.cleanupStyles) {
                            options.from = options.to = null;
                        }
                        if (options.from) {
                            element.css(options.from);
                            options.from = null;
                        }
                        var closed, runner = new $$AnimateRunner();
                        return {
                            start: run,
                            end: run
                        };
                        function run() {
                            $$rAF(function() {
                                applyAnimationContents();
                                if (!closed) {
                                    runner.complete();
                                }
                                closed = true;
                            });
                            return runner;
                        }
                        function applyAnimationContents() {
                            if (options.addClass) {
                                element.addClass(options.addClass);
                                options.addClass = null;
                            }
                            if (options.removeClass) {
                                element.removeClass(options.removeClass);
                                options.removeClass = null;
                            }
                            if (options.to) {
                                element.css(options.to);
                                options.to = null;
                            }
                        }
                    };
                } ];
            };
            function Browser(window, document, $log, $sniffer) {
                var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
                self.isMock = false;
                var outstandingRequestCount = 0;
                var outstandingRequestCallbacks = [];
                self.$$completeOutstandingRequest = completeOutstandingRequest;
                self.$$incOutstandingRequestCount = function() {
                    outstandingRequestCount++;
                };
                function completeOutstandingRequest(fn) {
                    try {
                        fn.apply(null, sliceArgs(arguments, 1));
                    } finally {
                        outstandingRequestCount--;
                        if (outstandingRequestCount === 0) {
                            while (outstandingRequestCallbacks.length) {
                                try {
                                    outstandingRequestCallbacks.pop()();
                                } catch (e) {
                                    $log.error(e);
                                }
                            }
                        }
                    }
                }
                function getHash(url) {
                    var index = url.indexOf("#");
                    return index === -1 ? "" : url.substr(index);
                }
                self.notifyWhenNoOutstandingRequests = function(callback) {
                    if (outstandingRequestCount === 0) {
                        callback();
                    } else {
                        outstandingRequestCallbacks.push(callback);
                    }
                };
                var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
                    try {
                        return history.state;
                    } catch (e) {}
                };
                cacheState();
                self.url = function(url, replace, state) {
                    if (isUndefined(state)) {
                        state = null;
                    }
                    if (location !== window.location) location = window.location;
                    if (history !== window.history) history = window.history;
                    if (url) {
                        var sameState = lastHistoryState === state;
                        if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                            return self;
                        }
                        var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                        lastBrowserUrl = url;
                        lastHistoryState = state;
                        if ($sniffer.history && (!sameBase || !sameState)) {
                            history[replace ? "replaceState" : "pushState"](state, "", url);
                            cacheState();
                        } else {
                            if (!sameBase) {
                                pendingLocation = url;
                            }
                            if (replace) {
                                location.replace(url);
                            } else if (!sameBase) {
                                location.href = url;
                            } else {
                                location.hash = getHash(url);
                            }
                            if (location.href !== url) {
                                pendingLocation = url;
                            }
                        }
                        if (pendingLocation) {
                            pendingLocation = url;
                        }
                        return self;
                    } else {
                        return pendingLocation || location.href.replace(/%27/g, "'");
                    }
                };
                self.state = function() {
                    return cachedState;
                };
                var urlChangeListeners = [], urlChangeInit = false;
                function cacheStateAndFireUrlChange() {
                    pendingLocation = null;
                    fireStateOrUrlChange();
                }
                var lastCachedState = null;
                function cacheState() {
                    cachedState = getCurrentState();
                    cachedState = isUndefined(cachedState) ? null : cachedState;
                    if (equals(cachedState, lastCachedState)) {
                        cachedState = lastCachedState;
                    }
                    lastCachedState = cachedState;
                    lastHistoryState = cachedState;
                }
                function fireStateOrUrlChange() {
                    var prevLastHistoryState = lastHistoryState;
                    cacheState();
                    if (lastBrowserUrl === self.url() && prevLastHistoryState === cachedState) {
                        return;
                    }
                    lastBrowserUrl = self.url();
                    lastHistoryState = cachedState;
                    forEach(urlChangeListeners, function(listener) {
                        listener(self.url(), cachedState);
                    });
                }
                self.onUrlChange = function(callback) {
                    if (!urlChangeInit) {
                        if ($sniffer.history) jqLite(window).on("popstate", cacheStateAndFireUrlChange);
                        jqLite(window).on("hashchange", cacheStateAndFireUrlChange);
                        urlChangeInit = true;
                    }
                    urlChangeListeners.push(callback);
                    return callback;
                };
                self.$$applicationDestroyed = function() {
                    jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
                };
                self.$$checkUrlChange = fireStateOrUrlChange;
                self.baseHref = function() {
                    var href = baseElement.attr("href");
                    return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
                };
                self.defer = function(fn, delay) {
                    var timeoutId;
                    outstandingRequestCount++;
                    timeoutId = setTimeout(function() {
                        delete pendingDeferIds[timeoutId];
                        completeOutstandingRequest(fn);
                    }, delay || 0);
                    pendingDeferIds[timeoutId] = true;
                    return timeoutId;
                };
                self.defer.cancel = function(deferId) {
                    if (pendingDeferIds[deferId]) {
                        delete pendingDeferIds[deferId];
                        clearTimeout(deferId);
                        completeOutstandingRequest(noop);
                        return true;
                    }
                    return false;
                };
            }
            function $BrowserProvider() {
                this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
                    return new Browser($window, $document, $log, $sniffer);
                } ];
            }
            function $CacheFactoryProvider() {
                this.$get = function() {
                    var caches = {};
                    function cacheFactory(cacheId, options) {
                        if (cacheId in caches) {
                            throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                        }
                        var size = 0, stats = extend({}, options, {
                            id: cacheId
                        }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                        return caches[cacheId] = {
                            put: function(key, value) {
                                if (isUndefined(value)) return;
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key] || (lruHash[key] = {
                                        key: key
                                    });
                                    refresh(lruEntry);
                                }
                                if (!(key in data)) size++;
                                data[key] = value;
                                if (size > capacity) {
                                    this.remove(staleEnd.key);
                                }
                                return value;
                            },
                            get: function(key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry) return;
                                    refresh(lruEntry);
                                }
                                return data[key];
                            },
                            remove: function(key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry) return;
                                    if (lruEntry === freshEnd) freshEnd = lruEntry.p;
                                    if (lruEntry === staleEnd) staleEnd = lruEntry.n;
                                    link(lruEntry.n, lruEntry.p);
                                    delete lruHash[key];
                                }
                                if (!(key in data)) return;
                                delete data[key];
                                size--;
                            },
                            removeAll: function() {
                                data = createMap();
                                size = 0;
                                lruHash = createMap();
                                freshEnd = staleEnd = null;
                            },
                            destroy: function() {
                                data = null;
                                stats = null;
                                lruHash = null;
                                delete caches[cacheId];
                            },
                            info: function() {
                                return extend({}, stats, {
                                    size: size
                                });
                            }
                        };
                        function refresh(entry) {
                            if (entry !== freshEnd) {
                                if (!staleEnd) {
                                    staleEnd = entry;
                                } else if (staleEnd === entry) {
                                    staleEnd = entry.n;
                                }
                                link(entry.n, entry.p);
                                link(entry, freshEnd);
                                freshEnd = entry;
                                freshEnd.n = null;
                            }
                        }
                        function link(nextEntry, prevEntry) {
                            if (nextEntry !== prevEntry) {
                                if (nextEntry) nextEntry.p = prevEntry;
                                if (prevEntry) prevEntry.n = nextEntry;
                            }
                        }
                    }
                    cacheFactory.info = function() {
                        var info = {};
                        forEach(caches, function(cache, cacheId) {
                            info[cacheId] = cache.info();
                        });
                        return info;
                    };
                    cacheFactory.get = function(cacheId) {
                        return caches[cacheId];
                    };
                    return cacheFactory;
                };
            }
            function $TemplateCacheProvider() {
                this.$get = [ "$cacheFactory", function($cacheFactory) {
                    return $cacheFactory("templates");
                } ];
            }
            var $compileMinErr = minErr("$compile");
            function UNINITIALIZED_VALUE() {}
            var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
            $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
            function $CompileProvider($provide, $$sanitizeUriProvider) {
                var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
                var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
                var bindingCache = createMap();
                function parseIsolateBindings(scope, directiveName, isController) {
                    var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*([\w$]*)\s*$/;
                    var bindings = createMap();
                    forEach(scope, function(definition, scopeName) {
                        if (definition in bindingCache) {
                            bindings[scopeName] = bindingCache[definition];
                            return;
                        }
                        var match = definition.match(LOCAL_REGEXP);
                        if (!match) {
                            throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                        }
                        bindings[scopeName] = {
                            mode: match[1][0],
                            collection: match[2] === "*",
                            optional: match[3] === "?",
                            attrName: match[4] || scopeName
                        };
                        if (match[4]) {
                            bindingCache[definition] = bindings[scopeName];
                        }
                    });
                    return bindings;
                }
                function parseDirectiveBindings(directive, directiveName) {
                    var bindings = {
                        isolateScope: null,
                        bindToController: null
                    };
                    if (isObject(directive.scope)) {
                        if (directive.bindToController === true) {
                            bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                            bindings.isolateScope = {};
                        } else {
                            bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                        }
                    }
                    if (isObject(directive.bindToController)) {
                        bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
                    }
                    if (bindings.bindToController && !directive.controller) {
                        throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                    }
                    return bindings;
                }
                function assertValidDirectiveName(name) {
                    var letter = name.charAt(0);
                    if (!letter || letter !== lowercase(letter)) {
                        throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                    }
                    if (name !== name.trim()) {
                        throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
                    }
                }
                function getDirectiveRequire(directive) {
                    var require = directive.require || directive.controller && directive.name;
                    if (!isArray(require) && isObject(require)) {
                        forEach(require, function(value, key) {
                            var match = value.match(REQUIRE_PREFIX_REGEXP);
                            var name = value.substring(match[0].length);
                            if (!name) require[key] = match[0] + key;
                        });
                    }
                    return require;
                }
                function getDirectiveRestrict(restrict, name) {
                    if (restrict && !(isString(restrict) && /[EACM]/.test(restrict))) {
                        throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                    }
                    return restrict || "EA";
                }
                this.directive = function registerDirective(name, directiveFactory) {
                    assertArg(name, "name");
                    assertNotHasOwnProperty(name, "directive");
                    if (isString(name)) {
                        assertValidDirectiveName(name);
                        assertArg(directiveFactory, "directiveFactory");
                        if (!hasDirectives.hasOwnProperty(name)) {
                            hasDirectives[name] = [];
                            $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                                var directives = [];
                                forEach(hasDirectives[name], function(directiveFactory, index) {
                                    try {
                                        var directive = $injector.invoke(directiveFactory);
                                        if (isFunction(directive)) {
                                            directive = {
                                                compile: valueFn(directive)
                                            };
                                        } else if (!directive.compile && directive.link) {
                                            directive.compile = valueFn(directive.link);
                                        }
                                        directive.priority = directive.priority || 0;
                                        directive.index = index;
                                        directive.name = directive.name || name;
                                        directive.require = getDirectiveRequire(directive);
                                        directive.restrict = getDirectiveRestrict(directive.restrict, name);
                                        directive.$$moduleName = directiveFactory.$$moduleName;
                                        directives.push(directive);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                                return directives;
                            } ]);
                        }
                        hasDirectives[name].push(directiveFactory);
                    } else {
                        forEach(name, reverseParams(registerDirective));
                    }
                    return this;
                };
                this.component = function registerComponent(name, options) {
                    if (!isString(name)) {
                        forEach(name, reverseParams(bind(this, registerComponent)));
                        return this;
                    }
                    var controller = options.controller || function() {};
                    function factory($injector) {
                        function makeInjectable(fn) {
                            if (isFunction(fn) || isArray(fn)) {
                                return function(tElement, tAttrs) {
                                    return $injector.invoke(fn, this, {
                                        $element: tElement,
                                        $attrs: tAttrs
                                    });
                                };
                            } else {
                                return fn;
                            }
                        }
                        var template = !options.template && !options.templateUrl ? "" : options.template;
                        var ddo = {
                            controller: controller,
                            controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                            template: makeInjectable(template),
                            templateUrl: makeInjectable(options.templateUrl),
                            transclude: options.transclude,
                            scope: {},
                            bindToController: options.bindings || {},
                            restrict: "E",
                            require: options.require
                        };
                        forEach(options, function(val, key) {
                            if (key.charAt(0) === "$") ddo[key] = val;
                        });
                        return ddo;
                    }
                    forEach(options, function(val, key) {
                        if (key.charAt(0) === "$") {
                            factory[key] = val;
                            if (isFunction(controller)) controller[key] = val;
                        }
                    });
                    factory.$inject = [ "$injector" ];
                    return this.directive(name, factory);
                };
                this.aHrefSanitizationWhitelist = function(regexp) {
                    if (isDefined(regexp)) {
                        $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                        return this;
                    } else {
                        return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
                    }
                };
                this.imgSrcSanitizationWhitelist = function(regexp) {
                    if (isDefined(regexp)) {
                        $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                        return this;
                    } else {
                        return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
                    }
                };
                var debugInfoEnabled = true;
                this.debugInfoEnabled = function(enabled) {
                    if (isDefined(enabled)) {
                        debugInfoEnabled = enabled;
                        return this;
                    }
                    return debugInfoEnabled;
                };
                var preAssignBindingsEnabled = false;
                this.preAssignBindingsEnabled = function(enabled) {
                    if (isDefined(enabled)) {
                        preAssignBindingsEnabled = enabled;
                        return this;
                    }
                    return preAssignBindingsEnabled;
                };
                var strictComponentBindingsEnabled = false;
                this.strictComponentBindingsEnabled = function(enabled) {
                    if (isDefined(enabled)) {
                        strictComponentBindingsEnabled = enabled;
                        return this;
                    }
                    return strictComponentBindingsEnabled;
                };
                var TTL = 10;
                this.onChangesTtl = function(value) {
                    if (arguments.length) {
                        TTL = value;
                        return this;
                    }
                    return TTL;
                };
                var commentDirectivesEnabledConfig = true;
                this.commentDirectivesEnabled = function(value) {
                    if (arguments.length) {
                        commentDirectivesEnabledConfig = value;
                        return this;
                    }
                    return commentDirectivesEnabledConfig;
                };
                var cssClassDirectivesEnabledConfig = true;
                this.cssClassDirectivesEnabled = function(value) {
                    if (arguments.length) {
                        cssClassDirectivesEnabledConfig = value;
                        return this;
                    }
                    return cssClassDirectivesEnabledConfig;
                };
                this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
                    var SIMPLE_ATTR_NAME = /^\w/;
                    var specialAttrHolder = window.document.createElement("div");
                    var commentDirectivesEnabled = commentDirectivesEnabledConfig;
                    var cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig;
                    var onChangesTtl = TTL;
                    var onChangesQueue;
                    function flushOnChangesQueue() {
                        try {
                            if (!--onChangesTtl) {
                                onChangesQueue = undefined;
                                throw $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                            }
                            $rootScope.$apply(function() {
                                var errors = [];
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                                    try {
                                        onChangesQueue[i]();
                                    } catch (e) {
                                        errors.push(e);
                                    }
                                }
                                onChangesQueue = undefined;
                                if (errors.length) {
                                    throw errors;
                                }
                            });
                        } finally {
                            onChangesTtl++;
                        }
                    }
                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var keys = Object.keys(attributesToCopy);
                            var i, l, key;
                            for (i = 0, l = keys.length; i < l; i++) {
                                key = keys[i];
                                this[key] = attributesToCopy[key];
                            }
                        } else {
                            this.$attr = {};
                        }
                        this.$$element = element;
                    }
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function(classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.addClass(this.$$element, classVal);
                            }
                        },
                        $removeClass: function(classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.removeClass(this.$$element, classVal);
                            }
                        },
                        $updateClass: function(newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            if (toAdd && toAdd.length) {
                                $animate.addClass(this.$$element, toAdd);
                            }
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            if (toRemove && toRemove.length) {
                                $animate.removeClass(this.$$element, toRemove);
                            }
                        },
                        $set: function(key, value, writeAttr, attrName) {
                            var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                            if (booleanKey) {
                                this.$$element.prop(key, value);
                                attrName = booleanKey;
                            } else if (aliasedKey) {
                                this[aliasedKey] = value;
                                observer = aliasedKey;
                            }
                            this[key] = value;
                            if (attrName) {
                                this.$attr[key] = attrName;
                            } else {
                                attrName = this.$attr[key];
                                if (!attrName) {
                                    this.$attr[key] = attrName = snake_case(key, "-");
                                }
                            }
                            nodeName = nodeName_(this.$$element);
                            if (nodeName === "a" && (key === "href" || key === "xlinkHref") || nodeName === "img" && key === "src") {
                                this[key] = value = $$sanitizeUri(value, key === "src");
                            } else if (nodeName === "img" && key === "srcset" && isDefined(value)) {
                                var result = "";
                                var trimmedSrcset = trim(value);
                                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                                var rawUris = trimmedSrcset.split(pattern);
                                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                                for (var i = 0; i < nbrUrisWith2parts; i++) {
                                    var innerIdx = i * 2;
                                    result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                                    result += " " + trim(rawUris[innerIdx + 1]);
                                }
                                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                                result += $$sanitizeUri(trim(lastTuple[0]), true);
                                if (lastTuple.length === 2) {
                                    result += " " + trim(lastTuple[1]);
                                }
                                this[key] = value = result;
                            }
                            if (writeAttr !== false) {
                                if (value === null || isUndefined(value)) {
                                    this.$$element.removeAttr(attrName);
                                } else {
                                    if (SIMPLE_ATTR_NAME.test(attrName)) {
                                        this.$$element.attr(attrName, value);
                                    } else {
                                        setSpecialAttr(this.$$element[0], attrName, value);
                                    }
                                }
                            }
                            var $$observers = this.$$observers;
                            if ($$observers) {
                                forEach($$observers[observer], function(fn) {
                                    try {
                                        fn(value);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                            }
                        },
                        $observe: function(key, fn) {
                            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                            listeners.push(fn);
                            $rootScope.$evalAsync(function() {
                                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                                    fn(attrs[key]);
                                }
                            });
                            return function() {
                                arrayRemove(listeners, fn);
                            };
                        }
                    };
                    function setSpecialAttr(element, attrName, value) {
                        specialAttrHolder.innerHTML = "<span " + attrName + ">";
                        var attributes = specialAttrHolder.firstChild.attributes;
                        var attribute = attributes[0];
                        attributes.removeNamedItem(attribute.name);
                        attribute.value = value;
                        element.attributes.setNamedItem(attribute);
                    }
                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className);
                        } catch (e) {}
                    }
                    var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol === "{{" && endSymbol === "}}" ? identity : function denormalizeTemplate(template) {
                        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                    }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                    var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                        var bindings = $element.data("$binding") || [];
                        if (isArray(binding)) {
                            bindings = bindings.concat(binding);
                        } else {
                            bindings.push(binding);
                        }
                        $element.data("$binding", bindings);
                    } : noop;
                    compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                        safeAddClass($element, "ng-binding");
                    } : noop;
                    compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                        $element.data(dataName, scope);
                    } : noop;
                    compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                        safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
                    } : noop;
                    compile.$$createComment = function(directiveName, comment) {
                        var content = "";
                        if (debugInfoEnabled) {
                            content = " " + (directiveName || "") + ": ";
                            if (comment) content += comment + " ";
                        }
                        return window.document.createComment(content);
                    };
                    return compile;
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        if (!($compileNodes instanceof jqLite)) {
                            $compileNodes = jqLite($compileNodes);
                        }
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function publicLinkFn(scope, cloneConnectFn, options) {
                            if (!$compileNodes) {
                                throw $compileMinErr("multilink", "This element has already been linked.");
                            }
                            assertArg(scope, "scope");
                            if (previousCompileContext && previousCompileContext.needsNewScope) {
                                scope = scope.$parent.$new();
                            }
                            options = options || {};
                            var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                            }
                            if (!namespace) {
                                namespace = detectNamespaceForChildElements(futureParentElement);
                            }
                            var $linkNode;
                            if (namespace !== "html") {
                                $linkNode = jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html()));
                            } else if (cloneConnectFn) {
                                $linkNode = JQLitePrototype.clone.call($compileNodes);
                            } else {
                                $linkNode = $compileNodes;
                            }
                            if (transcludeControllers) {
                                for (var controllerName in transcludeControllers) {
                                    $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                                }
                            }
                            compile.$$addScopeInfo($linkNode, scope);
                            if (cloneConnectFn) cloneConnectFn($linkNode, scope);
                            if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                            if (!cloneConnectFn) {
                                $compileNodes = compositeLinkFn = null;
                            }
                            return $linkNode;
                        };
                    }
                    function detectNamespaceForChildElements(parentElement) {
                        var node = parentElement && parentElement[0];
                        if (!node) {
                            return "html";
                        } else {
                            return nodeName_(node) !== "foreignobject" && toString.call(node).match(/SVG/) ? "svg" : "html";
                        }
                    }
                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        var linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                        for (var i = 0; i < nodeList.length; i++) {
                            attrs = new Attributes();
                            if (msie === 11) {
                                mergeConsecutiveTextNodes(nodeList, i, notLiveList);
                            }
                            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                            if (nodeLinkFn && nodeLinkFn.scope) {
                                compile.$$addScopeClass(attrs.$$element);
                            }
                            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                            if (nodeLinkFn || childLinkFn) {
                                linkFns.push(i, nodeLinkFn, childLinkFn);
                                linkFnFound = true;
                                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                            }
                            previousCompileContext = null;
                        }
                        return linkFnFound ? compositeLinkFn : null;
                        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                            var stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                stableNodeList = new Array(nodeListLength);
                                for (i = 0; i < linkFns.length; i += 3) {
                                    idx = linkFns[i];
                                    stableNodeList[idx] = nodeList[idx];
                                }
                            } else {
                                stableNodeList = nodeList;
                            }
                            for (i = 0, ii = linkFns.length; i < ii; ) {
                                node = stableNodeList[linkFns[i++]];
                                nodeLinkFn = linkFns[i++];
                                childLinkFn = linkFns[i++];
                                if (nodeLinkFn) {
                                    if (nodeLinkFn.scope) {
                                        childScope = scope.$new();
                                        compile.$$addScopeInfo(jqLite(node), childScope);
                                    } else {
                                        childScope = scope;
                                    }
                                    if (nodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                                    } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                        childBoundTranscludeFn = parentBoundTranscludeFn;
                                    } else if (!parentBoundTranscludeFn && transcludeFn) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                                    } else {
                                        childBoundTranscludeFn = null;
                                    }
                                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                                } else if (childLinkFn) {
                                    childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                                }
                            }
                        }
                    }
                    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                        var node = nodeList[idx];
                        var parent = node.parentNode;
                        var sibling;
                        if (node.nodeType !== NODE_TYPE_TEXT) {
                            return;
                        }
                        while (true) {
                            sibling = parent ? node.nextSibling : nodeList[idx + 1];
                            if (!sibling || sibling.nodeType !== NODE_TYPE_TEXT) {
                                break;
                            }
                            node.nodeValue = node.nodeValue + sibling.nodeValue;
                            if (sibling.parentNode) {
                                sibling.parentNode.removeChild(sibling);
                            }
                            if (notLiveList && sibling === nodeList[idx + 1]) {
                                nodeList.splice(idx + 1, 1);
                            }
                        }
                    }
                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            if (!transcludedScope) {
                                transcludedScope = scope.$new(false, containingScope);
                                transcludedScope.$$transcluded = true;
                            }
                            return transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement: futureParentElement
                            });
                        }
                        var boundSlots = boundTranscludeFn.$$slots = createMap();
                        for (var slotName in transcludeFn.$$slots) {
                            if (transcludeFn.$$slots[slotName]) {
                                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                            } else {
                                boundSlots[slotName] = null;
                            }
                        }
                        return boundTranscludeFn;
                    }
                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var nodeType = node.nodeType, attrsMap = attrs.$attr, match, nodeName, className;
                        switch (nodeType) {
                          case NODE_TYPE_ELEMENT:
                            nodeName = nodeName_(node);
                            addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                            for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                var attrStartName = false;
                                var attrEndName = false;
                                attr = nAttrs[j];
                                name = attr.name;
                                value = attr.value;
                                ngAttrName = directiveNormalize(name);
                                isNgAttr = NG_ATTR_BINDING.test(ngAttrName);
                                if (isNgAttr) {
                                    name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                                        return letter.toUpperCase();
                                    });
                                }
                                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                                if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                                    attrStartName = name;
                                    attrEndName = name.substr(0, name.length - 5) + "end";
                                    name = name.substr(0, name.length - 6);
                                }
                                nName = directiveNormalize(name.toLowerCase());
                                attrsMap[nName] = name;
                                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                    attrs[nName] = value;
                                    if (getBooleanAttrName(node, nName)) {
                                        attrs[nName] = true;
                                    }
                                }
                                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                                addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                            }
                            if (nodeName === "input" && node.getAttribute("type") === "hidden") {
                                node.setAttribute("autocomplete", "off");
                            }
                            if (!cssClassDirectivesEnabled) break;
                            className = node.className;
                            if (isObject(className)) {
                                className = className.animVal;
                            }
                            if (isString(className) && className !== "") {
                                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                    nName = directiveNormalize(match[2]);
                                    if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                        attrs[nName] = trim(match[3]);
                                    }
                                    className = className.substr(match.index + match[0].length);
                                }
                            }
                            break;

                          case NODE_TYPE_TEXT:
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;

                          case NODE_TYPE_COMMENT:
                            if (!commentDirectivesEnabled) break;
                            collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                            break;
                        }
                        directives.sort(byPriority);
                        return directives;
                    }
                    function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        try {
                            var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                            if (match) {
                                var nName = directiveNormalize(match[1]);
                                if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                    attrs[nName] = trim(match[2]);
                                }
                            }
                        } catch (e) {}
                    }
                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [];
                        var depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) {
                                    throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                                }
                                if (node.nodeType === NODE_TYPE_ELEMENT) {
                                    if (node.hasAttribute(attrStart)) depth++;
                                    if (node.hasAttribute(attrEnd)) depth--;
                                }
                                nodes.push(node);
                                node = node.nextSibling;
                            } while (depth > 0);
                        } else {
                            nodes.push(node);
                        }
                        return jqLite(nodes);
                    }
                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                            element = groupScan(element[0], attrStart, attrEnd);
                            return linkFn(scope, element, attrs, controllers, transcludeFn);
                        };
                    }
                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        if (eager) {
                            return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        }
                        return function lazyCompilation() {
                            if (!compiled) {
                                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                                $compileNodes = transcludeFn = previousCompileContext = null;
                            }
                            return compiled.apply(this, arguments);
                        };
                    }
                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        previousCompileContext = previousCompileContext || {};
                        var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
                        for (var i = 0, ii = directives.length; i < ii; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start;
                            var attrEnd = directive.$$end;
                            if (attrStart) {
                                $compileNode = groupScan(compileNode, attrStart, attrEnd);
                            }
                            $template = undefined;
                            if (terminalPriority > directive.priority) {
                                break;
                            }
                            directiveValue = directive.scope;
                            if (directiveValue) {
                                if (!directive.templateUrl) {
                                    if (isObject(directiveValue)) {
                                        assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                        newIsolateScopeDirective = directive;
                                    } else {
                                        assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode);
                                    }
                                }
                                newScopeDirective = newScopeDirective || directive;
                            }
                            directiveName = directive.name;
                            if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                                var candidateDirective;
                                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                                    if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                        mightHaveMultipleTransclusionError = true;
                                        break;
                                    }
                                }
                                didScanForMultipleTransclusion = true;
                            }
                            if (!directive.templateUrl && directive.controller) {
                                controllerDirectives = controllerDirectives || createMap();
                                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                                controllerDirectives[directiveName] = directive;
                            }
                            directiveValue = directive.transclude;
                            if (directiveValue) {
                                hasTranscludeDirective = true;
                                if (!directive.$$tlb) {
                                    assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode);
                                    nonTlbTranscludeDirective = directive;
                                }
                                if (directiveValue === "element") {
                                    hasElementTranscludeDirective = true;
                                    terminalPriority = directive.priority;
                                    $template = $compileNode;
                                    $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                                    compileNode = $compileNode[0];
                                    replaceWith(jqCollection, sliceArgs($template), compileNode);
                                    $template[0].$$parentNode = $template[0].parentNode;
                                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                    });
                                } else {
                                    var slots = createMap();
                                    if (!isObject(directiveValue)) {
                                        $template = jqLite(jqLiteClone(compileNode)).contents();
                                    } else {
                                        $template = [];
                                        var slotMap = createMap();
                                        var filledSlots = createMap();
                                        forEach(directiveValue, function(elementSelector, slotName) {
                                            var optional = elementSelector.charAt(0) === "?";
                                            elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                            slotMap[elementSelector] = slotName;
                                            slots[slotName] = null;
                                            filledSlots[slotName] = optional;
                                        });
                                        forEach($compileNode.contents(), function(node) {
                                            var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                            if (slotName) {
                                                filledSlots[slotName] = true;
                                                slots[slotName] = slots[slotName] || [];
                                                slots[slotName].push(node);
                                            } else {
                                                $template.push(node);
                                            }
                                        });
                                        forEach(filledSlots, function(filled, slotName) {
                                            if (!filled) {
                                                throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                                            }
                                        });
                                        for (var slotName in slots) {
                                            if (slots[slotName]) {
                                                slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                                            }
                                        }
                                    }
                                    $compileNode.empty();
                                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {
                                        needsNewScope: directive.$$isolateScope || directive.$$newScope
                                    });
                                    childTranscludeFn.$$slots = slots;
                                }
                            }
                            if (directive.template) {
                                hasTemplate = true;
                                assertNoDuplicate("template", templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                                directiveValue = denormalizeTemplate(directiveValue);
                                if (directive.replace) {
                                    replaceDirective = directive;
                                    if (jqLiteIsTextNode(directiveValue)) {
                                        $template = [];
                                    } else {
                                        $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                                    }
                                    compileNode = $template[0];
                                    if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                        throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                    }
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = {
                                        $attr: {}
                                    };
                                    var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                                    var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    if (newIsolateScopeDirective || newScopeDirective) {
                                        markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                                    }
                                    directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                                    mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                                    ii = directives.length;
                                } else {
                                    $compileNode.html(directiveValue);
                                }
                            }
                            if (directive.templateUrl) {
                                hasTemplate = true;
                                assertNoDuplicate("template", templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                if (directive.replace) {
                                    replaceDirective = directive;
                                }
                                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                    controllerDirectives: controllerDirectives,
                                    newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                    newIsolateScopeDirective: newIsolateScopeDirective,
                                    templateDirective: templateDirective,
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                });
                                ii = directives.length;
                            } else if (directive.compile) {
                                try {
                                    linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                    var context = directive.$$originalDirective || directive;
                                    if (isFunction(linkFn)) {
                                        addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                                    } else if (linkFn) {
                                        addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                                    }
                                } catch (e) {
                                    $exceptionHandler(e, startingTag($compileNode));
                                }
                            }
                            if (directive.terminal) {
                                nodeLinkFn.terminal = true;
                                terminalPriority = Math.max(terminalPriority, directive.priority);
                            }
                        }
                        nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                        nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                        nodeLinkFn.templateOnThisElement = hasTemplate;
                        nodeLinkFn.transclude = childTranscludeFn;
                        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                        return nodeLinkFn;
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            if (pre) {
                                if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                                pre.require = directive.require;
                                pre.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    pre = cloneAndAnnotateFn(pre, {
                                        isolateScope: true
                                    });
                                }
                                preLinkFns.push(pre);
                            }
                            if (post) {
                                if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                                post.require = directive.require;
                                post.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    post = cloneAndAnnotateFn(post, {
                                        isolateScope: true
                                    });
                                }
                                postLinkFns.push(post);
                            }
                        }
                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            if (compileNode === linkNode) {
                                attrs = templateAttrs;
                                $element = templateAttrs.$$element;
                            } else {
                                $element = jqLite(linkNode);
                                attrs = new Attributes($element, templateAttrs);
                            }
                            controllerScope = scope;
                            if (newIsolateScopeDirective) {
                                isolateScope = scope.$new(true);
                            } else if (newScopeDirective) {
                                controllerScope = scope.$parent;
                            }
                            if (boundTranscludeFn) {
                                transcludeFn = controllersBoundTransclude;
                                transcludeFn.$$boundTransclude = boundTranscludeFn;
                                transcludeFn.isSlotFilled = function(slotName) {
                                    return !!boundTranscludeFn.$$slots[slotName];
                                };
                            }
                            if (controllerDirectives) {
                                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                            }
                            if (newIsolateScopeDirective) {
                                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                                compile.$$addScopeClass($element, true);
                                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                                if (scopeBindingInfo.removeWatches) {
                                    isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                                }
                            }
                            for (var name in elementControllers) {
                                var controllerDirective = controllerDirectives[name];
                                var controller = elementControllers[name];
                                var bindings = controllerDirective.$$bindings.bindToController;
                                if (preAssignBindingsEnabled) {
                                    if (bindings) {
                                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                    } else {
                                        controller.bindingInfo = {};
                                    }
                                    var controllerResult = controller();
                                    if (controllerResult !== controller.instance) {
                                        controller.instance = controllerResult;
                                        $element.data("$" + controllerDirective.name + "Controller", controllerResult);
                                        if (controller.bindingInfo.removeWatches) {
                                            controller.bindingInfo.removeWatches();
                                        }
                                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                    }
                                } else {
                                    controller.instance = controller();
                                    $element.data("$" + controllerDirective.name + "Controller", controller.instance);
                                    controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                }
                            }
                            forEach(controllerDirectives, function(controllerDirective, name) {
                                var require = controllerDirective.require;
                                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                                    extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                                }
                            });
                            forEach(elementControllers, function(controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$onChanges)) {
                                    try {
                                        controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (isFunction(controllerInstance.$onInit)) {
                                    try {
                                        controllerInstance.$onInit();
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (isFunction(controllerInstance.$doCheck)) {
                                    controllerScope.$watch(function() {
                                        controllerInstance.$doCheck();
                                    });
                                    controllerInstance.$doCheck();
                                }
                                if (isFunction(controllerInstance.$onDestroy)) {
                                    controllerScope.$on("$destroy", function callOnDestroyHook() {
                                        controllerInstance.$onDestroy();
                                    });
                                }
                            });
                            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                                linkFn = preLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            var scopeToChild = scope;
                            if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                                scopeToChild = isolateScope;
                            }
                            if (childLinkFn) {
                                childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                            }
                            for (i = postLinkFns.length - 1; i >= 0; i--) {
                                linkFn = postLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            forEach(elementControllers, function(controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$postLink)) {
                                    controllerInstance.$postLink();
                                }
                            });
                            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                                var transcludeControllers;
                                if (!isScope(scope)) {
                                    slotName = futureParentElement;
                                    futureParentElement = cloneAttachFn;
                                    cloneAttachFn = scope;
                                    scope = undefined;
                                }
                                if (hasElementTranscludeDirective) {
                                    transcludeControllers = elementControllers;
                                }
                                if (!futureParentElement) {
                                    futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                                }
                                if (slotName) {
                                    var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                    if (slotTranscludeFn) {
                                        return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                    } else if (isUndefined(slotTranscludeFn)) {
                                        throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". ' + "Element: {1}", slotName, startingTag($element));
                                    }
                                } else {
                                    return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                }
                            }
                        }
                    }
                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP);
                            var name = require.substring(match[0].length);
                            var inheritType = match[1] || match[3];
                            var optional = match[2] === "?";
                            if (inheritType === "^^") {
                                $element = $element.parent();
                            } else {
                                value = elementControllers && elementControllers[name];
                                value = value && value.instance;
                            }
                            if (!value) {
                                var dataName = "$" + name + "Controller";
                                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                            }
                            if (!value && !optional) {
                                throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                            }
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) {
                                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                            }
                        } else if (isObject(require)) {
                            value = {};
                            forEach(require, function(controller, property) {
                                value[property] = getControllers(directiveName, controller, $element, elementControllers);
                            });
                        }
                        return value || null;
                    }
                    function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                        var elementControllers = createMap();
                        for (var controllerKey in controllerDirectives) {
                            var directive = controllerDirectives[controllerKey];
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            };
                            var controller = directive.controller;
                            if (controller === "@") {
                                controller = attrs[directive.name];
                            }
                            var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance;
                            $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                        }
                        return elementControllers;
                    }
                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) {
                            directives[j] = inherit(directives[j], {
                                $$isolateScope: isolateScope,
                                $$newScope: newScope
                            });
                        }
                    }
                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                                    if (startAttrName) {
                                        directive = inherit(directive, {
                                            $$start: startAttrName,
                                            $$end: endAttrName
                                        });
                                    }
                                    if (!directive.$$bindings) {
                                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                        if (isObject(bindings.isolateScope)) {
                                            directive.$$isolateBindings = bindings.isolateScope;
                                        }
                                    }
                                    tDirectives.push(directive);
                                    match = directive;
                                }
                            }
                        }
                        return match;
                    }
                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                if (directive.multiElement) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr, dstAttr = dst.$attr;
                        forEach(dst, function(value, key) {
                            if (key.charAt(0) !== "$") {
                                if (src[key] && src[key] !== value) {
                                    if (value.length) {
                                        value += (key === "style" ? ";" : " ") + src[key];
                                    } else {
                                        value = src[key];
                                    }
                                }
                                dst.$set(key, value, true, srcAttr[key]);
                            }
                        });
                        forEach(src, function(value, key) {
                            if (!dst.hasOwnProperty(key) && key.charAt(0) !== "$") {
                                dst[key] = value;
                                if (key !== "class" && key !== "style") {
                                    dstAttr[key] = srcAttr[key];
                                }
                            }
                        });
                    }
                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                            templateUrl: null,
                            transclude: null,
                            replace: null,
                            $$originalDirective: origAsyncDirective
                        }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                        $compileNode.empty();
                        $templateRequest(templateUrl).then(function(content) {
                            var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                            content = denormalizeTemplate(content);
                            if (origAsyncDirective.replace) {
                                if (jqLiteIsTextNode(content)) {
                                    $template = [];
                                } else {
                                    $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                                }
                                compileNode = $template[0];
                                if ($template.length !== 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                    throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                }
                                tempTemplateAttrs = {
                                    $attr: {}
                                };
                                replaceWith($rootElement, $compileNode, compileNode);
                                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                if (isObject(origAsyncDirective.scope)) {
                                    markDirectiveScope(templateDirectives, true);
                                }
                                directives = templateDirectives.concat(directives);
                                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else {
                                compileNode = beforeTemplateCompileNode;
                                $compileNode.html(content);
                            }
                            directives.unshift(derivedSyncDirective);
                            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                            forEach($rootElement, function(node, i) {
                                if (node === compileNode) {
                                    $rootElement[i] = $compileNode[0];
                                }
                            });
                            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                            while (linkQueue.length) {
                                var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                if (scope.$$destroyed) continue;
                                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                    var oldClasses = beforeTemplateLinkNode.className;
                                    if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                        linkNode = jqLiteClone(compileNode);
                                    }
                                    replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                                    safeAddClass(jqLite(linkNode), oldClasses);
                                }
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                } else {
                                    childBoundTranscludeFn = boundTranscludeFn;
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                            }
                            linkQueue = null;
                        }).catch(function(error) {
                            if (isError(error)) {
                                $exceptionHandler(error);
                            }
                        });
                        return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            if (scope.$$destroyed) return;
                            if (linkQueue) {
                                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                            } else {
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                            }
                        };
                    }
                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        if (diff !== 0) return diff;
                        if (a.name !== b.name) return a.name < b.name ? -1 : 1;
                        return a.index - b.index;
                    }
                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? " (module: " + moduleName + ")" : "";
                        }
                        if (previousDirective) {
                            throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                        }
                    }
                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, true);
                        if (interpolateFn) {
                            directives.push({
                                priority: 0,
                                compile: function textInterpolateCompileFn(templateNode) {
                                    var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                                    if (hasCompileParent) compile.$$addBindingClass(templateNodeParent);
                                    return function textInterpolateLinkFn(scope, node) {
                                        var parent = node.parent();
                                        if (!hasCompileParent) compile.$$addBindingClass(parent);
                                        compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                        scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                            node[0].nodeValue = value;
                                        });
                                    };
                                }
                            });
                        }
                    }
                    function wrapTemplate(type, template) {
                        type = lowercase(type || "html");
                        switch (type) {
                          case "svg":
                          case "math":
                            var wrapper = window.document.createElement("div");
                            wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">";
                            return wrapper.childNodes[0].childNodes;

                          default:
                            return template;
                        }
                    }
                    function getTrustedContext(node, attrNormalizedName) {
                        if (attrNormalizedName === "srcdoc") {
                            return $sce.HTML;
                        }
                        var tag = nodeName_(node);
                        if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
                            if ([ "img", "video", "audio", "source", "track" ].indexOf(tag) === -1) {
                                return $sce.RESOURCE_URL;
                            }
                        } else if (attrNormalizedName === "xlinkHref" || tag === "form" && attrNormalizedName === "action" || tag === "link" && attrNormalizedName === "href") {
                            return $sce.RESOURCE_URL;
                        }
                    }
                    function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                        var trustedContext = getTrustedContext(node, name);
                        var mustHaveExpression = !isNgAttr;
                        var allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr;
                        var interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                        if (!interpolateFn) return;
                        if (name === "multiple" && nodeName_(node) === "select") {
                            throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                        }
                        if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                            throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                        }
                        directives.push({
                            priority: 100,
                            compile: function() {
                                return {
                                    pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                        var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                        var newValue = attr[name];
                                        if (newValue !== value) {
                                            interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                            value = newValue;
                                        }
                                        if (!interpolateFn) return;
                                        attr[name] = interpolateFn(scope);
                                        ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                        (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                            if (name === "class" && newValue !== oldValue) {
                                                attr.$updateClass(newValue, oldValue);
                                            } else {
                                                attr.$set(name, newValue);
                                            }
                                        });
                                    }
                                };
                            }
                        });
                    }
                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                        if ($rootElement) {
                            for (i = 0, ii = $rootElement.length; i < ii; i++) {
                                if ($rootElement[i] === firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                                    j2++) {
                                        if (j2 < jj) {
                                            $rootElement[j] = $rootElement[j2];
                                        } else {
                                            delete $rootElement[j];
                                        }
                                    }
                                    $rootElement.length -= removeCount - 1;
                                    if ($rootElement.context === firstElementToRemove) {
                                        $rootElement.context = newNode;
                                    }
                                    break;
                                }
                            }
                        }
                        if (parent) {
                            parent.replaceChild(newNode, firstElementToRemove);
                        }
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) {
                            fragment.appendChild(elementsToRemove[i]);
                        }
                        if (jqLite.hasData(firstElementToRemove)) {
                            jqLite.data(newNode, jqLite.data(firstElementToRemove));
                            jqLite(firstElementToRemove).off("$destroy");
                        }
                        jqLite.cleanData(fragment.querySelectorAll("*"));
                        for (i = 1; i < removeCount; i++) {
                            delete elementsToRemove[i];
                        }
                        elementsToRemove[0] = newNode;
                        elementsToRemove.length = 1;
                    }
                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function() {
                            return fn.apply(null, arguments);
                        }, fn, annotation);
                    }
                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function strictBindingsCheck(attrName, directiveName) {
                        if (strictComponentBindingsEnabled) {
                            throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
                        }
                    }
                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        var removeWatchCollection = [];
                        var initialChanges = {};
                        var changes;
                        forEach(bindings, function initializeBinding(definition, scopeName) {
                            var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                            switch (mode) {
                              case "@":
                                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                                    strictBindingsCheck(attrName, directive.name);
                                    destination[scopeName] = attrs[attrName] = undefined;
                                }
                                removeWatch = attrs.$observe(attrName, function(value) {
                                    if (isString(value) || isBoolean(value)) {
                                        var oldValue = destination[scopeName];
                                        recordChanges(scopeName, value, oldValue);
                                        destination[scopeName] = value;
                                    }
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                lastValue = attrs[attrName];
                                if (isString(lastValue)) {
                                    destination[scopeName] = $interpolate(lastValue)(scope);
                                } else if (isBoolean(lastValue)) {
                                    destination[scopeName] = lastValue;
                                }
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "=":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional) break;
                                    strictBindingsCheck(attrName, directive.name);
                                    attrs[attrName] = undefined;
                                }
                                if (optional && !attrs[attrName]) break;
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = simpleCompare;
                                }
                                parentSet = parentGet.assign || function() {
                                    lastValue = destination[scopeName] = parentGet(scope);
                                    throw $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                                };
                                lastValue = destination[scopeName] = parentGet(scope);
                                var parentValueWatch = function parentValueWatch(parentValue) {
                                    if (!compare(parentValue, destination[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            destination[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = destination[scopeName]);
                                        }
                                    }
                                    lastValue = parentValue;
                                    return lastValue;
                                };
                                parentValueWatch.$stateful = true;
                                if (definition.collection) {
                                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                } else {
                                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                }
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "<":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional) break;
                                    strictBindingsCheck(attrName, directive.name);
                                    attrs[attrName] = undefined;
                                }
                                if (optional && !attrs[attrName]) break;
                                parentGet = $parse(attrs[attrName]);
                                var deepWatch = parentGet.literal;
                                var initialValue = destination[scopeName] = parentGet(scope);
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                                    if (oldValue === newValue) {
                                        if (oldValue === initialValue || deepWatch && equals(oldValue, initialValue)) {
                                            return;
                                        }
                                        oldValue = initialValue;
                                    }
                                    recordChanges(scopeName, newValue, oldValue);
                                    destination[scopeName] = newValue;
                                }, deepWatch);
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "&":
                                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                                    strictBindingsCheck(attrName, directive.name);
                                }
                                parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                                if (parentGet === noop && optional) break;
                                destination[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;
                            }
                        });
                        function recordChanges(key, currentValue, previousValue) {
                            if (isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue)) {
                                if (!onChangesQueue) {
                                    scope.$$postDigest(flushOnChangesQueue);
                                    onChangesQueue = [];
                                }
                                if (!changes) {
                                    changes = {};
                                    onChangesQueue.push(triggerOnChangesHook);
                                }
                                if (changes[key]) {
                                    previousValue = changes[key].previousValue;
                                }
                                changes[key] = new SimpleChange(previousValue, currentValue);
                            }
                        }
                        function triggerOnChangesHook() {
                            destination.$onChanges(changes);
                            changes = undefined;
                        }
                        return {
                            initialChanges: initialChanges,
                            removeWatches: removeWatchCollection.length && function removeWatches() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                                    removeWatchCollection[i]();
                                }
                            }
                        };
                    }
                } ];
            }
            function SimpleChange(previous, current) {
                this.previousValue = previous;
                this.currentValue = current;
            }
            SimpleChange.prototype.isFirstChange = function() {
                return this.previousValue === _UNINITIALIZED_VALUE;
            };
            var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
            var SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
            function directiveNormalize(name) {
                return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
                    return offset ? letter.toUpperCase() : letter;
                });
            }
            function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
            function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
            function tokenDifference(str1, str2) {
                var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
                outer: for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token === tokens2[j]) continue outer;
                    }
                    values += (values.length > 0 ? " " : "") + token;
                }
                return values;
            }
            function removeComments(jqNodes) {
                jqNodes = jqLite(jqNodes);
                var i = jqNodes.length;
                if (i <= 1) {
                    return jqNodes;
                }
                while (i--) {
                    var node = jqNodes[i];
                    if (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && node.nodeValue.trim() === "") {
                        splice.call(jqNodes, i, 1);
                    }
                }
                return jqNodes;
            }
            var $controllerMinErr = minErr("$controller");
            var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
            function identifierForController(controller, ident) {
                if (ident && isString(ident)) return ident;
                if (isString(controller)) {
                    var match = CNTRL_REG.exec(controller);
                    if (match) return match[3];
                }
            }
            function $ControllerProvider() {
                var controllers = {}, globals = false;
                this.has = function(name) {
                    return controllers.hasOwnProperty(name);
                };
                this.register = function(name, constructor) {
                    assertNotHasOwnProperty(name, "controller");
                    if (isObject(name)) {
                        extend(controllers, name);
                    } else {
                        controllers[name] = constructor;
                    }
                };
                this.allowGlobals = function() {
                    globals = true;
                };
                this.$get = [ "$injector", "$window", function($injector, $window) {
                    return function $controller(expression, locals, later, ident) {
                        var instance, match, constructor, identifier;
                        later = later === true;
                        if (ident && isString(ident)) {
                            identifier = ident;
                        }
                        if (isString(expression)) {
                            match = expression.match(CNTRL_REG);
                            if (!match) {
                                throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
                            }
                            constructor = match[1];
                            identifier = identifier || match[3];
                            expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                            if (!expression) {
                                throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                            }
                            assertArgFn(expression, constructor, true);
                        }
                        if (later) {
                            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                            instance = Object.create(controllerPrototype || null);
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                            return extend(function $controllerInit() {
                                var result = $injector.invoke(expression, instance, locals, constructor);
                                if (result !== instance && (isObject(result) || isFunction(result))) {
                                    instance = result;
                                    if (identifier) {
                                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                                    }
                                }
                                return instance;
                            }, {
                                instance: instance,
                                identifier: identifier
                            });
                        }
                        instance = $injector.instantiate(expression, locals, constructor);
                        if (identifier) {
                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                        }
                        return instance;
                    };
                    function addIdentifier(locals, identifier, instance, name) {
                        if (!(locals && isObject(locals.$scope))) {
                            throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                        }
                        locals.$scope[identifier] = instance;
                    }
                } ];
            }
            function $DocumentProvider() {
                this.$get = [ "$window", function(window) {
                    return jqLite(window.document);
                } ];
            }
            function $$IsDocumentHiddenProvider() {
                this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
                    var doc = $document[0];
                    var hidden = doc && doc.hidden;
                    $document.on("visibilitychange", changeListener);
                    $rootScope.$on("$destroy", function() {
                        $document.off("visibilitychange", changeListener);
                    });
                    function changeListener() {
                        hidden = doc.hidden;
                    }
                    return function() {
                        return hidden;
                    };
                } ];
            }
            function $ExceptionHandlerProvider() {
                this.$get = [ "$log", function($log) {
                    return function(exception, cause) {
                        $log.error.apply($log, arguments);
                    };
                } ];
            }
            var $$ForceReflowProvider = function() {
                this.$get = [ "$document", function($document) {
                    return function(domNode) {
                        if (domNode) {
                            if (!domNode.nodeType && domNode instanceof jqLite) {
                                domNode = domNode[0];
                            }
                        } else {
                            domNode = $document[0].body;
                        }
                        return domNode.offsetWidth + 1;
                    };
                } ];
            };
            var APPLICATION_JSON = "application/json";
            var CONTENT_TYPE_APPLICATION_JSON = {
                "Content-Type": APPLICATION_JSON + ";charset=utf-8"
            };
            var JSON_START = /^\[|^\{(?!\{)/;
            var JSON_ENDS = {
                "[": /]$/,
                "{": /}$/
            };
            var JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;
            var $httpMinErr = minErr("$http");
            function serializeValue(v) {
                if (isObject(v)) {
                    return isDate(v) ? v.toISOString() : toJson(v);
                }
                return v;
            }
            function $HttpParamSerializerProvider() {
                this.$get = function() {
                    return function ngParamSerializer(params) {
                        if (!params) return "";
                        var parts = [];
                        forEachSorted(params, function(value, key) {
                            if (value === null || isUndefined(value) || isFunction(value)) return;
                            if (isArray(value)) {
                                forEach(value, function(v) {
                                    parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                                });
                            } else {
                                parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value)));
                            }
                        });
                        return parts.join("&");
                    };
                };
            }
            function $HttpParamSerializerJQLikeProvider() {
                this.$get = function() {
                    return function jQueryLikeParamSerializer(params) {
                        if (!params) return "";
                        var parts = [];
                        serialize(params, "", true);
                        return parts.join("&");
                        function serialize(toSerialize, prefix, topLevel) {
                            if (toSerialize === null || isUndefined(toSerialize)) return;
                            if (isArray(toSerialize)) {
                                forEach(toSerialize, function(value, index) {
                                    serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                                });
                            } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                                forEachSorted(toSerialize, function(value, key) {
                                    serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                                });
                            } else {
                                parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize)));
                            }
                        }
                    };
                };
            }
            function defaultHttpResponseTransform(data, headers) {
                if (isString(data)) {
                    var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                    if (tempData) {
                        var contentType = headers("Content-Type");
                        var hasJsonContentType = contentType && contentType.indexOf(APPLICATION_JSON) === 0;
                        if (hasJsonContentType || isJsonLike(tempData)) {
                            try {
                                data = fromJson(tempData);
                            } catch (e) {
                                if (!hasJsonContentType) {
                                    return data;
                                }
                                throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". ' + 'Parse error: "{1}"', data, e);
                            }
                        }
                    }
                }
                return data;
            }
            function isJsonLike(str) {
                var jsonStart = str.match(JSON_START);
                return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
            }
            function parseHeaders(headers) {
                var parsed = createMap(), i;
                function fillInParsed(key, val) {
                    if (key) {
                        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                    }
                }
                if (isString(headers)) {
                    forEach(headers.split("\n"), function(line) {
                        i = line.indexOf(":");
                        fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                    });
                } else if (isObject(headers)) {
                    forEach(headers, function(headerVal, headerKey) {
                        fillInParsed(lowercase(headerKey), trim(headerVal));
                    });
                }
                return parsed;
            }
            function headersGetter(headers) {
                var headersObj;
                return function(name) {
                    if (!headersObj) headersObj = parseHeaders(headers);
                    if (name) {
                        var value = headersObj[lowercase(name)];
                        if (value === undefined) {
                            value = null;
                        }
                        return value;
                    }
                    return headersObj;
                };
            }
            function transformData(data, headers, status, fns) {
                if (isFunction(fns)) {
                    return fns(data, headers, status);
                }
                forEach(fns, function(fn) {
                    data = fn(data, headers, status);
                });
                return data;
            }
            function isSuccess(status) {
                return 200 <= status && status < 300;
            }
            function $HttpProvider() {
                var defaults = this.defaults = {
                    transformResponse: [ defaultHttpResponseTransform ],
                    transformRequest: [ function(d) {
                        return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
                    } ],
                    headers: {
                        common: {
                            Accept: "application/json, text/plain, */*"
                        },
                        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN",
                    paramSerializer: "$httpParamSerializer",
                    jsonpCallbackParam: "callback"
                };
                var useApplyAsync = false;
                this.useApplyAsync = function(value) {
                    if (isDefined(value)) {
                        useApplyAsync = !!value;
                        return this;
                    }
                    return useApplyAsync;
                };
                var interceptorFactories = this.interceptors = [];
                this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
                    var defaultCache = $cacheFactory("$http");
                    defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                    var reversedInterceptors = [];
                    forEach(interceptorFactories, function(interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                    });
                    function $http(requestConfig) {
                        if (!isObject(requestConfig)) {
                            throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                        }
                        if (!isString($sce.valueOf(requestConfig.url))) {
                            throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                        }
                        var config = extend({
                            method: "get",
                            transformRequest: defaults.transformRequest,
                            transformResponse: defaults.transformResponse,
                            paramSerializer: defaults.paramSerializer,
                            jsonpCallbackParam: defaults.jsonpCallbackParam
                        }, requestConfig);
                        config.headers = mergeHeaders(requestConfig);
                        config.method = uppercase(config.method);
                        config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                        $browser.$$incOutstandingRequestCount();
                        var requestInterceptors = [];
                        var responseInterceptors = [];
                        var promise = $q.resolve(config);
                        forEach(reversedInterceptors, function(interceptor) {
                            if (interceptor.request || interceptor.requestError) {
                                requestInterceptors.unshift(interceptor.request, interceptor.requestError);
                            }
                            if (interceptor.response || interceptor.responseError) {
                                responseInterceptors.push(interceptor.response, interceptor.responseError);
                            }
                        });
                        promise = chainInterceptors(promise, requestInterceptors);
                        promise = promise.then(serverRequest);
                        promise = chainInterceptors(promise, responseInterceptors);
                        promise = promise.finally(completeOutstandingRequest);
                        return promise;
                        function chainInterceptors(promise, interceptors) {
                            for (var i = 0, ii = interceptors.length; i < ii; ) {
                                var thenFn = interceptors[i++];
                                var rejectFn = interceptors[i++];
                                promise = promise.then(thenFn, rejectFn);
                            }
                            interceptors.length = 0;
                            return promise;
                        }
                        function completeOutstandingRequest() {
                            $browser.$$completeOutstandingRequest(noop);
                        }
                        function executeHeaderFns(headers, config) {
                            var headerContent, processedHeaders = {};
                            forEach(headers, function(headerFn, header) {
                                if (isFunction(headerFn)) {
                                    headerContent = headerFn(config);
                                    if (headerContent != null) {
                                        processedHeaders[header] = headerContent;
                                    }
                                } else {
                                    processedHeaders[header] = headerFn;
                                }
                            });
                            return processedHeaders;
                        }
                        function mergeHeaders(config) {
                            var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                            defaultHeadersIteration: for (defHeaderName in defHeaders) {
                                lowercaseDefHeaderName = lowercase(defHeaderName);
                                for (reqHeaderName in reqHeaders) {
                                    if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                        continue defaultHeadersIteration;
                                    }
                                }
                                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                            }
                            return executeHeaderFns(reqHeaders, shallowCopy(config));
                        }
                        function serverRequest(config) {
                            var headers = config.headers;
                            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                            if (isUndefined(reqData)) {
                                forEach(headers, function(value, header) {
                                    if (lowercase(header) === "content-type") {
                                        delete headers[header];
                                    }
                                });
                            }
                            if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                                config.withCredentials = defaults.withCredentials;
                            }
                            return sendReq(config, reqData).then(transformResponse, transformResponse);
                        }
                        function transformResponse(response) {
                            var resp = extend({}, response);
                            resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                            return isSuccess(response.status) ? resp : $q.reject(resp);
                        }
                    }
                    $http.pendingRequests = [];
                    createShortMethods("get", "delete", "head", "jsonp");
                    createShortMethodsWithData("post", "put", "patch");
                    $http.defaults = defaults;
                    return $http;
                    function createShortMethods(names) {
                        forEach(arguments, function(name) {
                            $http[name] = function(url, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url
                                }));
                            };
                        });
                    }
                    function createShortMethodsWithData(name) {
                        forEach(arguments, function(name) {
                            $http[name] = function(url, data, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }));
                            };
                        });
                    }
                    function sendReq(config, reqData) {
                        var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, isJsonp = lowercase(config.method) === "jsonp", url = config.url;
                        if (isJsonp) {
                            url = $sce.getTrustedResourceUrl(url);
                        } else if (!isString(url)) {
                            url = $sce.valueOf(url);
                        }
                        url = buildUrl(url, config.paramSerializer(config.params));
                        if (isJsonp) {
                            url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam);
                        }
                        $http.pendingRequests.push(config);
                        promise.then(removePendingReq, removePendingReq);
                        if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                            cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                        }
                        if (cache) {
                            cachedResp = cache.get(url);
                            if (isDefined(cachedResp)) {
                                if (isPromiseLike(cachedResp)) {
                                    cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                                } else {
                                    if (isArray(cachedResp)) {
                                        resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]);
                                    } else {
                                        resolvePromise(cachedResp, 200, {}, "OK", "complete");
                                    }
                                }
                            } else {
                                cache.put(url, promise);
                            }
                        }
                        if (isUndefined(cachedResp)) {
                            var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                            if (xsrfValue) {
                                reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                            }
                            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                        }
                        return promise;
                        function createApplyHandlers(eventHandlers) {
                            if (eventHandlers) {
                                var applyHandlers = {};
                                forEach(eventHandlers, function(eventHandler, key) {
                                    applyHandlers[key] = function(event) {
                                        if (useApplyAsync) {
                                            $rootScope.$applyAsync(callEventHandler);
                                        } else if ($rootScope.$$phase) {
                                            callEventHandler();
                                        } else {
                                            $rootScope.$apply(callEventHandler);
                                        }
                                        function callEventHandler() {
                                            eventHandler(event);
                                        }
                                    };
                                });
                                return applyHandlers;
                            }
                        }
                        function done(status, response, headersString, statusText, xhrStatus) {
                            if (cache) {
                                if (isSuccess(status)) {
                                    cache.put(url, [ status, response, parseHeaders(headersString), statusText, xhrStatus ]);
                                } else {
                                    cache.remove(url);
                                }
                            }
                            function resolveHttpPromise() {
                                resolvePromise(response, status, headersString, statusText, xhrStatus);
                            }
                            if (useApplyAsync) {
                                $rootScope.$applyAsync(resolveHttpPromise);
                            } else {
                                resolveHttpPromise();
                                if (!$rootScope.$$phase) $rootScope.$apply();
                            }
                        }
                        function resolvePromise(response, status, headers, statusText, xhrStatus) {
                            status = status >= -1 ? status : 0;
                            (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config,
                                statusText: statusText,
                                xhrStatus: xhrStatus
                            });
                        }
                        function resolvePromiseWithResult(result) {
                            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                        }
                        function removePendingReq() {
                            var idx = $http.pendingRequests.indexOf(config);
                            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                        }
                    }
                    function buildUrl(url, serializedParams) {
                        if (serializedParams.length > 0) {
                            url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                        }
                        return url;
                    }
                    function sanitizeJsonpCallbackParam(url, cbKey) {
                        var parts = url.split("?");
                        if (parts.length > 2) {
                            throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                        }
                        var params = parseKeyValue(parts[1]);
                        forEach(params, function(value, key) {
                            if (value === "JSON_CALLBACK") {
                                throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                            }
                            if (key === cbKey) {
                                throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                            }
                        });
                        url += (url.indexOf("?") === -1 ? "?" : "&") + cbKey + "=JSON_CALLBACK";
                        return url;
                    }
                } ];
            }
            function $xhrFactoryProvider() {
                this.$get = function() {
                    return function createXhr() {
                        return new window.XMLHttpRequest();
                    };
                };
            }
            function $HttpBackendProvider() {
                this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
                    return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
                } ];
            }
            function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
                return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                    url = url || $browser.url();
                    if (lowercase(method) === "jsonp") {
                        var callbackPath = callbacks.createCallback(url);
                        var jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                            var response = status === 200 && callbacks.getResponse(callbackPath);
                            completeRequest(callback, status, response, "", text, "complete");
                            callbacks.removeCallback(callbackPath);
                        });
                    } else {
                        var xhr = createXhr(method, url);
                        xhr.open(method, url, true);
                        forEach(headers, function(value, key) {
                            if (isDefined(value)) {
                                xhr.setRequestHeader(key, value);
                            }
                        });
                        xhr.onload = function requestLoaded() {
                            var statusText = xhr.statusText || "";
                            var response = "response" in xhr ? xhr.response : xhr.responseText;
                            var status = xhr.status === 1223 ? 204 : xhr.status;
                            if (status === 0) {
                                status = response ? 200 : urlResolve(url).protocol === "file" ? 404 : 0;
                            }
                            completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
                        };
                        var requestError = function() {
                            completeRequest(callback, -1, null, null, "", "error");
                        };
                        var requestAborted = function() {
                            completeRequest(callback, -1, null, null, "", "abort");
                        };
                        var requestTimeout = function() {
                            completeRequest(callback, -1, null, null, "", "timeout");
                        };
                        xhr.onerror = requestError;
                        xhr.onabort = requestAborted;
                        xhr.ontimeout = requestTimeout;
                        forEach(eventHandlers, function(value, key) {
                            xhr.addEventListener(key, value);
                        });
                        forEach(uploadEventHandlers, function(value, key) {
                            xhr.upload.addEventListener(key, value);
                        });
                        if (withCredentials) {
                            xhr.withCredentials = true;
                        }
                        if (responseType) {
                            try {
                                xhr.responseType = responseType;
                            } catch (e) {
                                if (responseType !== "json") {
                                    throw e;
                                }
                            }
                        }
                        xhr.send(isUndefined(post) ? null : post);
                    }
                    if (timeout > 0) {
                        var timeoutId = $browserDefer(timeoutRequest, timeout);
                    } else if (isPromiseLike(timeout)) {
                        timeout.then(timeoutRequest);
                    }
                    function timeoutRequest() {
                        if (jsonpDone) {
                            jsonpDone();
                        }
                        if (xhr) {
                            xhr.abort();
                        }
                    }
                    function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                        if (isDefined(timeoutId)) {
                            $browserDefer.cancel(timeoutId);
                        }
                        jsonpDone = xhr = null;
                        callback(status, response, headersString, statusText, xhrStatus);
                    }
                };
                function jsonpReq(url, callbackPath, done) {
                    url = url.replace("JSON_CALLBACK", callbackPath);
                    var script = rawDocument.createElement("script"), callback = null;
                    script.type = "text/javascript";
                    script.src = url;
                    script.async = true;
                    callback = function(event) {
                        script.removeEventListener("load", callback);
                        script.removeEventListener("error", callback);
                        rawDocument.body.removeChild(script);
                        script = null;
                        var status = -1;
                        var text = "unknown";
                        if (event) {
                            if (event.type === "load" && !callbacks.wasCalled(callbackPath)) {
                                event = {
                                    type: "error"
                                };
                            }
                            text = event.type;
                            status = event.type === "error" ? 404 : 200;
                        }
                        if (done) {
                            done(status, text);
                        }
                    };
                    script.addEventListener("load", callback);
                    script.addEventListener("error", callback);
                    rawDocument.body.appendChild(script);
                    return callback;
                }
            }
            var $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
            $interpolateMinErr.throwNoconcat = function(text) {
                throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
            };
            $interpolateMinErr.interr = function(text, err) {
                return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
            };
            function $InterpolateProvider() {
                var startSymbol = "{{";
                var endSymbol = "}}";
                this.startSymbol = function(value) {
                    if (value) {
                        startSymbol = value;
                        return this;
                    } else {
                        return startSymbol;
                    }
                };
                this.endSymbol = function(value) {
                    if (value) {
                        endSymbol = value;
                        return this;
                    } else {
                        return endSymbol;
                    }
                };
                this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
                    var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                    function escape(ch) {
                        return "\\\\\\" + ch;
                    }
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                        var unwatch = scope.$watch(function constantInterpolateWatch(scope) {
                            unwatch();
                            return constantInterp(scope);
                        }, listener, objectEquality);
                        return unwatch;
                    }
                    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                        if (!text.length || text.indexOf(startSymbol) === -1) {
                            var constantInterp;
                            if (!mustHaveExpression) {
                                var unescapedText = unescapeText(text);
                                constantInterp = valueFn(unescapedText);
                                constantInterp.exp = text;
                                constantInterp.expressions = [];
                                constantInterp.$$watchDelegate = constantWatchDelegate;
                            }
                            return constantInterp;
                        }
                        allOrNothing = !!allOrNothing;
                        var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                        while (index < textLength) {
                            if ((startIndex = text.indexOf(startSymbol, index)) !== -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) !== -1) {
                                if (index !== startIndex) {
                                    concat.push(unescapeText(text.substring(index, startIndex)));
                                }
                                exp = text.substring(startIndex + startSymbolLength, endIndex);
                                expressions.push(exp);
                                parseFns.push($parse(exp, parseStringifyInterceptor));
                                index = endIndex + endSymbolLength;
                                expressionPositions.push(concat.length);
                                concat.push("");
                            } else {
                                if (index !== textLength) {
                                    concat.push(unescapeText(text.substring(index)));
                                }
                                break;
                            }
                        }
                        if (trustedContext && concat.length > 1) {
                            $interpolateMinErr.throwNoconcat(text);
                        }
                        if (!mustHaveExpression || expressions.length) {
                            var compute = function(values) {
                                for (var i = 0, ii = expressions.length; i < ii; i++) {
                                    if (allOrNothing && isUndefined(values[i])) return;
                                    concat[expressionPositions[i]] = values[i];
                                }
                                return concat.join("");
                            };
                            var getValue = function(value) {
                                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                            };
                            return extend(function interpolationFn(context) {
                                var i = 0;
                                var ii = expressions.length;
                                var values = new Array(ii);
                                try {
                                    for (;i < ii; i++) {
                                        values[i] = parseFns[i](context);
                                    }
                                    return compute(values);
                                } catch (err) {
                                    $exceptionHandler($interpolateMinErr.interr(text, err));
                                }
                            }, {
                                exp: text,
                                expressions: expressions,
                                $$watchDelegate: function(scope, listener) {
                                    var lastValue;
                                    return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                        var currValue = compute(values);
                                        listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                        lastValue = currValue;
                                    });
                                }
                            });
                        }
                        function parseStringifyInterceptor(value) {
                            try {
                                value = getValue(value);
                                return allOrNothing && !isDefined(value) ? value : stringify(value);
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err));
                            }
                        }
                    }
                    $interpolate.startSymbol = function() {
                        return startSymbol;
                    };
                    $interpolate.endSymbol = function() {
                        return endSymbol;
                    };
                    return $interpolate;
                } ];
            }
            function $IntervalProvider() {
                this.$get = [ "$rootScope", "$window", "$q", "$$q", "$browser", function($rootScope, $window, $q, $$q, $browser) {
                    var intervals = {};
                    function interval(fn, delay, count, invokeApply) {
                        var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                        count = isDefined(count) ? count : 0;
                        promise.$$intervalId = setInterval(function tick() {
                            if (skipApply) {
                                $browser.defer(callback);
                            } else {
                                $rootScope.$evalAsync(callback);
                            }
                            deferred.notify(iteration++);
                            if (count > 0 && iteration >= count) {
                                deferred.resolve(iteration);
                                clearInterval(promise.$$intervalId);
                                delete intervals[promise.$$intervalId];
                            }
                            if (!skipApply) $rootScope.$apply();
                        }, delay);
                        intervals[promise.$$intervalId] = deferred;
                        return promise;
                        function callback() {
                            if (!hasParams) {
                                fn(iteration);
                            } else {
                                fn.apply(null, args);
                            }
                        }
                    }
                    interval.cancel = function(promise) {
                        if (promise && promise.$$intervalId in intervals) {
                            markQExceptionHandled(intervals[promise.$$intervalId].promise);
                            intervals[promise.$$intervalId].reject("canceled");
                            $window.clearInterval(promise.$$intervalId);
                            delete intervals[promise.$$intervalId];
                            return true;
                        }
                        return false;
                    };
                    return interval;
                } ];
            }
            var $jsonpCallbacksProvider = function() {
                this.$get = function() {
                    var callbacks = angular.callbacks;
                    var callbackMap = {};
                    function createCallback(callbackId) {
                        var callback = function(data) {
                            callback.data = data;
                            callback.called = true;
                        };
                        callback.id = callbackId;
                        return callback;
                    }
                    return {
                        createCallback: function(url) {
                            var callbackId = "_" + (callbacks.$$counter++).toString(36);
                            var callbackPath = "angular.callbacks." + callbackId;
                            var callback = createCallback(callbackId);
                            callbackMap[callbackPath] = callbacks[callbackId] = callback;
                            return callbackPath;
                        },
                        wasCalled: function(callbackPath) {
                            return callbackMap[callbackPath].called;
                        },
                        getResponse: function(callbackPath) {
                            return callbackMap[callbackPath].data;
                        },
                        removeCallback: function(callbackPath) {
                            var callback = callbackMap[callbackPath];
                            delete callbacks[callback.id];
                            delete callbackMap[callbackPath];
                        }
                    };
                };
            };
            var PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
                http: 80,
                https: 443,
                ftp: 21
            };
            var $locationMinErr = minErr("$location");
            function encodePath(path) {
                var segments = path.split("/"), i = segments.length;
                while (i--) {
                    segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
                }
                return segments.join("/");
            }
            function decodePath(path, html5Mode) {
                var segments = path.split("/"), i = segments.length;
                while (i--) {
                    segments[i] = decodeURIComponent(segments[i]);
                    if (html5Mode) {
                        segments[i] = segments[i].replace(/\//g, "%2F");
                    }
                }
                return segments.join("/");
            }
            function parseAbsoluteUrl(absoluteUrl, locationObj) {
                var parsedUrl = urlResolve(absoluteUrl);
                locationObj.$$protocol = parsedUrl.protocol;
                locationObj.$$host = parsedUrl.hostname;
                locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
            }
            var DOUBLE_SLASH_REGEX = /^\s*[\\\/]{2,}/;
            function parseAppUrl(url, locationObj, html5Mode) {
                if (DOUBLE_SLASH_REGEX.test(url)) {
                    throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
                }
                var prefixed = url.charAt(0) !== "/";
                if (prefixed) {
                    url = "/" + url;
                }
                var match = urlResolve(url);
                var path = prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname;
                locationObj.$$path = decodePath(path, html5Mode);
                locationObj.$$search = parseKeyValue(match.search);
                locationObj.$$hash = decodeURIComponent(match.hash);
                if (locationObj.$$path && locationObj.$$path.charAt(0) !== "/") {
                    locationObj.$$path = "/" + locationObj.$$path;
                }
            }
            function startsWith(str, search) {
                return str.slice(0, search.length) === search;
            }
            function stripBaseUrl(base, url) {
                if (startsWith(url, base)) {
                    return url.substr(base.length);
                }
            }
            function stripHash(url) {
                var index = url.indexOf("#");
                return index === -1 ? url : url.substr(0, index);
            }
            function trimEmptyHash(url) {
                return url.replace(/(#.+)|#$/, "$1");
            }
            function stripFile(url) {
                return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
            }
            function serverBase(url) {
                return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
            }
            function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
                this.$$html5 = true;
                basePrefix = basePrefix || "";
                parseAbsoluteUrl(appBase, this);
                this.$$parse = function(url) {
                    var pathUrl = stripBaseUrl(appBaseNoFile, url);
                    if (!isString(pathUrl)) {
                        throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                    }
                    parseAppUrl(pathUrl, this, true);
                    if (!this.$$path) {
                        this.$$path = "/";
                    }
                    this.$$compose();
                };
                this.$$compose = function() {
                    var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                    this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
                    this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
                    this.$$urlUpdatedByLocation = true;
                };
                this.$$parseLinkUrl = function(url, relHref) {
                    if (relHref && relHref[0] === "#") {
                        this.hash(relHref.slice(1));
                        return true;
                    }
                    var appUrl, prevAppUrl;
                    var rewrittenUrl;
                    if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
                        prevAppUrl = appUrl;
                        if (basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
                            rewrittenUrl = appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
                        } else {
                            rewrittenUrl = appBase + prevAppUrl;
                        }
                    } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
                        rewrittenUrl = appBaseNoFile + appUrl;
                    } else if (appBaseNoFile === url + "/") {
                        rewrittenUrl = appBaseNoFile;
                    }
                    if (rewrittenUrl) {
                        this.$$parse(rewrittenUrl);
                    }
                    return !!rewrittenUrl;
                };
            }
            function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
                parseAbsoluteUrl(appBase, this);
                this.$$parse = function(url) {
                    var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                    var withoutHashUrl;
                    if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
                        withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
                        if (isUndefined(withoutHashUrl)) {
                            withoutHashUrl = withoutBaseUrl;
                        }
                    } else {
                        if (this.$$html5) {
                            withoutHashUrl = withoutBaseUrl;
                        } else {
                            withoutHashUrl = "";
                            if (isUndefined(withoutBaseUrl)) {
                                appBase = url;
                                this.replace();
                            }
                        }
                    }
                    parseAppUrl(withoutHashUrl, this, false);
                    this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
                    this.$$compose();
                    function removeWindowsDriveName(path, url, base) {
                        var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                        var firstPathSegmentMatch;
                        if (startsWith(url, base)) {
                            url = url.replace(base, "");
                        }
                        if (windowsFilePathExp.exec(url)) {
                            return path;
                        }
                        firstPathSegmentMatch = windowsFilePathExp.exec(path);
                        return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
                    }
                };
                this.$$compose = function() {
                    var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                    this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
                    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
                    this.$$urlUpdatedByLocation = true;
                };
                this.$$parseLinkUrl = function(url, relHref) {
                    if (stripHash(appBase) === stripHash(url)) {
                        this.$$parse(url);
                        return true;
                    }
                    return false;
                };
            }
            function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
                this.$$html5 = true;
                LocationHashbangUrl.apply(this, arguments);
                this.$$parseLinkUrl = function(url, relHref) {
                    if (relHref && relHref[0] === "#") {
                        this.hash(relHref.slice(1));
                        return true;
                    }
                    var rewrittenUrl;
                    var appUrl;
                    if (appBase === stripHash(url)) {
                        rewrittenUrl = url;
                    } else if (appUrl = stripBaseUrl(appBaseNoFile, url)) {
                        rewrittenUrl = appBase + hashPrefix + appUrl;
                    } else if (appBaseNoFile === url + "/") {
                        rewrittenUrl = appBaseNoFile;
                    }
                    if (rewrittenUrl) {
                        this.$$parse(rewrittenUrl);
                    }
                    return !!rewrittenUrl;
                };
                this.$$compose = function() {
                    var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                    this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash;
                    this.$$absUrl = appBase + hashPrefix + this.$$url;
                    this.$$urlUpdatedByLocation = true;
                };
            }
            var locationPrototype = {
                $$absUrl: "",
                $$html5: false,
                $$replace: false,
                absUrl: locationGetter("$$absUrl"),
                url: function(url) {
                    if (isUndefined(url)) {
                        return this.$$url;
                    }
                    var match = PATH_MATCH.exec(url);
                    if (match[1] || url === "") this.path(decodeURIComponent(match[1]));
                    if (match[2] || match[1] || url === "") this.search(match[3] || "");
                    this.hash(match[5] || "");
                    return this;
                },
                protocol: locationGetter("$$protocol"),
                host: locationGetter("$$host"),
                port: locationGetter("$$port"),
                path: locationGetterSetter("$$path", function(path) {
                    path = path !== null ? path.toString() : "";
                    return path.charAt(0) === "/" ? path : "/" + path;
                }),
                search: function(search, paramValue) {
                    switch (arguments.length) {
                      case 0:
                        return this.$$search;

                      case 1:
                        if (isString(search) || isNumber(search)) {
                            search = search.toString();
                            this.$$search = parseKeyValue(search);
                        } else if (isObject(search)) {
                            search = copy(search, {});
                            forEach(search, function(value, key) {
                                if (value == null) delete search[key];
                            });
                            this.$$search = search;
                        } else {
                            throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                        }
                        break;

                      default:
                        if (isUndefined(paramValue) || paramValue === null) {
                            delete this.$$search[search];
                        } else {
                            this.$$search[search] = paramValue;
                        }
                    }
                    this.$$compose();
                    return this;
                },
                hash: locationGetterSetter("$$hash", function(hash) {
                    return hash !== null ? hash.toString() : "";
                }),
                replace: function() {
                    this.$$replace = true;
                    return this;
                }
            };
            forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
                Location.prototype = Object.create(locationPrototype);
                Location.prototype.state = function(state) {
                    if (!arguments.length) {
                        return this.$$state;
                    }
                    if (Location !== LocationHtml5Url || !this.$$html5) {
                        throw $locationMinErr("nostate", "History API state support is available only " + "in HTML5 mode and only in browsers supporting HTML5 History API");
                    }
                    this.$$state = isUndefined(state) ? null : state;
                    this.$$urlUpdatedByLocation = true;
                    return this;
                };
            });
            function locationGetter(property) {
                return function() {
                    return this[property];
                };
            }
            function locationGetterSetter(property, preprocess) {
                return function(value) {
                    if (isUndefined(value)) {
                        return this[property];
                    }
                    this[property] = preprocess(value);
                    this.$$compose();
                    return this;
                };
            }
            function $LocationProvider() {
                var hashPrefix = "!", html5Mode = {
                    enabled: false,
                    requireBase: true,
                    rewriteLinks: true
                };
                this.hashPrefix = function(prefix) {
                    if (isDefined(prefix)) {
                        hashPrefix = prefix;
                        return this;
                    } else {
                        return hashPrefix;
                    }
                };
                this.html5Mode = function(mode) {
                    if (isBoolean(mode)) {
                        html5Mode.enabled = mode;
                        return this;
                    } else if (isObject(mode)) {
                        if (isBoolean(mode.enabled)) {
                            html5Mode.enabled = mode.enabled;
                        }
                        if (isBoolean(mode.requireBase)) {
                            html5Mode.requireBase = mode.requireBase;
                        }
                        if (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) {
                            html5Mode.rewriteLinks = mode.rewriteLinks;
                        }
                        return this;
                    } else {
                        return html5Mode;
                    }
                };
                this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
                    var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
                    if (html5Mode.enabled) {
                        if (!baseHref && html5Mode.requireBase) {
                            throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                        }
                        appBase = serverBase(initialUrl) + (baseHref || "/");
                        LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                    } else {
                        appBase = stripHash(initialUrl);
                        LocationMode = LocationHashbangUrl;
                    }
                    var appBaseNoFile = stripFile(appBase);
                    $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix);
                    $location.$$parseLinkUrl(initialUrl, initialUrl);
                    $location.$$state = $browser.state();
                    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                    function setBrowserUrlWithFallback(url, replace, state) {
                        var oldUrl = $location.url();
                        var oldState = $location.$$state;
                        try {
                            $browser.url(url, replace, state);
                            $location.$$state = $browser.state();
                        } catch (e) {
                            $location.url(oldUrl);
                            $location.$$state = oldState;
                            throw e;
                        }
                    }
                    $rootElement.on("click", function(event) {
                        var rewriteLinks = html5Mode.rewriteLinks;
                        if (!rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which === 2 || event.button === 2) return;
                        var elm = jqLite(event.target);
                        while (nodeName_(elm[0]) !== "a") {
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                        }
                        if (isString(rewriteLinks) && isUndefined(elm.attr(rewriteLinks))) return;
                        var absHref = elm.prop("href");
                        var relHref = elm.attr("href") || elm.attr("xlink:href");
                        if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                            absHref = urlResolve(absHref.animVal).href;
                        }
                        if (IGNORE_URI_REGEXP.test(absHref)) return;
                        if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                            if ($location.$$parseLinkUrl(absHref, relHref)) {
                                event.preventDefault();
                                if ($location.absUrl() !== $browser.url()) {
                                    $rootScope.$apply();
                                    $window.angular["ff-684208-preventDefault"] = true;
                                }
                            }
                        }
                    });
                    if (trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl)) {
                        $browser.url($location.absUrl(), true);
                    }
                    var initializing = true;
                    $browser.onUrlChange(function(newUrl, newState) {
                        if (!startsWith(newUrl, appBaseNoFile)) {
                            $window.location.href = newUrl;
                            return;
                        }
                        $rootScope.$evalAsync(function() {
                            var oldUrl = $location.absUrl();
                            var oldState = $location.$$state;
                            var defaultPrevented;
                            newUrl = trimEmptyHash(newUrl);
                            $location.$$parse(newUrl);
                            $location.$$state = newState;
                            defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented;
                            if ($location.absUrl() !== newUrl) return;
                            if (defaultPrevented) {
                                $location.$$parse(oldUrl);
                                $location.$$state = oldState;
                                setBrowserUrlWithFallback(oldUrl, false, oldState);
                            } else {
                                initializing = false;
                                afterLocationChange(oldUrl, oldState);
                            }
                        });
                        if (!$rootScope.$$phase) $rootScope.$digest();
                    });
                    $rootScope.$watch(function $locationWatch() {
                        if (initializing || $location.$$urlUpdatedByLocation) {
                            $location.$$urlUpdatedByLocation = false;
                            var oldUrl = trimEmptyHash($browser.url());
                            var newUrl = trimEmptyHash($location.absUrl());
                            var oldState = $browser.state();
                            var currentReplace = $location.$$replace;
                            var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                            if (initializing || urlOrStateChanged) {
                                initializing = false;
                                $rootScope.$evalAsync(function() {
                                    var newUrl = $location.absUrl();
                                    var defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                    if ($location.absUrl() !== newUrl) return;
                                    if (defaultPrevented) {
                                        $location.$$parse(oldUrl);
                                        $location.$$state = oldState;
                                    } else {
                                        if (urlOrStateChanged) {
                                            setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                        }
                                        afterLocationChange(oldUrl, oldState);
                                    }
                                });
                            }
                        }
                        $location.$$replace = false;
                    });
                    return $location;
                    function afterLocationChange(oldUrl, oldState) {
                        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
                    }
                } ];
            }
            function $LogProvider() {
                var debug = true, self = this;
                this.debugEnabled = function(flag) {
                    if (isDefined(flag)) {
                        debug = flag;
                        return this;
                    } else {
                        return debug;
                    }
                };
                this.$get = [ "$window", function($window) {
                    var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
                    return {
                        log: consoleLog("log"),
                        info: consoleLog("info"),
                        warn: consoleLog("warn"),
                        error: consoleLog("error"),
                        debug: function() {
                            var fn = consoleLog("debug");
                            return function() {
                                if (debug) {
                                    fn.apply(self, arguments);
                                }
                            };
                        }()
                    };
                    function formatError(arg) {
                        if (isError(arg)) {
                            if (arg.stack && formatStackTrace) {
                                arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack;
                            } else if (arg.sourceURL) {
                                arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line;
                            }
                        }
                        return arg;
                    }
                    function consoleLog(type) {
                        var console = $window.console || {}, logFn = console[type] || console.log || noop;
                        return function() {
                            var args = [];
                            forEach(arguments, function(arg) {
                                args.push(formatError(arg));
                            });
                            return Function.prototype.apply.call(logFn, console, args);
                        };
                    }
                } ];
            }
            var $parseMinErr = minErr("$parse");
            var objectValueOf = {}.constructor.prototype.valueOf;
            function getStringValue(name) {
                return name + "";
            }
            var OPERATORS = createMap();
            forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
                OPERATORS[operator] = true;
            });
            var ESCAPE = {
                n: "\n",
                f: "\f",
                r: "\r",
                t: "\t",
                v: "\v",
                "'": "'",
                '"': '"'
            };
            var Lexer = function Lexer(options) {
                this.options = options;
            };
            Lexer.prototype = {
                constructor: Lexer,
                lex: function(text) {
                    this.text = text;
                    this.index = 0;
                    this.tokens = [];
                    while (this.index < this.text.length) {
                        var ch = this.text.charAt(this.index);
                        if (ch === '"' || ch === "'") {
                            this.readString(ch);
                        } else if (this.isNumber(ch) || ch === "." && this.isNumber(this.peek())) {
                            this.readNumber();
                        } else if (this.isIdentifierStart(this.peekMultichar())) {
                            this.readIdent();
                        } else if (this.is(ch, "(){}[].,;:?")) {
                            this.tokens.push({
                                index: this.index,
                                text: ch
                            });
                            this.index++;
                        } else if (this.isWhitespace(ch)) {
                            this.index++;
                        } else {
                            var ch2 = ch + this.peek();
                            var ch3 = ch2 + this.peek(2);
                            var op1 = OPERATORS[ch];
                            var op2 = OPERATORS[ch2];
                            var op3 = OPERATORS[ch3];
                            if (op1 || op2 || op3) {
                                var token = op3 ? ch3 : op2 ? ch2 : ch;
                                this.tokens.push({
                                    index: this.index,
                                    text: token,
                                    operator: true
                                });
                                this.index += token.length;
                            } else {
                                this.throwError("Unexpected next character ", this.index, this.index + 1);
                            }
                        }
                    }
                    return this.tokens;
                },
                is: function(ch, chars) {
                    return chars.indexOf(ch) !== -1;
                },
                peek: function(i) {
                    var num = i || 1;
                    return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
                },
                isNumber: function(ch) {
                    return "0" <= ch && ch <= "9" && typeof ch === "string";
                },
                isWhitespace: function(ch) {
                    return ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\v" || ch === " ";
                },
                isIdentifierStart: function(ch) {
                    return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
                },
                isValidIdentifierStart: function(ch) {
                    return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$";
                },
                isIdentifierContinue: function(ch) {
                    return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
                },
                isValidIdentifierContinue: function(ch, cp) {
                    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
                },
                codePointAt: function(ch) {
                    if (ch.length === 1) return ch.charCodeAt(0);
                    return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
                },
                peekMultichar: function() {
                    var ch = this.text.charAt(this.index);
                    var peek = this.peek();
                    if (!peek) {
                        return ch;
                    }
                    var cp1 = ch.charCodeAt(0);
                    var cp2 = peek.charCodeAt(0);
                    if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
                        return ch + peek;
                    }
                    return ch;
                },
                isExpOperator: function(ch) {
                    return ch === "-" || ch === "+" || this.isNumber(ch);
                },
                throwError: function(error, start, end) {
                    end = end || this.index;
                    var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                    throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
                },
                readNumber: function() {
                    var number = "";
                    var start = this.index;
                    while (this.index < this.text.length) {
                        var ch = lowercase(this.text.charAt(this.index));
                        if (ch === "." || this.isNumber(ch)) {
                            number += ch;
                        } else {
                            var peekCh = this.peek();
                            if (ch === "e" && this.isExpOperator(peekCh)) {
                                number += ch;
                            } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) === "e") {
                                number += ch;
                            } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) === "e") {
                                this.throwError("Invalid exponent");
                            } else {
                                break;
                            }
                        }
                        this.index++;
                    }
                    this.tokens.push({
                        index: start,
                        text: number,
                        constant: true,
                        value: Number(number)
                    });
                },
                readIdent: function() {
                    var start = this.index;
                    this.index += this.peekMultichar().length;
                    while (this.index < this.text.length) {
                        var ch = this.peekMultichar();
                        if (!this.isIdentifierContinue(ch)) {
                            break;
                        }
                        this.index += ch.length;
                    }
                    this.tokens.push({
                        index: start,
                        text: this.text.slice(start, this.index),
                        identifier: true
                    });
                },
                readString: function(quote) {
                    var start = this.index;
                    this.index++;
                    var string = "";
                    var rawString = quote;
                    var escape = false;
                    while (this.index < this.text.length) {
                        var ch = this.text.charAt(this.index);
                        rawString += ch;
                        if (escape) {
                            if (ch === "u") {
                                var hex = this.text.substring(this.index + 1, this.index + 5);
                                if (!hex.match(/[\da-f]{4}/i)) {
                                    this.throwError("Invalid unicode escape [\\u" + hex + "]");
                                }
                                this.index += 4;
                                string += String.fromCharCode(parseInt(hex, 16));
                            } else {
                                var rep = ESCAPE[ch];
                                string = string + (rep || ch);
                            }
                            escape = false;
                        } else if (ch === "\\") {
                            escape = true;
                        } else if (ch === quote) {
                            this.index++;
                            this.tokens.push({
                                index: start,
                                text: rawString,
                                constant: true,
                                value: string
                            });
                            return;
                        } else {
                            string += ch;
                        }
                        this.index++;
                    }
                    this.throwError("Unterminated quote", start);
                }
            };
            var AST = function AST(lexer, options) {
                this.lexer = lexer;
                this.options = options;
            };
            AST.Program = "Program";
            AST.ExpressionStatement = "ExpressionStatement";
            AST.AssignmentExpression = "AssignmentExpression";
            AST.ConditionalExpression = "ConditionalExpression";
            AST.LogicalExpression = "LogicalExpression";
            AST.BinaryExpression = "BinaryExpression";
            AST.UnaryExpression = "UnaryExpression";
            AST.CallExpression = "CallExpression";
            AST.MemberExpression = "MemberExpression";
            AST.Identifier = "Identifier";
            AST.Literal = "Literal";
            AST.ArrayExpression = "ArrayExpression";
            AST.Property = "Property";
            AST.ObjectExpression = "ObjectExpression";
            AST.ThisExpression = "ThisExpression";
            AST.LocalsExpression = "LocalsExpression";
            AST.NGValueParameter = "NGValueParameter";
            AST.prototype = {
                ast: function(text) {
                    this.text = text;
                    this.tokens = this.lexer.lex(text);
                    var value = this.program();
                    if (this.tokens.length !== 0) {
                        this.throwError("is an unexpected token", this.tokens[0]);
                    }
                    return value;
                },
                program: function() {
                    var body = [];
                    while (true) {
                        if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) body.push(this.expressionStatement());
                        if (!this.expect(";")) {
                            return {
                                type: AST.Program,
                                body: body
                            };
                        }
                    }
                },
                expressionStatement: function() {
                    return {
                        type: AST.ExpressionStatement,
                        expression: this.filterChain()
                    };
                },
                filterChain: function() {
                    var left = this.expression();
                    while (this.expect("|")) {
                        left = this.filter(left);
                    }
                    return left;
                },
                expression: function() {
                    return this.assignment();
                },
                assignment: function() {
                    var result = this.ternary();
                    if (this.expect("=")) {
                        if (!isAssignable(result)) {
                            throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                        }
                        result = {
                            type: AST.AssignmentExpression,
                            left: result,
                            right: this.assignment(),
                            operator: "="
                        };
                    }
                    return result;
                },
                ternary: function() {
                    var test = this.logicalOR();
                    var alternate;
                    var consequent;
                    if (this.expect("?")) {
                        alternate = this.expression();
                        if (this.consume(":")) {
                            consequent = this.expression();
                            return {
                                type: AST.ConditionalExpression,
                                test: test,
                                alternate: alternate,
                                consequent: consequent
                            };
                        }
                    }
                    return test;
                },
                logicalOR: function() {
                    var left = this.logicalAND();
                    while (this.expect("||")) {
                        left = {
                            type: AST.LogicalExpression,
                            operator: "||",
                            left: left,
                            right: this.logicalAND()
                        };
                    }
                    return left;
                },
                logicalAND: function() {
                    var left = this.equality();
                    while (this.expect("&&")) {
                        left = {
                            type: AST.LogicalExpression,
                            operator: "&&",
                            left: left,
                            right: this.equality()
                        };
                    }
                    return left;
                },
                equality: function() {
                    var left = this.relational();
                    var token;
                    while (token = this.expect("==", "!=", "===", "!==")) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.relational()
                        };
                    }
                    return left;
                },
                relational: function() {
                    var left = this.additive();
                    var token;
                    while (token = this.expect("<", ">", "<=", ">=")) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.additive()
                        };
                    }
                    return left;
                },
                additive: function() {
                    var left = this.multiplicative();
                    var token;
                    while (token = this.expect("+", "-")) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.multiplicative()
                        };
                    }
                    return left;
                },
                multiplicative: function() {
                    var left = this.unary();
                    var token;
                    while (token = this.expect("*", "/", "%")) {
                        left = {
                            type: AST.BinaryExpression,
                            operator: token.text,
                            left: left,
                            right: this.unary()
                        };
                    }
                    return left;
                },
                unary: function() {
                    var token;
                    if (token = this.expect("+", "-", "!")) {
                        return {
                            type: AST.UnaryExpression,
                            operator: token.text,
                            prefix: true,
                            argument: this.unary()
                        };
                    } else {
                        return this.primary();
                    }
                },
                primary: function() {
                    var primary;
                    if (this.expect("(")) {
                        primary = this.filterChain();
                        this.consume(")");
                    } else if (this.expect("[")) {
                        primary = this.arrayDeclaration();
                    } else if (this.expect("{")) {
                        primary = this.object();
                    } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
                        primary = copy(this.selfReferential[this.consume().text]);
                    } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
                        primary = {
                            type: AST.Literal,
                            value: this.options.literals[this.consume().text]
                        };
                    } else if (this.peek().identifier) {
                        primary = this.identifier();
                    } else if (this.peek().constant) {
                        primary = this.constant();
                    } else {
                        this.throwError("not a primary expression", this.peek());
                    }
                    var next;
                    while (next = this.expect("(", "[", ".")) {
                        if (next.text === "(") {
                            primary = {
                                type: AST.CallExpression,
                                callee: primary,
                                arguments: this.parseArguments()
                            };
                            this.consume(")");
                        } else if (next.text === "[") {
                            primary = {
                                type: AST.MemberExpression,
                                object: primary,
                                property: this.expression(),
                                computed: true
                            };
                            this.consume("]");
                        } else if (next.text === ".") {
                            primary = {
                                type: AST.MemberExpression,
                                object: primary,
                                property: this.identifier(),
                                computed: false
                            };
                        } else {
                            this.throwError("IMPOSSIBLE");
                        }
                    }
                    return primary;
                },
                filter: function(baseExpression) {
                    var args = [ baseExpression ];
                    var result = {
                        type: AST.CallExpression,
                        callee: this.identifier(),
                        arguments: args,
                        filter: true
                    };
                    while (this.expect(":")) {
                        args.push(this.expression());
                    }
                    return result;
                },
                parseArguments: function() {
                    var args = [];
                    if (this.peekToken().text !== ")") {
                        do {
                            args.push(this.filterChain());
                        } while (this.expect(","));
                    }
                    return args;
                },
                identifier: function() {
                    var token = this.consume();
                    if (!token.identifier) {
                        this.throwError("is not a valid identifier", token);
                    }
                    return {
                        type: AST.Identifier,
                        name: token.text
                    };
                },
                constant: function() {
                    return {
                        type: AST.Literal,
                        value: this.consume().value
                    };
                },
                arrayDeclaration: function() {
                    var elements = [];
                    if (this.peekToken().text !== "]") {
                        do {
                            if (this.peek("]")) {
                                break;
                            }
                            elements.push(this.expression());
                        } while (this.expect(","));
                    }
                    this.consume("]");
                    return {
                        type: AST.ArrayExpression,
                        elements: elements
                    };
                },
                object: function() {
                    var properties = [], property;
                    if (this.peekToken().text !== "}") {
                        do {
                            if (this.peek("}")) {
                                break;
                            }
                            property = {
                                type: AST.Property,
                                kind: "init"
                            };
                            if (this.peek().constant) {
                                property.key = this.constant();
                                property.computed = false;
                                this.consume(":");
                                property.value = this.expression();
                            } else if (this.peek().identifier) {
                                property.key = this.identifier();
                                property.computed = false;
                                if (this.peek(":")) {
                                    this.consume(":");
                                    property.value = this.expression();
                                } else {
                                    property.value = property.key;
                                }
                            } else if (this.peek("[")) {
                                this.consume("[");
                                property.key = this.expression();
                                this.consume("]");
                                property.computed = true;
                                this.consume(":");
                                property.value = this.expression();
                            } else {
                                this.throwError("invalid key", this.peek());
                            }
                            properties.push(property);
                        } while (this.expect(","));
                    }
                    this.consume("}");
                    return {
                        type: AST.ObjectExpression,
                        properties: properties
                    };
                },
                throwError: function(msg, token) {
                    throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
                },
                consume: function(e1) {
                    if (this.tokens.length === 0) {
                        throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                    }
                    var token = this.expect(e1);
                    if (!token) {
                        this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
                    }
                    return token;
                },
                peekToken: function() {
                    if (this.tokens.length === 0) {
                        throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                    }
                    return this.tokens[0];
                },
                peek: function(e1, e2, e3, e4) {
                    return this.peekAhead(0, e1, e2, e3, e4);
                },
                peekAhead: function(i, e1, e2, e3, e4) {
                    if (this.tokens.length > i) {
                        var token = this.tokens[i];
                        var t = token.text;
                        if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                            return token;
                        }
                    }
                    return false;
                },
                expect: function(e1, e2, e3, e4) {
                    var token = this.peek(e1, e2, e3, e4);
                    if (token) {
                        this.tokens.shift();
                        return token;
                    }
                    return false;
                },
                selfReferential: {
                    this: {
                        type: AST.ThisExpression
                    },
                    $locals: {
                        type: AST.LocalsExpression
                    }
                }
            };
            function ifDefined(v, d) {
                return typeof v !== "undefined" ? v : d;
            }
            function plusFn(l, r) {
                if (typeof l === "undefined") return r;
                if (typeof r === "undefined") return l;
                return l + r;
            }
            function isStateless($filter, filterName) {
                var fn = $filter(filterName);
                return !fn.$stateful;
            }
            var PURITY_ABSOLUTE = 1;
            var PURITY_RELATIVE = 2;
            function isPure(node, parentIsPure) {
                switch (node.type) {
                  case AST.MemberExpression:
                    if (node.computed) {
                        return false;
                    }
                    break;

                  case AST.UnaryExpression:
                    return PURITY_ABSOLUTE;

                  case AST.BinaryExpression:
                    return node.operator !== "+" ? PURITY_ABSOLUTE : false;

                  case AST.CallExpression:
                    return false;
                }
                return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;
            }
            function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
                var allConstants;
                var argsToWatch;
                var isStatelessFilter;
                var astIsPure = ast.isPure = isPure(ast, parentIsPure);
                switch (ast.type) {
                  case AST.Program:
                    allConstants = true;
                    forEach(ast.body, function(expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure);
                        allConstants = allConstants && expr.expression.constant;
                    });
                    ast.constant = allConstants;
                    break;

                  case AST.Literal:
                    ast.constant = true;
                    ast.toWatch = [];
                    break;

                  case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter, astIsPure);
                    ast.constant = ast.argument.constant;
                    ast.toWatch = ast.argument.toWatch;
                    break;

                  case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
                    findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;

                  case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
                    findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter, astIsPure);
                    findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure);
                    findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure);
                    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.Identifier:
                    ast.constant = false;
                    ast.toWatch = [ ast ];
                    break;

                  case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter, astIsPure);
                    if (ast.computed) {
                        findConstantAndWatchExpressions(ast.property, $filter, astIsPure);
                    }
                    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.CallExpression:
                    isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;
                    allConstants = isStatelessFilter;
                    argsToWatch = [];
                    forEach(ast.arguments, function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure);
                        allConstants = allConstants && expr.constant;
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    });
                    ast.constant = allConstants;
                    ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
                    break;

                  case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure);
                    findConstantAndWatchExpressions(ast.right, $filter, astIsPure);
                    ast.constant = ast.left.constant && ast.right.constant;
                    ast.toWatch = [ ast ];
                    break;

                  case AST.ArrayExpression:
                    allConstants = true;
                    argsToWatch = [];
                    forEach(ast.elements, function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure);
                        allConstants = allConstants && expr.constant;
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    });
                    ast.constant = allConstants;
                    ast.toWatch = argsToWatch;
                    break;

                  case AST.ObjectExpression:
                    allConstants = true;
                    argsToWatch = [];
                    forEach(ast.properties, function(property) {
                        findConstantAndWatchExpressions(property.value, $filter, astIsPure);
                        allConstants = allConstants && property.value.constant;
                        argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                        if (property.computed) {
                            findConstantAndWatchExpressions(property.key, $filter, false);
                            allConstants = allConstants && property.key.constant;
                            argsToWatch.push.apply(argsToWatch, property.key.toWatch);
                        }
                    });
                    ast.constant = allConstants;
                    ast.toWatch = argsToWatch;
                    break;

                  case AST.ThisExpression:
                    ast.constant = false;
                    ast.toWatch = [];
                    break;

                  case AST.LocalsExpression:
                    ast.constant = false;
                    ast.toWatch = [];
                    break;
                }
            }
            function getInputs(body) {
                if (body.length !== 1) return;
                var lastExpression = body[0].expression;
                var candidate = lastExpression.toWatch;
                if (candidate.length !== 1) return candidate;
                return candidate[0] !== lastExpression ? candidate : undefined;
            }
            function isAssignable(ast) {
                return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
            }
            function assignableAST(ast) {
                if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
                    return {
                        type: AST.AssignmentExpression,
                        left: ast.body[0].expression,
                        right: {
                            type: AST.NGValueParameter
                        },
                        operator: "="
                    };
                }
            }
            function isLiteral(ast) {
                return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
            }
            function isConstant(ast) {
                return ast.constant;
            }
            function ASTCompiler($filter) {
                this.$filter = $filter;
            }
            ASTCompiler.prototype = {
                compile: function(ast) {
                    var self = this;
                    this.state = {
                        nextId: 0,
                        filters: {},
                        fn: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        assign: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        inputs: []
                    };
                    findConstantAndWatchExpressions(ast, self.$filter);
                    var extra = "";
                    var assignable;
                    this.stage = "assign";
                    if (assignable = assignableAST(ast)) {
                        this.state.computing = "assign";
                        var result = this.nextId();
                        this.recurse(assignable, result);
                        this.return_(result);
                        extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
                    }
                    var toWatch = getInputs(ast.body);
                    self.stage = "inputs";
                    forEach(toWatch, function(watch, key) {
                        var fnKey = "fn" + key;
                        self.state[fnKey] = {
                            vars: [],
                            body: [],
                            own: {}
                        };
                        self.state.computing = fnKey;
                        var intoId = self.nextId();
                        self.recurse(watch, intoId);
                        self.return_(intoId);
                        self.state.inputs.push({
                            name: fnKey,
                            isPure: watch.isPure
                        });
                        watch.watchId = key;
                    });
                    this.state.computing = "fn";
                    this.stage = "main";
                    this.recurse(ast);
                    var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;";
                    var fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
                    this.state = this.stage = undefined;
                    return fn;
                },
                USE: "use",
                STRICT: "strict",
                watchFns: function() {
                    var result = [];
                    var inputs = this.state.inputs;
                    var self = this;
                    forEach(inputs, function(input) {
                        result.push("var " + input.name + "=" + self.generateFunction(input.name, "s"));
                        if (input.isPure) {
                            result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
                        }
                    });
                    if (inputs.length) {
                        result.push("fn.inputs=[" + inputs.map(function(i) {
                            return i.name;
                        }).join(",") + "];");
                    }
                    return result.join("");
                },
                generateFunction: function(name, params) {
                    return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
                },
                filterPrefix: function() {
                    var parts = [];
                    var self = this;
                    forEach(this.state.filters, function(id, filter) {
                        parts.push(id + "=$filter(" + self.escape(filter) + ")");
                    });
                    if (parts.length) return "var " + parts.join(",") + ";";
                    return "";
                },
                varsPrefix: function(section) {
                    return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
                },
                body: function(section) {
                    return this.state[section].body.join("");
                },
                recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var left, right, self = this, args, expression, computed;
                    recursionFn = recursionFn || noop;
                    if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                        intoId = intoId || this.nextId();
                        this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                        return;
                    }
                    switch (ast.type) {
                      case AST.Program:
                        forEach(ast.body, function(expression, pos) {
                            self.recurse(expression.expression, undefined, undefined, function(expr) {
                                right = expr;
                            });
                            if (pos !== ast.body.length - 1) {
                                self.current().body.push(right, ";");
                            } else {
                                self.return_(right);
                            }
                        });
                        break;

                      case AST.Literal:
                        expression = this.escape(ast.value);
                        this.assign(intoId, expression);
                        recursionFn(intoId || expression);
                        break;

                      case AST.UnaryExpression:
                        this.recurse(ast.argument, undefined, undefined, function(expr) {
                            right = expr;
                        });
                        expression = ast.operator + "(" + this.ifDefined(right, 0) + ")";
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;

                      case AST.BinaryExpression:
                        this.recurse(ast.left, undefined, undefined, function(expr) {
                            left = expr;
                        });
                        this.recurse(ast.right, undefined, undefined, function(expr) {
                            right = expr;
                        });
                        if (ast.operator === "+") {
                            expression = this.plus(left, right);
                        } else if (ast.operator === "-") {
                            expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                        } else {
                            expression = "(" + left + ")" + ast.operator + "(" + right + ")";
                        }
                        this.assign(intoId, expression);
                        recursionFn(expression);
                        break;

                      case AST.LogicalExpression:
                        intoId = intoId || this.nextId();
                        self.recurse(ast.left, intoId);
                        self.if_(ast.operator === "&&" ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                        recursionFn(intoId);
                        break;

                      case AST.ConditionalExpression:
                        intoId = intoId || this.nextId();
                        self.recurse(ast.test, intoId);
                        self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                        recursionFn(intoId);
                        break;

                      case AST.Identifier:
                        intoId = intoId || this.nextId();
                        if (nameId) {
                            nameId.context = self.stage === "inputs" ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s");
                            nameId.computed = false;
                            nameId.name = ast.name;
                        }
                        self.if_(self.stage === "inputs" || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                            self.if_(self.stage === "inputs" || "s", function() {
                                if (create && create !== 1) {
                                    self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}"));
                                }
                                self.assign(intoId, self.nonComputedMember("s", ast.name));
                            });
                        }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name)));
                        recursionFn(intoId);
                        break;

                      case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId();
                        intoId = intoId || this.nextId();
                        self.recurse(ast.object, left, undefined, function() {
                            self.if_(self.notNull(left), function() {
                                if (ast.computed) {
                                    right = self.nextId();
                                    self.recurse(ast.property, right);
                                    self.getStringValue(right);
                                    if (create && create !== 1) {
                                        self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}"));
                                    }
                                    expression = self.computedMember(left, right);
                                    self.assign(intoId, expression);
                                    if (nameId) {
                                        nameId.computed = true;
                                        nameId.name = right;
                                    }
                                } else {
                                    if (create && create !== 1) {
                                        self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}"));
                                    }
                                    expression = self.nonComputedMember(left, ast.property.name);
                                    self.assign(intoId, expression);
                                    if (nameId) {
                                        nameId.computed = false;
                                        nameId.name = ast.property.name;
                                    }
                                }
                            }, function() {
                                self.assign(intoId, "undefined");
                            });
                            recursionFn(intoId);
                        }, !!create);
                        break;

                      case AST.CallExpression:
                        intoId = intoId || this.nextId();
                        if (ast.filter) {
                            right = self.filter(ast.callee.name);
                            args = [];
                            forEach(ast.arguments, function(expr) {
                                var argument = self.nextId();
                                self.recurse(expr, argument);
                                args.push(argument);
                            });
                            expression = right + "(" + args.join(",") + ")";
                            self.assign(intoId, expression);
                            recursionFn(intoId);
                        } else {
                            right = self.nextId();
                            left = {};
                            args = [];
                            self.recurse(ast.callee, right, left, function() {
                                self.if_(self.notNull(right), function() {
                                    forEach(ast.arguments, function(expr) {
                                        self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function(argument) {
                                            args.push(argument);
                                        });
                                    });
                                    if (left.name) {
                                        expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")";
                                    } else {
                                        expression = right + "(" + args.join(",") + ")";
                                    }
                                    self.assign(intoId, expression);
                                }, function() {
                                    self.assign(intoId, "undefined");
                                });
                                recursionFn(intoId);
                            });
                        }
                        break;

                      case AST.AssignmentExpression:
                        right = this.nextId();
                        left = {};
                        this.recurse(ast.left, undefined, left, function() {
                            self.if_(self.notNull(left.context), function() {
                                self.recurse(ast.right, right);
                                expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                                self.assign(intoId, expression);
                                recursionFn(intoId || expression);
                            });
                        }, 1);
                        break;

                      case AST.ArrayExpression:
                        args = [];
                        forEach(ast.elements, function(expr) {
                            self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function(argument) {
                                args.push(argument);
                            });
                        });
                        expression = "[" + args.join(",") + "]";
                        this.assign(intoId, expression);
                        recursionFn(intoId || expression);
                        break;

                      case AST.ObjectExpression:
                        args = [];
                        computed = false;
                        forEach(ast.properties, function(property) {
                            if (property.computed) {
                                computed = true;
                            }
                        });
                        if (computed) {
                            intoId = intoId || this.nextId();
                            this.assign(intoId, "{}");
                            forEach(ast.properties, function(property) {
                                if (property.computed) {
                                    left = self.nextId();
                                    self.recurse(property.key, left);
                                } else {
                                    left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value;
                                }
                                right = self.nextId();
                                self.recurse(property.value, right);
                                self.assign(self.member(intoId, left, property.computed), right);
                            });
                        } else {
                            forEach(ast.properties, function(property) {
                                self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                                });
                            });
                            expression = "{" + args.join(",") + "}";
                            this.assign(intoId, expression);
                        }
                        recursionFn(intoId || expression);
                        break;

                      case AST.ThisExpression:
                        this.assign(intoId, "s");
                        recursionFn(intoId || "s");
                        break;

                      case AST.LocalsExpression:
                        this.assign(intoId, "l");
                        recursionFn(intoId || "l");
                        break;

                      case AST.NGValueParameter:
                        this.assign(intoId, "v");
                        recursionFn(intoId || "v");
                        break;
                    }
                },
                getHasOwnProperty: function(element, property) {
                    var key = element + "." + property;
                    var own = this.current().own;
                    if (!own.hasOwnProperty(key)) {
                        own[key] = this.nextId(false, element + "&&(" + this.escape(property) + " in " + element + ")");
                    }
                    return own[key];
                },
                assign: function(id, value) {
                    if (!id) return;
                    this.current().body.push(id, "=", value, ";");
                    return id;
                },
                filter: function(filterName) {
                    if (!this.state.filters.hasOwnProperty(filterName)) {
                        this.state.filters[filterName] = this.nextId(true);
                    }
                    return this.state.filters[filterName];
                },
                ifDefined: function(id, defaultValue) {
                    return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
                },
                plus: function(left, right) {
                    return "plus(" + left + "," + right + ")";
                },
                return_: function(id) {
                    this.current().body.push("return ", id, ";");
                },
                if_: function(test, alternate, consequent) {
                    if (test === true) {
                        alternate();
                    } else {
                        var body = this.current().body;
                        body.push("if(", test, "){");
                        alternate();
                        body.push("}");
                        if (consequent) {
                            body.push("else{");
                            consequent();
                            body.push("}");
                        }
                    }
                },
                not: function(expression) {
                    return "!(" + expression + ")";
                },
                isNull: function(expression) {
                    return expression + "==null";
                },
                notNull: function(expression) {
                    return expression + "!=null";
                },
                nonComputedMember: function(left, right) {
                    var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;
                    var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
                    if (SAFE_IDENTIFIER.test(right)) {
                        return left + "." + right;
                    } else {
                        return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
                    }
                },
                computedMember: function(left, right) {
                    return left + "[" + right + "]";
                },
                member: function(left, right, computed) {
                    if (computed) return this.computedMember(left, right);
                    return this.nonComputedMember(left, right);
                },
                getStringValue: function(item) {
                    this.assign(item, "getStringValue(" + item + ")");
                },
                lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var self = this;
                    return function() {
                        self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                    };
                },
                lazyAssign: function(id, value) {
                    var self = this;
                    return function() {
                        self.assign(id, value);
                    };
                },
                stringEscapeRegex: /[^ a-zA-Z0-9]/g,
                stringEscapeFn: function(c) {
                    return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
                },
                escape: function(value) {
                    if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                    if (isNumber(value)) return value.toString();
                    if (value === true) return "true";
                    if (value === false) return "false";
                    if (value === null) return "null";
                    if (typeof value === "undefined") return "undefined";
                    throw $parseMinErr("esc", "IMPOSSIBLE");
                },
                nextId: function(skip, init) {
                    var id = "v" + this.state.nextId++;
                    if (!skip) {
                        this.current().vars.push(id + (init ? "=" + init : ""));
                    }
                    return id;
                },
                current: function() {
                    return this.state[this.state.computing];
                }
            };
            function ASTInterpreter($filter) {
                this.$filter = $filter;
            }
            ASTInterpreter.prototype = {
                compile: function(ast) {
                    var self = this;
                    findConstantAndWatchExpressions(ast, self.$filter);
                    var assignable;
                    var assign;
                    if (assignable = assignableAST(ast)) {
                        assign = this.recurse(assignable);
                    }
                    var toWatch = getInputs(ast.body);
                    var inputs;
                    if (toWatch) {
                        inputs = [];
                        forEach(toWatch, function(watch, key) {
                            var input = self.recurse(watch);
                            input.isPure = watch.isPure;
                            watch.input = input;
                            inputs.push(input);
                            watch.watchId = key;
                        });
                    }
                    var expressions = [];
                    forEach(ast.body, function(expression) {
                        expressions.push(self.recurse(expression.expression));
                    });
                    var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
                        var lastValue;
                        forEach(expressions, function(exp) {
                            lastValue = exp(scope, locals);
                        });
                        return lastValue;
                    };
                    if (assign) {
                        fn.assign = function(scope, value, locals) {
                            return assign(scope, locals, value);
                        };
                    }
                    if (inputs) {
                        fn.inputs = inputs;
                    }
                    return fn;
                },
                recurse: function(ast, context, create) {
                    var left, right, self = this, args;
                    if (ast.input) {
                        return this.inputs(ast.input, ast.watchId);
                    }
                    switch (ast.type) {
                      case AST.Literal:
                        return this.value(ast.value, context);

                      case AST.UnaryExpression:
                        right = this.recurse(ast.argument);
                        return this["unary" + ast.operator](right, context);

                      case AST.BinaryExpression:
                        left = this.recurse(ast.left);
                        right = this.recurse(ast.right);
                        return this["binary" + ast.operator](left, right, context);

                      case AST.LogicalExpression:
                        left = this.recurse(ast.left);
                        right = this.recurse(ast.right);
                        return this["binary" + ast.operator](left, right, context);

                      case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

                      case AST.Identifier:
                        return self.identifier(ast.name, context, create);

                      case AST.MemberExpression:
                        left = this.recurse(ast.object, false, !!create);
                        if (!ast.computed) {
                            right = ast.property.name;
                        }
                        if (ast.computed) right = this.recurse(ast.property);
                        return ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

                      case AST.CallExpression:
                        args = [];
                        forEach(ast.arguments, function(expr) {
                            args.push(self.recurse(expr));
                        });
                        if (ast.filter) right = this.$filter(ast.callee.name);
                        if (!ast.filter) right = this.recurse(ast.callee, true);
                        return ast.filter ? function(scope, locals, assign, inputs) {
                            var values = [];
                            for (var i = 0; i < args.length; ++i) {
                                values.push(args[i](scope, locals, assign, inputs));
                            }
                            var value = right.apply(undefined, values, inputs);
                            return context ? {
                                context: undefined,
                                name: undefined,
                                value: value
                            } : value;
                        } : function(scope, locals, assign, inputs) {
                            var rhs = right(scope, locals, assign, inputs);
                            var value;
                            if (rhs.value != null) {
                                var values = [];
                                for (var i = 0; i < args.length; ++i) {
                                    values.push(args[i](scope, locals, assign, inputs));
                                }
                                value = rhs.value.apply(rhs.context, values);
                            }
                            return context ? {
                                value: value
                            } : value;
                        };

                      case AST.AssignmentExpression:
                        left = this.recurse(ast.left, true, 1);
                        right = this.recurse(ast.right);
                        return function(scope, locals, assign, inputs) {
                            var lhs = left(scope, locals, assign, inputs);
                            var rhs = right(scope, locals, assign, inputs);
                            lhs.context[lhs.name] = rhs;
                            return context ? {
                                value: rhs
                            } : rhs;
                        };

                      case AST.ArrayExpression:
                        args = [];
                        forEach(ast.elements, function(expr) {
                            args.push(self.recurse(expr));
                        });
                        return function(scope, locals, assign, inputs) {
                            var value = [];
                            for (var i = 0; i < args.length; ++i) {
                                value.push(args[i](scope, locals, assign, inputs));
                            }
                            return context ? {
                                value: value
                            } : value;
                        };

                      case AST.ObjectExpression:
                        args = [];
                        forEach(ast.properties, function(property) {
                            if (property.computed) {
                                args.push({
                                    key: self.recurse(property.key),
                                    computed: true,
                                    value: self.recurse(property.value)
                                });
                            } else {
                                args.push({
                                    key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                                    computed: false,
                                    value: self.recurse(property.value)
                                });
                            }
                        });
                        return function(scope, locals, assign, inputs) {
                            var value = {};
                            for (var i = 0; i < args.length; ++i) {
                                if (args[i].computed) {
                                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                                } else {
                                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                                }
                            }
                            return context ? {
                                value: value
                            } : value;
                        };

                      case AST.ThisExpression:
                        return function(scope) {
                            return context ? {
                                value: scope
                            } : scope;
                        };

                      case AST.LocalsExpression:
                        return function(scope, locals) {
                            return context ? {
                                value: locals
                            } : locals;
                        };

                      case AST.NGValueParameter:
                        return function(scope, locals, assign) {
                            return context ? {
                                value: assign
                            } : assign;
                        };
                    }
                },
                "unary+": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        if (isDefined(arg)) {
                            arg = +arg;
                        } else {
                            arg = 0;
                        }
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "unary-": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        if (isDefined(arg)) {
                            arg = -arg;
                        } else {
                            arg = -0;
                        }
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "unary!": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = !argument(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary+": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs = right(scope, locals, assign, inputs);
                        var arg = plusFn(lhs, rhs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary-": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs = right(scope, locals, assign, inputs);
                        var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary*": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary/": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary%": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary===": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary!==": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary==": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary!=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary<": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary>": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary<=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary>=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary&&": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary||": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "ternary?:": function(test, alternate, consequent, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                value: function(value, context) {
                    return function() {
                        return context ? {
                            context: undefined,
                            name: undefined,
                            value: value
                        } : value;
                    };
                },
                identifier: function(name, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var base = locals && name in locals ? locals : scope;
                        if (create && create !== 1 && base && base[name] == null) {
                            base[name] = {};
                        }
                        var value = base ? base[name] : undefined;
                        if (context) {
                            return {
                                context: base,
                                name: name,
                                value: value
                            };
                        } else {
                            return value;
                        }
                    };
                },
                computedMember: function(left, right, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs;
                        var value;
                        if (lhs != null) {
                            rhs = right(scope, locals, assign, inputs);
                            rhs = getStringValue(rhs);
                            if (create && create !== 1) {
                                if (lhs && !lhs[rhs]) {
                                    lhs[rhs] = {};
                                }
                            }
                            value = lhs[rhs];
                        }
                        if (context) {
                            return {
                                context: lhs,
                                name: rhs,
                                value: value
                            };
                        } else {
                            return value;
                        }
                    };
                },
                nonComputedMember: function(left, right, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        if (create && create !== 1) {
                            if (lhs && lhs[right] == null) {
                                lhs[right] = {};
                            }
                        }
                        var value = lhs != null ? lhs[right] : undefined;
                        if (context) {
                            return {
                                context: lhs,
                                name: right,
                                value: value
                            };
                        } else {
                            return value;
                        }
                    };
                },
                inputs: function(input, watchId) {
                    return function(scope, value, locals, inputs) {
                        if (inputs) return inputs[watchId];
                        return input(scope, value, locals);
                    };
                }
            };
            function Parser(lexer, $filter, options) {
                this.ast = new AST(lexer, options);
                this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
            }
            Parser.prototype = {
                constructor: Parser,
                parse: function(text) {
                    var ast = this.getAst(text);
                    var fn = this.astCompiler.compile(ast.ast);
                    fn.literal = isLiteral(ast.ast);
                    fn.constant = isConstant(ast.ast);
                    fn.oneTime = ast.oneTime;
                    return fn;
                },
                getAst: function(exp) {
                    var oneTime = false;
                    exp = exp.trim();
                    if (exp.charAt(0) === ":" && exp.charAt(1) === ":") {
                        oneTime = true;
                        exp = exp.substring(2);
                    }
                    return {
                        ast: this.ast.ast(exp),
                        oneTime: oneTime
                    };
                }
            };
            function getValueOf(value) {
                return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
            }
            function $ParseProvider() {
                var cache = createMap();
                var literals = {
                    true: true,
                    false: false,
                    null: null,
                    undefined: undefined
                };
                var identStart, identContinue;
                this.addLiteral = function(literalName, literalValue) {
                    literals[literalName] = literalValue;
                };
                this.setIdentifierFns = function(identifierStart, identifierContinue) {
                    identStart = identifierStart;
                    identContinue = identifierContinue;
                    return this;
                };
                this.$get = [ "$filter", function($filter) {
                    var noUnsafeEval = csp().noUnsafeEval;
                    var $parseOptions = {
                        csp: noUnsafeEval,
                        literals: copy(literals),
                        isIdentifierStart: isFunction(identStart) && identStart,
                        isIdentifierContinue: isFunction(identContinue) && identContinue
                    };
                    $parse.$$getAst = $$getAst;
                    return $parse;
                    function $parse(exp, interceptorFn) {
                        var parsedExpression, cacheKey;
                        switch (typeof exp) {
                          case "string":
                            exp = exp.trim();
                            cacheKey = exp;
                            parsedExpression = cache[cacheKey];
                            if (!parsedExpression) {
                                var lexer = new Lexer($parseOptions);
                                var parser = new Parser(lexer, $filter, $parseOptions);
                                parsedExpression = parser.parse(exp);
                                if (parsedExpression.constant) {
                                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                                } else if (parsedExpression.oneTime) {
                                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                                } else if (parsedExpression.inputs) {
                                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                                }
                                cache[cacheKey] = parsedExpression;
                            }
                            return addInterceptor(parsedExpression, interceptorFn);

                          case "function":
                            return addInterceptor(exp, interceptorFn);

                          default:
                            return addInterceptor(noop, interceptorFn);
                        }
                    }
                    function $$getAst(exp) {
                        var lexer = new Lexer($parseOptions);
                        var parser = new Parser(lexer, $filter, $parseOptions);
                        return parser.getAst(exp).ast;
                    }
                    function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                        if (newValue == null || oldValueOfValue == null) {
                            return newValue === oldValueOfValue;
                        }
                        if (typeof newValue === "object") {
                            newValue = getValueOf(newValue);
                            if (typeof newValue === "object" && !compareObjectIdentity) {
                                return false;
                            }
                        }
                        return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
                    }
                    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var inputExpressions = parsedExpression.inputs;
                        var lastResult;
                        if (inputExpressions.length === 1) {
                            var oldInputValueOf = expressionInputDirtyCheck;
                            inputExpressions = inputExpressions[0];
                            return scope.$watch(function expressionInputWatch(scope) {
                                var newInputValue = inputExpressions(scope);
                                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure)) {
                                    lastResult = parsedExpression(scope, undefined, undefined, [ newInputValue ]);
                                    oldInputValueOf = newInputValue && getValueOf(newInputValue);
                                }
                                return lastResult;
                            }, listener, objectEquality, prettyPrintExpression);
                        }
                        var oldInputValueOfValues = [];
                        var oldInputValues = [];
                        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                            oldInputValueOfValues[i] = expressionInputDirtyCheck;
                            oldInputValues[i] = null;
                        }
                        return scope.$watch(function expressionInputsWatch(scope) {
                            var changed = false;
                            for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                                var newInputValue = inputExpressions[i](scope);
                                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) {
                                    oldInputValues[i] = newInputValue;
                                    oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                                }
                            }
                            if (changed) {
                                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                            }
                            return lastResult;
                        }, listener, objectEquality, prettyPrintExpression);
                    }
                    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var unwatch, lastValue;
                        if (parsedExpression.inputs) {
                            unwatch = inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression);
                        } else {
                            unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);
                        }
                        return unwatch;
                        function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }
                        function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener(value, old, scope);
                            }
                            if (isDefined(value)) {
                                scope.$$postDigest(function() {
                                    if (isDefined(lastValue)) {
                                        unwatch();
                                    }
                                });
                            }
                        }
                    }
                    function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch, lastValue;
                        unwatch = scope.$watch(function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }, function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener(value, old, scope);
                            }
                            if (isAllDefined(value)) {
                                scope.$$postDigest(function() {
                                    if (isAllDefined(lastValue)) unwatch();
                                });
                            }
                        }, objectEquality);
                        return unwatch;
                        function isAllDefined(value) {
                            var allDefined = true;
                            forEach(value, function(val) {
                                if (!isDefined(val)) allDefined = false;
                            });
                            return allDefined;
                        }
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch = scope.$watch(function constantWatch(scope) {
                            unwatch();
                            return parsedExpression(scope);
                        }, listener, objectEquality);
                        return unwatch;
                    }
                    function addInterceptor(parsedExpression, interceptorFn) {
                        if (!interceptorFn) return parsedExpression;
                        var watchDelegate = parsedExpression.$$watchDelegate;
                        var useInputs = false;
                        var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                        var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value, scope, locals);
                        } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                            var value = parsedExpression(scope, locals, assign, inputs);
                            var result = interceptorFn(value, scope, locals);
                            return isDefined(value) ? result : value;
                        };
                        useInputs = !parsedExpression.inputs;
                        if (watchDelegate && watchDelegate !== inputsWatchDelegate) {
                            fn.$$watchDelegate = watchDelegate;
                            fn.inputs = parsedExpression.inputs;
                        } else if (!interceptorFn.$stateful) {
                            fn.$$watchDelegate = inputsWatchDelegate;
                            fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ];
                        }
                        if (fn.inputs) {
                            fn.inputs = fn.inputs.map(function(e) {
                                if (e.isPure === PURITY_RELATIVE) {
                                    return function depurifier(s) {
                                        return e(s);
                                    };
                                }
                                return e;
                            });
                        }
                        return fn;
                    }
                } ];
            }
            function $QProvider() {
                var errorOnUnhandledRejections = true;
                this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
                    return qFactory(function(callback) {
                        $rootScope.$evalAsync(callback);
                    }, $exceptionHandler, errorOnUnhandledRejections);
                } ];
                this.errorOnUnhandledRejections = function(value) {
                    if (isDefined(value)) {
                        errorOnUnhandledRejections = value;
                        return this;
                    } else {
                        return errorOnUnhandledRejections;
                    }
                };
            }
            function $$QProvider() {
                var errorOnUnhandledRejections = true;
                this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
                    return qFactory(function(callback) {
                        $browser.defer(callback);
                    }, $exceptionHandler, errorOnUnhandledRejections);
                } ];
                this.errorOnUnhandledRejections = function(value) {
                    if (isDefined(value)) {
                        errorOnUnhandledRejections = value;
                        return this;
                    } else {
                        return errorOnUnhandledRejections;
                    }
                };
            }
            function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
                var $qMinErr = minErr("$q", TypeError);
                var queueSize = 0;
                var checkQueue = [];
                function defer() {
                    return new Deferred();
                }
                function Deferred() {
                    var promise = this.promise = new Promise();
                    this.resolve = function(val) {
                        resolvePromise(promise, val);
                    };
                    this.reject = function(reason) {
                        rejectPromise(promise, reason);
                    };
                    this.notify = function(progress) {
                        notifyPromise(promise, progress);
                    };
                }
                function Promise() {
                    this.$$state = {
                        status: 0
                    };
                }
                extend(Promise.prototype, {
                    then: function(onFulfilled, onRejected, progressBack) {
                        if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                            return this;
                        }
                        var result = new Promise();
                        this.$$state.pending = this.$$state.pending || [];
                        this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]);
                        if (this.$$state.status > 0) scheduleProcessQueue(this.$$state);
                        return result;
                    },
                    catch: function(callback) {
                        return this.then(null, callback);
                    },
                    finally: function(callback, progressBack) {
                        return this.then(function(value) {
                            return handleCallback(value, resolve, callback);
                        }, function(error) {
                            return handleCallback(error, reject, callback);
                        }, progressBack);
                    }
                });
                function processQueue(state) {
                    var fn, promise, pending;
                    pending = state.pending;
                    state.processScheduled = false;
                    state.pending = undefined;
                    try {
                        for (var i = 0, ii = pending.length; i < ii; ++i) {
                            markQStateExceptionHandled(state);
                            promise = pending[i][0];
                            fn = pending[i][state.status];
                            try {
                                if (isFunction(fn)) {
                                    resolvePromise(promise, fn(state.value));
                                } else if (state.status === 1) {
                                    resolvePromise(promise, state.value);
                                } else {
                                    rejectPromise(promise, state.value);
                                }
                            } catch (e) {
                                rejectPromise(promise, e);
                                if (e && e.$$passToExceptionHandler === true) {
                                    exceptionHandler(e);
                                }
                            }
                        }
                    } finally {
                        --queueSize;
                        if (errorOnUnhandledRejections && queueSize === 0) {
                            nextTick(processChecks);
                        }
                    }
                }
                function processChecks() {
                    while (!queueSize && checkQueue.length) {
                        var toCheck = checkQueue.shift();
                        if (!isStateExceptionHandled(toCheck)) {
                            markQStateExceptionHandled(toCheck);
                            var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                            if (isError(toCheck.value)) {
                                exceptionHandler(toCheck.value, errorMessage);
                            } else {
                                exceptionHandler(errorMessage);
                            }
                        }
                    }
                }
                function scheduleProcessQueue(state) {
                    if (errorOnUnhandledRejections && !state.pending && state.status === 2 && !isStateExceptionHandled(state)) {
                        if (queueSize === 0 && checkQueue.length === 0) {
                            nextTick(processChecks);
                        }
                        checkQueue.push(state);
                    }
                    if (state.processScheduled || !state.pending) return;
                    state.processScheduled = true;
                    ++queueSize;
                    nextTick(function() {
                        processQueue(state);
                    });
                }
                function resolvePromise(promise, val) {
                    if (promise.$$state.status) return;
                    if (val === promise) {
                        $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val));
                    } else {
                        $$resolve(promise, val);
                    }
                }
                function $$resolve(promise, val) {
                    var then;
                    var done = false;
                    try {
                        if (isObject(val) || isFunction(val)) then = val.then;
                        if (isFunction(then)) {
                            promise.$$state.status = -1;
                            then.call(val, doResolve, doReject, doNotify);
                        } else {
                            promise.$$state.value = val;
                            promise.$$state.status = 1;
                            scheduleProcessQueue(promise.$$state);
                        }
                    } catch (e) {
                        doReject(e);
                    }
                    function doResolve(val) {
                        if (done) return;
                        done = true;
                        $$resolve(promise, val);
                    }
                    function doReject(val) {
                        if (done) return;
                        done = true;
                        $$reject(promise, val);
                    }
                    function doNotify(progress) {
                        notifyPromise(promise, progress);
                    }
                }
                function rejectPromise(promise, reason) {
                    if (promise.$$state.status) return;
                    $$reject(promise, reason);
                }
                function $$reject(promise, reason) {
                    promise.$$state.value = reason;
                    promise.$$state.status = 2;
                    scheduleProcessQueue(promise.$$state);
                }
                function notifyPromise(promise, progress) {
                    var callbacks = promise.$$state.pending;
                    if (promise.$$state.status <= 0 && callbacks && callbacks.length) {
                        nextTick(function() {
                            var callback, result;
                            for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                result = callbacks[i][0];
                                callback = callbacks[i][3];
                                try {
                                    notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                                } catch (e) {
                                    exceptionHandler(e);
                                }
                            }
                        });
                    }
                }
                function reject(reason) {
                    var result = new Promise();
                    rejectPromise(result, reason);
                    return result;
                }
                function handleCallback(value, resolver, callback) {
                    var callbackOutput = null;
                    try {
                        if (isFunction(callback)) callbackOutput = callback();
                    } catch (e) {
                        return reject(e);
                    }
                    if (isPromiseLike(callbackOutput)) {
                        return callbackOutput.then(function() {
                            return resolver(value);
                        }, reject);
                    } else {
                        return resolver(value);
                    }
                }
                function when(value, callback, errback, progressBack) {
                    var result = new Promise();
                    resolvePromise(result, value);
                    return result.then(callback, errback, progressBack);
                }
                var resolve = when;
                function all(promises) {
                    var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
                    forEach(promises, function(promise, key) {
                        counter++;
                        when(promise).then(function(value) {
                            results[key] = value;
                            if (!--counter) resolvePromise(result, results);
                        }, function(reason) {
                            rejectPromise(result, reason);
                        });
                    });
                    if (counter === 0) {
                        resolvePromise(result, results);
                    }
                    return result;
                }
                function race(promises) {
                    var deferred = defer();
                    forEach(promises, function(promise) {
                        when(promise).then(deferred.resolve, deferred.reject);
                    });
                    return deferred.promise;
                }
                function $Q(resolver) {
                    if (!isFunction(resolver)) {
                        throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                    }
                    var promise = new Promise();
                    function resolveFn(value) {
                        resolvePromise(promise, value);
                    }
                    function rejectFn(reason) {
                        rejectPromise(promise, reason);
                    }
                    resolver(resolveFn, rejectFn);
                    return promise;
                }
                $Q.prototype = Promise.prototype;
                $Q.defer = defer;
                $Q.reject = reject;
                $Q.when = when;
                $Q.resolve = resolve;
                $Q.all = all;
                $Q.race = race;
                return $Q;
            }
            function isStateExceptionHandled(state) {
                return !!state.pur;
            }
            function markQStateExceptionHandled(state) {
                state.pur = true;
            }
            function markQExceptionHandled(q) {
                markQStateExceptionHandled(q.$$state);
            }
            function $$RAFProvider() {
                this.$get = [ "$window", "$timeout", function($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
                    var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
                    var rafSupported = !!requestAnimationFrame;
                    var raf = rafSupported ? function(fn) {
                        var id = requestAnimationFrame(fn);
                        return function() {
                            cancelAnimationFrame(id);
                        };
                    } : function(fn) {
                        var timer = $timeout(fn, 16.66, false);
                        return function() {
                            $timeout.cancel(timer);
                        };
                    };
                    raf.supported = rafSupported;
                    return raf;
                } ];
            }
            function $RootScopeProvider() {
                var TTL = 10;
                var $rootScopeMinErr = minErr("$rootScope");
                var lastDirtyWatch = null;
                var applyAsyncId = null;
                this.digestTtl = function(value) {
                    if (arguments.length) {
                        TTL = value;
                    }
                    return TTL;
                };
                function createChildScopeClass(parent) {
                    function ChildScope() {
                        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                        this.$$listeners = {};
                        this.$$listenerCount = {};
                        this.$$watchersCount = 0;
                        this.$id = nextUid();
                        this.$$ChildScope = null;
                    }
                    ChildScope.prototype = parent;
                    return ChildScope;
                }
                this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
                    function destroyChildScope($event) {
                        $event.currentScope.$$destroyed = true;
                    }
                    function cleanUpScope($scope) {
                        if (msie === 9) {
                            if ($scope.$$childHead) {
                                cleanUpScope($scope.$$childHead);
                            }
                            if ($scope.$$nextSibling) {
                                cleanUpScope($scope.$$nextSibling);
                            }
                        }
                        $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                    }
                    function Scope() {
                        this.$id = nextUid();
                        this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                        this.$root = this;
                        this.$$destroyed = false;
                        this.$$listeners = {};
                        this.$$listenerCount = {};
                        this.$$watchersCount = 0;
                        this.$$isolateBindings = null;
                    }
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function(isolate, parent) {
                            var child;
                            parent = parent || this;
                            if (isolate) {
                                child = new Scope();
                                child.$root = this.$root;
                            } else {
                                if (!this.$$ChildScope) {
                                    this.$$ChildScope = createChildScopeClass(this);
                                }
                                child = new this.$$ChildScope();
                            }
                            child.$parent = parent;
                            child.$$prevSibling = parent.$$childTail;
                            if (parent.$$childHead) {
                                parent.$$childTail.$$nextSibling = child;
                                parent.$$childTail = child;
                            } else {
                                parent.$$childHead = parent.$$childTail = child;
                            }
                            if (isolate || parent !== this) child.$on("$destroy", destroyChildScope);
                            return child;
                        },
                        $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                            var get = $parse(watchExp);
                            var fn = isFunction(listener) ? listener : noop;
                            if (get.$$watchDelegate) {
                                return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                            }
                            var scope = this, array = scope.$$watchers, watcher = {
                                fn: fn,
                                last: initWatchVal,
                                get: get,
                                exp: prettyPrintExpression || watchExp,
                                eq: !!objectEquality
                            };
                            lastDirtyWatch = null;
                            if (!array) {
                                array = scope.$$watchers = [];
                                array.$$digestWatchIndex = -1;
                            }
                            array.unshift(watcher);
                            array.$$digestWatchIndex++;
                            incrementWatchersCount(this, 1);
                            return function deregisterWatch() {
                                var index = arrayRemove(array, watcher);
                                if (index >= 0) {
                                    incrementWatchersCount(scope, -1);
                                    if (index < array.$$digestWatchIndex) {
                                        array.$$digestWatchIndex--;
                                    }
                                }
                                lastDirtyWatch = null;
                            };
                        },
                        $watchGroup: function(watchExpressions, listener) {
                            var oldValues = new Array(watchExpressions.length);
                            var newValues = new Array(watchExpressions.length);
                            var deregisterFns = [];
                            var self = this;
                            var changeReactionScheduled = false;
                            var firstRun = true;
                            if (!watchExpressions.length) {
                                var shouldCall = true;
                                self.$evalAsync(function() {
                                    if (shouldCall) listener(newValues, newValues, self);
                                });
                                return function deregisterWatchGroup() {
                                    shouldCall = false;
                                };
                            }
                            if (watchExpressions.length === 1) {
                                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                                    newValues[0] = value;
                                    oldValues[0] = oldValue;
                                    listener(newValues, value === oldValue ? newValues : oldValues, scope);
                                });
                            }
                            forEach(watchExpressions, function(expr, i) {
                                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                                    newValues[i] = value;
                                    oldValues[i] = oldValue;
                                    if (!changeReactionScheduled) {
                                        changeReactionScheduled = true;
                                        self.$evalAsync(watchGroupAction);
                                    }
                                });
                                deregisterFns.push(unwatchFn);
                            });
                            function watchGroupAction() {
                                changeReactionScheduled = false;
                                if (firstRun) {
                                    firstRun = false;
                                    listener(newValues, newValues, self);
                                } else {
                                    listener(newValues, oldValues, self);
                                }
                            }
                            return function deregisterWatchGroup() {
                                while (deregisterFns.length) {
                                    deregisterFns.shift()();
                                }
                            };
                        },
                        $watchCollection: function(obj, listener) {
                            $watchCollectionInterceptor.$stateful = true;
                            var self = this;
                            var newValue;
                            var oldValue;
                            var veryOldValue;
                            var trackVeryOldValue = listener.length > 1;
                            var changeDetected = 0;
                            var changeDetector = $parse(obj, $watchCollectionInterceptor);
                            var internalArray = [];
                            var internalObject = {};
                            var initRun = true;
                            var oldLength = 0;
                            function $watchCollectionInterceptor(_value) {
                                newValue = _value;
                                var newLength, key, bothNaN, newItem, oldItem;
                                if (isUndefined(newValue)) return;
                                if (!isObject(newValue)) {
                                    if (oldValue !== newValue) {
                                        oldValue = newValue;
                                        changeDetected++;
                                    }
                                } else if (isArrayLike(newValue)) {
                                    if (oldValue !== internalArray) {
                                        oldValue = internalArray;
                                        oldLength = oldValue.length = 0;
                                        changeDetected++;
                                    }
                                    newLength = newValue.length;
                                    if (oldLength !== newLength) {
                                        changeDetected++;
                                        oldValue.length = oldLength = newLength;
                                    }
                                    for (var i = 0; i < newLength; i++) {
                                        oldItem = oldValue[i];
                                        newItem = newValue[i];
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[i] = newItem;
                                        }
                                    }
                                } else {
                                    if (oldValue !== internalObject) {
                                        oldValue = internalObject = {};
                                        oldLength = 0;
                                        changeDetected++;
                                    }
                                    newLength = 0;
                                    for (key in newValue) {
                                        if (hasOwnProperty.call(newValue, key)) {
                                            newLength++;
                                            newItem = newValue[key];
                                            oldItem = oldValue[key];
                                            if (key in oldValue) {
                                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                                if (!bothNaN && oldItem !== newItem) {
                                                    changeDetected++;
                                                    oldValue[key] = newItem;
                                                }
                                            } else {
                                                oldLength++;
                                                oldValue[key] = newItem;
                                                changeDetected++;
                                            }
                                        }
                                    }
                                    if (oldLength > newLength) {
                                        changeDetected++;
                                        for (key in oldValue) {
                                            if (!hasOwnProperty.call(newValue, key)) {
                                                oldLength--;
                                                delete oldValue[key];
                                            }
                                        }
                                    }
                                }
                                return changeDetected;
                            }
                            function $watchCollectionAction() {
                                if (initRun) {
                                    initRun = false;
                                    listener(newValue, newValue, self);
                                } else {
                                    listener(newValue, veryOldValue, self);
                                }
                                if (trackVeryOldValue) {
                                    if (!isObject(newValue)) {
                                        veryOldValue = newValue;
                                    } else if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++) {
                                            veryOldValue[i] = newValue[i];
                                        }
                                    } else {
                                        veryOldValue = {};
                                        for (var key in newValue) {
                                            if (hasOwnProperty.call(newValue, key)) {
                                                veryOldValue[key] = newValue[key];
                                            }
                                        }
                                    }
                                }
                            }
                            return this.$watch(changeDetector, $watchCollectionAction);
                        },
                        $digest: function() {
                            var watch, value, last, fn, get, watchers, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask;
                            beginPhase("$digest");
                            $browser.$$checkUrlChange();
                            if (this === $rootScope && applyAsyncId !== null) {
                                $browser.defer.cancel(applyAsyncId);
                                flushApplyAsync();
                            }
                            lastDirtyWatch = null;
                            do {
                                dirty = false;
                                current = target;
                                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                    try {
                                        asyncTask = asyncQueue[asyncQueuePosition];
                                        fn = asyncTask.fn;
                                        fn(asyncTask.scope, asyncTask.locals);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    lastDirtyWatch = null;
                                }
                                asyncQueue.length = 0;
                                traverseScopesLoop: do {
                                    if (watchers = current.$$watchers) {
                                        watchers.$$digestWatchIndex = watchers.length;
                                        while (watchers.$$digestWatchIndex--) {
                                            try {
                                                watch = watchers[watchers.$$digestWatchIndex];
                                                if (watch) {
                                                    get = watch.get;
                                                    if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                        dirty = true;
                                                        lastDirtyWatch = watch;
                                                        watch.last = watch.eq ? copy(value, null) : value;
                                                        fn = watch.fn;
                                                        fn(value, last === initWatchVal ? value : last, current);
                                                        if (ttl < 5) {
                                                            logIdx = 4 - ttl;
                                                            if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                            watchLog[logIdx].push({
                                                                msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                                newVal: value,
                                                                oldVal: last
                                                            });
                                                        }
                                                    } else if (watch === lastDirtyWatch) {
                                                        dirty = false;
                                                        break traverseScopesLoop;
                                                    }
                                                }
                                            } catch (e) {
                                                $exceptionHandler(e);
                                            }
                                        }
                                    }
                                    if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                        while (current !== target && !(next = current.$$nextSibling)) {
                                            current = current.$parent;
                                        }
                                    }
                                } while (current = next);
                                if ((dirty || asyncQueue.length) && !ttl--) {
                                    clearPhase();
                                    throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, watchLog);
                                }
                            } while (dirty || asyncQueue.length);
                            clearPhase();
                            while (postDigestQueuePosition < postDigestQueue.length) {
                                try {
                                    postDigestQueue[postDigestQueuePosition++]();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                            postDigestQueue.length = postDigestQueuePosition = 0;
                            $browser.$$checkUrlChange();
                        },
                        $destroy: function() {
                            if (this.$$destroyed) return;
                            var parent = this.$parent;
                            this.$broadcast("$destroy");
                            this.$$destroyed = true;
                            if (this === $rootScope) {
                                $browser.$$applicationDestroyed();
                            }
                            incrementWatchersCount(this, -this.$$watchersCount);
                            for (var eventName in this.$$listenerCount) {
                                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            }
                            if (parent && parent.$$childHead === this) parent.$$childHead = this.$$nextSibling;
                            if (parent && parent.$$childTail === this) parent.$$childTail = this.$$prevSibling;
                            if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                            if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                            this.$on = this.$watch = this.$watchGroup = function() {
                                return noop;
                            };
                            this.$$listeners = {};
                            this.$$nextSibling = null;
                            cleanUpScope(this);
                        },
                        $eval: function(expr, locals) {
                            return $parse(expr)(this, locals);
                        },
                        $evalAsync: function(expr, locals) {
                            if (!$rootScope.$$phase && !asyncQueue.length) {
                                $browser.defer(function() {
                                    if (asyncQueue.length) {
                                        $rootScope.$digest();
                                    }
                                });
                            }
                            asyncQueue.push({
                                scope: this,
                                fn: $parse(expr),
                                locals: locals
                            });
                        },
                        $$postDigest: function(fn) {
                            postDigestQueue.push(fn);
                        },
                        $apply: function(expr) {
                            try {
                                beginPhase("$apply");
                                try {
                                    return this.$eval(expr);
                                } finally {
                                    clearPhase();
                                }
                            } catch (e) {
                                $exceptionHandler(e);
                            } finally {
                                try {
                                    $rootScope.$digest();
                                } catch (e) {
                                    $exceptionHandler(e);
                                    throw e;
                                }
                            }
                        },
                        $applyAsync: function(expr) {
                            var scope = this;
                            if (expr) {
                                applyAsyncQueue.push($applyAsyncExpression);
                            }
                            expr = $parse(expr);
                            scheduleApplyAsync();
                            function $applyAsyncExpression() {
                                scope.$eval(expr);
                            }
                        },
                        $on: function(name, listener) {
                            var namedListeners = this.$$listeners[name];
                            if (!namedListeners) {
                                this.$$listeners[name] = namedListeners = [];
                            }
                            namedListeners.push(listener);
                            var current = this;
                            do {
                                if (!current.$$listenerCount[name]) {
                                    current.$$listenerCount[name] = 0;
                                }
                                current.$$listenerCount[name]++;
                            } while (current = current.$parent);
                            var self = this;
                            return function() {
                                var indexOfListener = namedListeners.indexOf(listener);
                                if (indexOfListener !== -1) {
                                    delete namedListeners[indexOfListener];
                                    decrementListenerCount(self, 1, name);
                                }
                            };
                        },
                        $emit: function(name, args) {
                            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                                name: name,
                                targetScope: scope,
                                stopPropagation: function() {
                                    stopPropagation = true;
                                },
                                preventDefault: function() {
                                    event.defaultPrevented = true;
                                },
                                defaultPrevented: false
                            }, listenerArgs = concat([ event ], arguments, 1), i, length;
                            do {
                                namedListeners = scope.$$listeners[name] || empty;
                                event.currentScope = scope;
                                for (i = 0, length = namedListeners.length; i < length; i++) {
                                    if (!namedListeners[i]) {
                                        namedListeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        namedListeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (stopPropagation) {
                                    break;
                                }
                                scope = scope.$parent;
                            } while (scope);
                            event.currentScope = null;
                            return event;
                        },
                        $broadcast: function(name, args) {
                            var target = this, current = target, next = target, event = {
                                name: name,
                                targetScope: target,
                                preventDefault: function() {
                                    event.defaultPrevented = true;
                                },
                                defaultPrevented: false
                            };
                            if (!target.$$listenerCount[name]) return event;
                            var listenerArgs = concat([ event ], arguments, 1), listeners, i, length;
                            while (current = next) {
                                event.currentScope = current;
                                listeners = current.$$listeners[name] || [];
                                for (i = 0, length = listeners.length; i < length; i++) {
                                    if (!listeners[i]) {
                                        listeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        listeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                                    while (current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            }
                            event.currentScope = null;
                            return event;
                        }
                    };
                    var $rootScope = new Scope();
                    var asyncQueue = $rootScope.$$asyncQueue = [];
                    var postDigestQueue = $rootScope.$$postDigestQueue = [];
                    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
                    var postDigestQueuePosition = 0;
                    return $rootScope;
                    function beginPhase(phase) {
                        if ($rootScope.$$phase) {
                            throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                        }
                        $rootScope.$$phase = phase;
                    }
                    function clearPhase() {
                        $rootScope.$$phase = null;
                    }
                    function incrementWatchersCount(current, count) {
                        do {
                            current.$$watchersCount += count;
                        } while (current = current.$parent);
                    }
                    function decrementListenerCount(current, count, name) {
                        do {
                            current.$$listenerCount[name] -= count;
                            if (current.$$listenerCount[name] === 0) {
                                delete current.$$listenerCount[name];
                            }
                        } while (current = current.$parent);
                    }
                    function initWatchVal() {}
                    function flushApplyAsync() {
                        while (applyAsyncQueue.length) {
                            try {
                                applyAsyncQueue.shift()();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        applyAsyncId = null;
                    }
                    function scheduleApplyAsync() {
                        if (applyAsyncId === null) {
                            applyAsyncId = $browser.defer(function() {
                                $rootScope.$apply(flushApplyAsync);
                            });
                        }
                    }
                } ];
            }
            function $$SanitizeUriProvider() {
                var aHrefSanitizationWhitelist = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
                this.aHrefSanitizationWhitelist = function(regexp) {
                    if (isDefined(regexp)) {
                        aHrefSanitizationWhitelist = regexp;
                        return this;
                    }
                    return aHrefSanitizationWhitelist;
                };
                this.imgSrcSanitizationWhitelist = function(regexp) {
                    if (isDefined(regexp)) {
                        imgSrcSanitizationWhitelist = regexp;
                        return this;
                    }
                    return imgSrcSanitizationWhitelist;
                };
                this.$get = function() {
                    return function sanitizeUri(uri, isImage) {
                        var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                        var normalizedVal;
                        normalizedVal = urlResolve(uri && uri.trim()).href;
                        if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                            return "unsafe:" + normalizedVal;
                        }
                        return uri;
                    };
                };
            }
            var $sceMinErr = minErr("$sce");
            var SCE_CONTEXTS = {
                HTML: "html",
                CSS: "css",
                URL: "url",
                RESOURCE_URL: "resourceUrl",
                JS: "js"
            };
            var UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
            function snakeToCamel(name) {
                return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
            }
            function adjustMatcher(matcher) {
                if (matcher === "self") {
                    return matcher;
                } else if (isString(matcher)) {
                    if (matcher.indexOf("***") > -1) {
                        throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                    }
                    matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*");
                    return new RegExp("^" + matcher + "$");
                } else if (isRegExp(matcher)) {
                    return new RegExp("^" + matcher.source + "$");
                } else {
                    throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
                }
            }
            function adjustMatchers(matchers) {
                var adjustedMatchers = [];
                if (isDefined(matchers)) {
                    forEach(matchers, function(matcher) {
                        adjustedMatchers.push(adjustMatcher(matcher));
                    });
                }
                return adjustedMatchers;
            }
            function $SceDelegateProvider() {
                this.SCE_CONTEXTS = SCE_CONTEXTS;
                var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
                this.resourceUrlWhitelist = function(value) {
                    if (arguments.length) {
                        resourceUrlWhitelist = adjustMatchers(value);
                    }
                    return resourceUrlWhitelist;
                };
                this.resourceUrlBlacklist = function(value) {
                    if (arguments.length) {
                        resourceUrlBlacklist = adjustMatchers(value);
                    }
                    return resourceUrlBlacklist;
                };
                this.$get = [ "$injector", function($injector) {
                    var htmlSanitizer = function htmlSanitizer(html) {
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    };
                    if ($injector.has("$sanitize")) {
                        htmlSanitizer = $injector.get("$sanitize");
                    }
                    function matchUrl(matcher, parsedUrl) {
                        if (matcher === "self") {
                            return urlIsSameOrigin(parsedUrl);
                        } else {
                            return !!matcher.exec(parsedUrl.href);
                        }
                    }
                    function isResourceUrlAllowedByPolicy(url) {
                        var parsedUrl = urlResolve(url.toString());
                        var i, n, allowed = false;
                        for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                allowed = true;
                                break;
                            }
                        }
                        if (allowed) {
                            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                    allowed = false;
                                    break;
                                }
                            }
                        }
                        return allowed;
                    }
                    function generateHolderType(Base) {
                        var holderType = function TrustedValueHolderType(trustedValue) {
                            this.$$unwrapTrustedValue = function() {
                                return trustedValue;
                            };
                        };
                        if (Base) {
                            holderType.prototype = new Base();
                        }
                        holderType.prototype.valueOf = function sceValueOf() {
                            return this.$$unwrapTrustedValue();
                        };
                        holderType.prototype.toString = function sceToString() {
                            return this.$$unwrapTrustedValue().toString();
                        };
                        return holderType;
                    }
                    var trustedValueHolderBase = generateHolderType(), byType = {};
                    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) {
                            throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                        }
                        if (trustedValue === null || isUndefined(trustedValue) || trustedValue === "") {
                            return trustedValue;
                        }
                        if (typeof trustedValue !== "string") {
                            throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                        }
                        return new Constructor(trustedValue);
                    }
                    function valueOf(maybeTrusted) {
                        if (maybeTrusted instanceof trustedValueHolderBase) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        } else {
                            return maybeTrusted;
                        }
                    }
                    function getTrusted(type, maybeTrusted) {
                        if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === "") {
                            return maybeTrusted;
                        }
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        }
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                                return maybeTrusted;
                            } else {
                                throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                            }
                        } else if (type === SCE_CONTEXTS.HTML) {
                            return htmlSanitizer(maybeTrusted);
                        }
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    }
                    return {
                        trustAs: trustAs,
                        getTrusted: getTrusted,
                        valueOf: valueOf
                    };
                } ];
            }
            function $SceProvider() {
                var enabled = true;
                this.enabled = function(value) {
                    if (arguments.length) {
                        enabled = !!value;
                    }
                    return enabled;
                };
                this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
                    if (enabled && msie < 8) {
                        throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                    }
                    var sce = shallowCopy(SCE_CONTEXTS);
                    sce.isEnabled = function() {
                        return enabled;
                    };
                    sce.trustAs = $sceDelegate.trustAs;
                    sce.getTrusted = $sceDelegate.getTrusted;
                    sce.valueOf = $sceDelegate.valueOf;
                    if (!enabled) {
                        sce.trustAs = sce.getTrusted = function(type, value) {
                            return value;
                        };
                        sce.valueOf = identity;
                    }
                    sce.parseAs = function sceParseAs(type, expr) {
                        var parsed = $parse(expr);
                        if (parsed.literal && parsed.constant) {
                            return parsed;
                        } else {
                            return $parse(expr, function(value) {
                                return sce.getTrusted(type, value);
                            });
                        }
                    };
                    var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                    forEach(SCE_CONTEXTS, function(enumValue, name) {
                        var lName = lowercase(name);
                        sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                            return parse(enumValue, expr);
                        };
                        sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                            return getTrusted(enumValue, value);
                        };
                        sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                            return trustAs(enumValue, value);
                        };
                    });
                    return sce;
                } ];
            }
            function $SnifferProvider() {
                this.$get = [ "$window", "$document", function($window, $document) {
                    var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = false, animations = false;
                    if (bodyStyle) {
                        transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle);
                        animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle);
                    }
                    return {
                        history: !!(hasHistoryPushState && !(android < 4) && !boxee),
                        hasEvent: function(event) {
                            if (event === "input" && msie) return false;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement("div");
                                eventSupport[event] = "on" + event in divElm;
                            }
                            return eventSupport[event];
                        },
                        csp: csp(),
                        transitions: transitions,
                        animations: animations,
                        android: android
                    };
                } ];
            }
            var $templateRequestMinErr = minErr("$compile");
            function $TemplateRequestProvider() {
                var httpOptions;
                this.httpOptions = function(val) {
                    if (val) {
                        httpOptions = val;
                        return this;
                    }
                    return httpOptions;
                };
                this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
                    function handleRequestFn(tpl, ignoreRequestError) {
                        handleRequestFn.totalPendingRequests++;
                        if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
                            tpl = $sce.getTrustedResourceUrl(tpl);
                        }
                        var transformResponse = $http.defaults && $http.defaults.transformResponse;
                        if (isArray(transformResponse)) {
                            transformResponse = transformResponse.filter(function(transformer) {
                                return transformer !== defaultHttpResponseTransform;
                            });
                        } else if (transformResponse === defaultHttpResponseTransform) {
                            transformResponse = null;
                        }
                        return $http.get(tpl, extend({
                            cache: $templateCache,
                            transformResponse: transformResponse
                        }, httpOptions)).finally(function() {
                            handleRequestFn.totalPendingRequests--;
                        }).then(function(response) {
                            $templateCache.put(tpl, response.data);
                            return response.data;
                        }, handleError);
                        function handleError(resp) {
                            if (!ignoreRequestError) {
                                resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                                $exceptionHandler(resp);
                            }
                            return $q.reject(resp);
                        }
                    }
                    handleRequestFn.totalPendingRequests = 0;
                    return handleRequestFn;
                } ];
            }
            function $$TestabilityProvider() {
                this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
                    var testability = {};
                    testability.findBindings = function(element, expression, opt_exactMatch) {
                        var bindings = element.getElementsByClassName("ng-binding");
                        var matches = [];
                        forEach(bindings, function(binding) {
                            var dataBinding = angular.element(binding).data("$binding");
                            if (dataBinding) {
                                forEach(dataBinding, function(bindingName) {
                                    if (opt_exactMatch) {
                                        var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                        if (matcher.test(bindingName)) {
                                            matches.push(binding);
                                        }
                                    } else {
                                        if (bindingName.indexOf(expression) !== -1) {
                                            matches.push(binding);
                                        }
                                    }
                                });
                            }
                        });
                        return matches;
                    };
                    testability.findModels = function(element, expression, opt_exactMatch) {
                        var prefixes = [ "ng-", "data-ng-", "ng\\:" ];
                        for (var p = 0; p < prefixes.length; ++p) {
                            var attributeEquals = opt_exactMatch ? "=" : "*=";
                            var selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]';
                            var elements = element.querySelectorAll(selector);
                            if (elements.length) {
                                return elements;
                            }
                        }
                    };
                    testability.getLocation = function() {
                        return $location.url();
                    };
                    testability.setLocation = function(url) {
                        if (url !== $location.url()) {
                            $location.url(url);
                            $rootScope.$digest();
                        }
                    };
                    testability.whenStable = function(callback) {
                        $browser.notifyWhenNoOutstandingRequests(callback);
                    };
                    return testability;
                } ];
            }
            function $TimeoutProvider() {
                this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
                    var deferreds = {};
                    function timeout(fn, delay, invokeApply) {
                        if (!isFunction(fn)) {
                            invokeApply = delay;
                            delay = fn;
                            fn = noop;
                        }
                        var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                        timeoutId = $browser.defer(function() {
                            try {
                                deferred.resolve(fn.apply(null, args));
                            } catch (e) {
                                deferred.reject(e);
                                $exceptionHandler(e);
                            } finally {
                                delete deferreds[promise.$$timeoutId];
                            }
                            if (!skipApply) $rootScope.$apply();
                        }, delay);
                        promise.$$timeoutId = timeoutId;
                        deferreds[timeoutId] = deferred;
                        return promise;
                    }
                    timeout.cancel = function(promise) {
                        if (promise && promise.$$timeoutId in deferreds) {
                            markQExceptionHandled(deferreds[promise.$$timeoutId].promise);
                            deferreds[promise.$$timeoutId].reject("canceled");
                            delete deferreds[promise.$$timeoutId];
                            return $browser.defer.cancel(promise.$$timeoutId);
                        }
                        return false;
                    };
                    return timeout;
                } ];
            }
            var urlParsingNode = window.document.createElement("a");
            var originUrl = urlResolve(window.location.href);
            function urlResolve(url) {
                var href = url;
                if (msie) {
                    urlParsingNode.setAttribute("href", href);
                    href = urlParsingNode.href;
                }
                urlParsingNode.setAttribute("href", href);
                return {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                    host: urlParsingNode.host,
                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                    hostname: urlParsingNode.hostname,
                    port: urlParsingNode.port,
                    pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
                };
            }
            function urlIsSameOrigin(requestUrl) {
                var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
                return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
            }
            function $WindowProvider() {
                this.$get = valueFn(window);
            }
            function $$CookieReader($document) {
                var rawDocument = $document[0] || {};
                var lastCookies = {};
                var lastCookieString = "";
                function safeGetCookie(rawDocument) {
                    try {
                        return rawDocument.cookie || "";
                    } catch (e) {
                        return "";
                    }
                }
                function safeDecodeURIComponent(str) {
                    try {
                        return decodeURIComponent(str);
                    } catch (e) {
                        return str;
                    }
                }
                return function() {
                    var cookieArray, cookie, i, index, name;
                    var currentCookieString = safeGetCookie(rawDocument);
                    if (currentCookieString !== lastCookieString) {
                        lastCookieString = currentCookieString;
                        cookieArray = lastCookieString.split("; ");
                        lastCookies = {};
                        for (i = 0; i < cookieArray.length; i++) {
                            cookie = cookieArray[i];
                            index = cookie.indexOf("=");
                            if (index > 0) {
                                name = safeDecodeURIComponent(cookie.substring(0, index));
                                if (isUndefined(lastCookies[name])) {
                                    lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                                }
                            }
                        }
                    }
                    return lastCookies;
                };
            }
            $$CookieReader.$inject = [ "$document" ];
            function $$CookieReaderProvider() {
                this.$get = $$CookieReader;
            }
            $FilterProvider.$inject = [ "$provide" ];
            function $FilterProvider($provide) {
                var suffix = "Filter";
                function register(name, factory) {
                    if (isObject(name)) {
                        var filters = {};
                        forEach(name, function(filter, key) {
                            filters[key] = register(key, filter);
                        });
                        return filters;
                    } else {
                        return $provide.factory(name + suffix, factory);
                    }
                }
                this.register = register;
                this.$get = [ "$injector", function($injector) {
                    return function(name) {
                        return $injector.get(name + suffix);
                    };
                } ];
                register("currency", currencyFilter);
                register("date", dateFilter);
                register("filter", filterFilter);
                register("json", jsonFilter);
                register("limitTo", limitToFilter);
                register("lowercase", lowercaseFilter);
                register("number", numberFilter);
                register("orderBy", orderByFilter);
                register("uppercase", uppercaseFilter);
            }
            function filterFilter() {
                return function(array, expression, comparator, anyPropertyKey) {
                    if (!isArrayLike(array)) {
                        if (array == null) {
                            return array;
                        } else {
                            throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                        }
                    }
                    anyPropertyKey = anyPropertyKey || "$";
                    var expressionType = getTypeForFilter(expression);
                    var predicateFn;
                    var matchAgainstAnyProp;
                    switch (expressionType) {
                      case "function":
                        predicateFn = expression;
                        break;

                      case "boolean":
                      case "null":
                      case "number":
                      case "string":
                        matchAgainstAnyProp = true;

                      case "object":
                        predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;

                      default:
                        return array;
                    }
                    return Array.prototype.filter.call(array, predicateFn);
                };
            }
            function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
                var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
                var predicateFn;
                if (comparator === true) {
                    comparator = equals;
                } else if (!isFunction(comparator)) {
                    comparator = function(actual, expected) {
                        if (isUndefined(actual)) {
                            return false;
                        }
                        if (actual === null || expected === null) {
                            return actual === expected;
                        }
                        if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                            return false;
                        }
                        actual = lowercase("" + actual);
                        expected = lowercase("" + expected);
                        return actual.indexOf(expected) !== -1;
                    };
                }
                predicateFn = function(item) {
                    if (shouldMatchPrimitives && !isObject(item)) {
                        return deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, false);
                    }
                    return deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                };
                return predicateFn;
            }
            function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
                var actualType = getTypeForFilter(actual);
                var expectedType = getTypeForFilter(expected);
                if (expectedType === "string" && expected.charAt(0) === "!") {
                    return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
                } else if (isArray(actual)) {
                    return actual.some(function(item) {
                        return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
                    });
                }
                switch (actualType) {
                  case "object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual) {
                            if (key.charAt && key.charAt(0) !== "$" && deepCompare(actual[key], expected, comparator, anyPropertyKey, true)) {
                                return true;
                            }
                        }
                        return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, anyPropertyKey, false);
                    } else if (expectedType === "object") {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                                continue;
                            }
                            var matchAnyProperty = key === anyPropertyKey;
                            var actualVal = matchAnyProperty ? actual : actual[key];
                            if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) {
                                return false;
                            }
                        }
                        return true;
                    } else {
                        return comparator(actual, expected);
                    }

                  case "function":
                    return false;

                  default:
                    return comparator(actual, expected);
                }
            }
            function getTypeForFilter(val) {
                return val === null ? "null" : typeof val;
            }
            var MAX_DIGITS = 22;
            var DECIMAL_SEP = ".";
            var ZERO_CHAR = "0";
            currencyFilter.$inject = [ "$locale" ];
            function currencyFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function(amount, currencySymbol, fractionSize) {
                    if (isUndefined(currencySymbol)) {
                        currencySymbol = formats.CURRENCY_SYM;
                    }
                    if (isUndefined(fractionSize)) {
                        fractionSize = formats.PATTERNS[1].maxFrac;
                    }
                    return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
                };
            }
            numberFilter.$inject = [ "$locale" ];
            function numberFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function(number, fractionSize) {
                    return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
                };
            }
            function parse(numStr) {
                var exponent = 0, digits, numberOfIntegerDigits;
                var i, j, zeros;
                if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
                    numStr = numStr.replace(DECIMAL_SEP, "");
                }
                if ((i = numStr.search(/e/i)) > 0) {
                    if (numberOfIntegerDigits < 0) numberOfIntegerDigits = i;
                    numberOfIntegerDigits += +numStr.slice(i + 1);
                    numStr = numStr.substring(0, i);
                } else if (numberOfIntegerDigits < 0) {
                    numberOfIntegerDigits = numStr.length;
                }
                for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {}
                if (i === (zeros = numStr.length)) {
                    digits = [ 0 ];
                    numberOfIntegerDigits = 1;
                } else {
                    zeros--;
                    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;
                    numberOfIntegerDigits -= i;
                    digits = [];
                    for (j = 0; i <= zeros; i++, j++) {
                        digits[j] = +numStr.charAt(i);
                    }
                }
                if (numberOfIntegerDigits > MAX_DIGITS) {
                    digits = digits.splice(0, MAX_DIGITS - 1);
                    exponent = numberOfIntegerDigits - 1;
                    numberOfIntegerDigits = 1;
                }
                return {
                    d: digits,
                    e: exponent,
                    i: numberOfIntegerDigits
                };
            }
            function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
                var digits = parsedNumber.d;
                var fractionLen = digits.length - parsedNumber.i;
                fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
                var roundAt = fractionSize + parsedNumber.i;
                var digit = digits[roundAt];
                if (roundAt > 0) {
                    digits.splice(Math.max(parsedNumber.i, roundAt));
                    for (var j = roundAt; j < digits.length; j++) {
                        digits[j] = 0;
                    }
                } else {
                    fractionLen = Math.max(0, fractionLen);
                    parsedNumber.i = 1;
                    digits.length = Math.max(1, roundAt = fractionSize + 1);
                    digits[0] = 0;
                    for (var i = 1; i < roundAt; i++) digits[i] = 0;
                }
                if (digit >= 5) {
                    if (roundAt - 1 < 0) {
                        for (var k = 0; k > roundAt; k--) {
                            digits.unshift(0);
                            parsedNumber.i++;
                        }
                        digits.unshift(1);
                        parsedNumber.i++;
                    } else {
                        digits[roundAt - 1]++;
                    }
                }
                for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
                var carry = digits.reduceRight(function(carry, d, i, digits) {
                    d = d + carry;
                    digits[i] = d % 10;
                    return Math.floor(d / 10);
                }, 0);
                if (carry) {
                    digits.unshift(carry);
                    parsedNumber.i++;
                }
            }
            function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
                if (!(isString(number) || isNumber(number)) || isNaN(number)) return "";
                var isInfinity = !isFinite(number);
                var isZero = false;
                var numStr = Math.abs(number) + "", formattedText = "", parsedNumber;
                if (isInfinity) {
                    formattedText = "∞";
                } else {
                    parsedNumber = parse(numStr);
                    roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                    var digits = parsedNumber.d;
                    var integerLen = parsedNumber.i;
                    var exponent = parsedNumber.e;
                    var decimals = [];
                    isZero = digits.reduce(function(isZero, d) {
                        return isZero && !d;
                    }, true);
                    while (integerLen < 0) {
                        digits.unshift(0);
                        integerLen++;
                    }
                    if (integerLen > 0) {
                        decimals = digits.splice(integerLen, digits.length);
                    } else {
                        decimals = digits;
                        digits = [ 0 ];
                    }
                    var groups = [];
                    if (digits.length >= pattern.lgSize) {
                        groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(""));
                    }
                    while (digits.length > pattern.gSize) {
                        groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                    }
                    if (digits.length) {
                        groups.unshift(digits.join(""));
                    }
                    formattedText = groups.join(groupSep);
                    if (decimals.length) {
                        formattedText += decimalSep + decimals.join("");
                    }
                    if (exponent) {
                        formattedText += "e+" + exponent;
                    }
                }
                if (number < 0 && !isZero) {
                    return pattern.negPre + formattedText + pattern.negSuf;
                } else {
                    return pattern.posPre + formattedText + pattern.posSuf;
                }
            }
            function padNumber(num, digits, trim, negWrap) {
                var neg = "";
                if (num < 0 || negWrap && num <= 0) {
                    if (negWrap) {
                        num = -num + 1;
                    } else {
                        num = -num;
                        neg = "-";
                    }
                }
                num = "" + num;
                while (num.length < digits) num = ZERO_CHAR + num;
                if (trim) {
                    num = num.substr(num.length - digits);
                }
                return neg + num;
            }
            function dateGetter(name, size, offset, trim, negWrap) {
                offset = offset || 0;
                return function(date) {
                    var value = date["get" + name]();
                    if (offset > 0 || value > -offset) {
                        value += offset;
                    }
                    if (value === 0 && offset === -12) value = 12;
                    return padNumber(value, size, trim, negWrap);
                };
            }
            function dateStrGetter(name, shortForm, standAlone) {
                return function(date, formats) {
                    var value = date["get" + name]();
                    var propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "");
                    var get = uppercase(propPrefix + name);
                    return formats[get][value];
                };
            }
            function timeZoneGetter(date, formats, offset) {
                var zone = -1 * offset;
                var paddedZone = zone >= 0 ? "+" : "";
                paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
                return paddedZone;
            }
            function getFirstThursdayOfYear(year) {
                var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
                return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
            }
            function getThursdayThisWeek(datetime) {
                return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
            }
            function weekGetter(size) {
                return function(date) {
                    var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
                    var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
                    return padNumber(result, size);
                };
            }
            function ampmGetter(date, formats) {
                return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
            }
            function eraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
            }
            function longEraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
            }
            var DATE_FORMATS = {
                yyyy: dateGetter("FullYear", 4, 0, false, true),
                yy: dateGetter("FullYear", 2, 0, true, true),
                y: dateGetter("FullYear", 1, 0, false, true),
                MMMM: dateStrGetter("Month"),
                MMM: dateStrGetter("Month", true),
                MM: dateGetter("Month", 2, 1),
                M: dateGetter("Month", 1, 1),
                LLLL: dateStrGetter("Month", false, true),
                dd: dateGetter("Date", 2),
                d: dateGetter("Date", 1),
                HH: dateGetter("Hours", 2),
                H: dateGetter("Hours", 1),
                hh: dateGetter("Hours", 2, -12),
                h: dateGetter("Hours", 1, -12),
                mm: dateGetter("Minutes", 2),
                m: dateGetter("Minutes", 1),
                ss: dateGetter("Seconds", 2),
                s: dateGetter("Seconds", 1),
                sss: dateGetter("Milliseconds", 3),
                EEEE: dateStrGetter("Day"),
                EEE: dateStrGetter("Day", true),
                a: ampmGetter,
                Z: timeZoneGetter,
                ww: weekGetter(2),
                w: weekGetter(1),
                G: eraGetter,
                GG: eraGetter,
                GGG: eraGetter,
                GGGG: longEraGetter
            };
            var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
            dateFilter.$inject = [ "$locale" ];
            function dateFilter($locale) {
                var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                function jsonStringToDate(string) {
                    var match;
                    if (match = string.match(R_ISO8601_STR)) {
                        var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                        if (match[9]) {
                            tzHour = toInt(match[9] + match[10]);
                            tzMin = toInt(match[9] + match[11]);
                        }
                        dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                        var h = toInt(match[4] || 0) - tzHour;
                        var m = toInt(match[5] || 0) - tzMin;
                        var s = toInt(match[6] || 0);
                        var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3);
                        timeSetter.call(date, h, m, s, ms);
                        return date;
                    }
                    return string;
                }
                return function(date, format, timezone) {
                    var text = "", parts = [], fn, match;
                    format = format || "mediumDate";
                    format = $locale.DATETIME_FORMATS[format] || format;
                    if (isString(date)) {
                        date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
                    }
                    if (isNumber(date)) {
                        date = new Date(date);
                    }
                    if (!isDate(date) || !isFinite(date.getTime())) {
                        return date;
                    }
                    while (format) {
                        match = DATE_FORMATS_SPLIT.exec(format);
                        if (match) {
                            parts = concat(parts, match, 1);
                            format = parts.pop();
                        } else {
                            parts.push(format);
                            format = null;
                        }
                    }
                    var dateTimezoneOffset = date.getTimezoneOffset();
                    if (timezone) {
                        dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                        date = convertTimezoneToLocal(date, timezone, true);
                    }
                    forEach(parts, function(value) {
                        fn = DATE_FORMATS[value];
                        text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
                    });
                    return text;
                };
            }
            function jsonFilter() {
                return function(object, spacing) {
                    if (isUndefined(spacing)) {
                        spacing = 2;
                    }
                    return toJson(object, spacing);
                };
            }
            var lowercaseFilter = valueFn(lowercase);
            var uppercaseFilter = valueFn(uppercase);
            function limitToFilter() {
                return function(input, limit, begin) {
                    if (Math.abs(Number(limit)) === Infinity) {
                        limit = Number(limit);
                    } else {
                        limit = toInt(limit);
                    }
                    if (isNumberNaN(limit)) return input;
                    if (isNumber(input)) input = input.toString();
                    if (!isArrayLike(input)) return input;
                    begin = !begin || isNaN(begin) ? 0 : toInt(begin);
                    begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
                    if (limit >= 0) {
                        return sliceFn(input, begin, begin + limit);
                    } else {
                        if (begin === 0) {
                            return sliceFn(input, limit, input.length);
                        } else {
                            return sliceFn(input, Math.max(0, begin + limit), begin);
                        }
                    }
                };
            }
            function sliceFn(input, begin, end) {
                if (isString(input)) return input.slice(begin, end);
                return slice.call(input, begin, end);
            }
            orderByFilter.$inject = [ "$parse" ];
            function orderByFilter($parse) {
                return function(array, sortPredicate, reverseOrder, compareFn) {
                    if (array == null) return array;
                    if (!isArrayLike(array)) {
                        throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                    }
                    if (!isArray(sortPredicate)) {
                        sortPredicate = [ sortPredicate ];
                    }
                    if (sortPredicate.length === 0) {
                        sortPredicate = [ "+" ];
                    }
                    var predicates = processPredicates(sortPredicate);
                    var descending = reverseOrder ? -1 : 1;
                    var compare = isFunction(compareFn) ? compareFn : defaultCompare;
                    var compareValues = Array.prototype.map.call(array, getComparisonObject);
                    compareValues.sort(doComparison);
                    array = compareValues.map(function(item) {
                        return item.value;
                    });
                    return array;
                    function getComparisonObject(value, index) {
                        return {
                            value: value,
                            tieBreaker: {
                                value: index,
                                type: "number",
                                index: index
                            },
                            predicateValues: predicates.map(function(predicate) {
                                return getPredicateValue(predicate.get(value), index);
                            })
                        };
                    }
                    function doComparison(v1, v2) {
                        for (var i = 0, ii = predicates.length; i < ii; i++) {
                            var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                            if (result) {
                                return result * predicates[i].descending * descending;
                            }
                        }
                        return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
                    }
                };
                function processPredicates(sortPredicates) {
                    return sortPredicates.map(function(predicate) {
                        var descending = 1, get = identity;
                        if (isFunction(predicate)) {
                            get = predicate;
                        } else if (isString(predicate)) {
                            if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
                                descending = predicate.charAt(0) === "-" ? -1 : 1;
                                predicate = predicate.substring(1);
                            }
                            if (predicate !== "") {
                                get = $parse(predicate);
                                if (get.constant) {
                                    var key = get();
                                    get = function(value) {
                                        return value[key];
                                    };
                                }
                            }
                        }
                        return {
                            get: get,
                            descending: descending
                        };
                    });
                }
                function isPrimitive(value) {
                    switch (typeof value) {
                      case "number":
                      case "boolean":
                      case "string":
                        return true;

                      default:
                        return false;
                    }
                }
                function objectValue(value) {
                    if (isFunction(value.valueOf)) {
                        value = value.valueOf();
                        if (isPrimitive(value)) return value;
                    }
                    if (hasCustomToString(value)) {
                        value = value.toString();
                        if (isPrimitive(value)) return value;
                    }
                    return value;
                }
                function getPredicateValue(value, index) {
                    var type = typeof value;
                    if (value === null) {
                        type = "string";
                        value = "null";
                    } else if (type === "object") {
                        value = objectValue(value);
                    }
                    return {
                        value: value,
                        type: type,
                        index: index
                    };
                }
                function defaultCompare(v1, v2) {
                    var result = 0;
                    var type1 = v1.type;
                    var type2 = v2.type;
                    if (type1 === type2) {
                        var value1 = v1.value;
                        var value2 = v2.value;
                        if (type1 === "string") {
                            value1 = value1.toLowerCase();
                            value2 = value2.toLowerCase();
                        } else if (type1 === "object") {
                            if (isObject(value1)) value1 = v1.index;
                            if (isObject(value2)) value2 = v2.index;
                        }
                        if (value1 !== value2) {
                            result = value1 < value2 ? -1 : 1;
                        }
                    } else {
                        result = type1 < type2 ? -1 : 1;
                    }
                    return result;
                }
            }
            function ngDirective(directive) {
                if (isFunction(directive)) {
                    directive = {
                        link: directive
                    };
                }
                directive.restrict = directive.restrict || "AC";
                return valueFn(directive);
            }
            var htmlAnchorDirective = valueFn({
                restrict: "E",
                compile: function(element, attr) {
                    if (!attr.href && !attr.xlinkHref) {
                        return function(scope, element) {
                            if (element[0].nodeName.toLowerCase() !== "a") return;
                            var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href";
                            element.on("click", function(event) {
                                if (!element.attr(href)) {
                                    event.preventDefault();
                                }
                            });
                        };
                    }
                }
            });
            var ngAttributeAliasDirectives = {};
            forEach(BOOLEAN_ATTR, function(propName, attrName) {
                if (propName === "multiple") return;
                function defaultLinkFn(scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value);
                    });
                }
                var normalized = directiveNormalize("ng-" + attrName);
                var linkFn = defaultLinkFn;
                if (propName === "checked") {
                    linkFn = function(scope, element, attr) {
                        if (attr.ngModel !== attr[normalized]) {
                            defaultLinkFn(scope, element, attr);
                        }
                    };
                }
                ngAttributeAliasDirectives[normalized] = function() {
                    return {
                        restrict: "A",
                        priority: 100,
                        link: linkFn
                    };
                };
            });
            forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
                ngAttributeAliasDirectives[ngAttr] = function() {
                    return {
                        priority: 100,
                        link: function(scope, element, attr) {
                            if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
                                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                                if (match) {
                                    attr.$set("ngPattern", new RegExp(match[1], match[2]));
                                    return;
                                }
                            }
                            scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                                attr.$set(ngAttr, value);
                            });
                        }
                    };
                };
            });
            forEach([ "src", "srcset", "href" ], function(attrName) {
                var normalized = directiveNormalize("ng-" + attrName);
                ngAttributeAliasDirectives[normalized] = function() {
                    return {
                        priority: 99,
                        link: function(scope, element, attr) {
                            var propName = attrName, name = attrName;
                            if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                                name = "xlinkHref";
                                attr.$attr[name] = "xlink:href";
                                propName = null;
                            }
                            attr.$observe(normalized, function(value) {
                                if (!value) {
                                    if (attrName === "href") {
                                        attr.$set(name, null);
                                    }
                                    return;
                                }
                                attr.$set(name, value);
                                if (msie && propName) element.prop(propName, attr[name]);
                            });
                        }
                    };
                };
            });
            var nullFormCtrl = {
                $addControl: noop,
                $$renameControl: nullFormRenameControl,
                $removeControl: noop,
                $setValidity: noop,
                $setDirty: noop,
                $setPristine: noop,
                $setSubmitted: noop
            }, PENDING_CLASS = "ng-pending", SUBMITTED_CLASS = "ng-submitted";
            function nullFormRenameControl(control, name) {
                control.$name = name;
            }
            FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
            function FormController($element, $attrs, $scope, $animate, $interpolate) {
                this.$$controls = [];
                this.$error = {};
                this.$$success = {};
                this.$pending = undefined;
                this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope);
                this.$dirty = false;
                this.$pristine = true;
                this.$valid = true;
                this.$invalid = false;
                this.$submitted = false;
                this.$$parentForm = nullFormCtrl;
                this.$$element = $element;
                this.$$animate = $animate;
                setupValidity(this);
            }
            FormController.prototype = {
                $rollbackViewValue: function() {
                    forEach(this.$$controls, function(control) {
                        control.$rollbackViewValue();
                    });
                },
                $commitViewValue: function() {
                    forEach(this.$$controls, function(control) {
                        control.$commitViewValue();
                    });
                },
                $addControl: function(control) {
                    assertNotHasOwnProperty(control.$name, "input");
                    this.$$controls.push(control);
                    if (control.$name) {
                        this[control.$name] = control;
                    }
                    control.$$parentForm = this;
                },
                $$renameControl: function(control, newName) {
                    var oldName = control.$name;
                    if (this[oldName] === control) {
                        delete this[oldName];
                    }
                    this[newName] = control;
                    control.$name = newName;
                },
                $removeControl: function(control) {
                    if (control.$name && this[control.$name] === control) {
                        delete this[control.$name];
                    }
                    forEach(this.$pending, function(value, name) {
                        this.$setValidity(name, null, control);
                    }, this);
                    forEach(this.$error, function(value, name) {
                        this.$setValidity(name, null, control);
                    }, this);
                    forEach(this.$$success, function(value, name) {
                        this.$setValidity(name, null, control);
                    }, this);
                    arrayRemove(this.$$controls, control);
                    control.$$parentForm = nullFormCtrl;
                },
                $setDirty: function() {
                    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
                    this.$$animate.addClass(this.$$element, DIRTY_CLASS);
                    this.$dirty = true;
                    this.$pristine = false;
                    this.$$parentForm.$setDirty();
                },
                $setPristine: function() {
                    this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS);
                    this.$dirty = false;
                    this.$pristine = true;
                    this.$submitted = false;
                    forEach(this.$$controls, function(control) {
                        control.$setPristine();
                    });
                },
                $setUntouched: function() {
                    forEach(this.$$controls, function(control) {
                        control.$setUntouched();
                    });
                },
                $setSubmitted: function() {
                    this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
                    this.$submitted = true;
                    this.$$parentForm.$setSubmitted();
                }
            };
            addSetValidityMethod({
                clazz: FormController,
                set: function(object, property, controller) {
                    var list = object[property];
                    if (!list) {
                        object[property] = [ controller ];
                    } else {
                        var index = list.indexOf(controller);
                        if (index === -1) {
                            list.push(controller);
                        }
                    }
                },
                unset: function(object, property, controller) {
                    var list = object[property];
                    if (!list) {
                        return;
                    }
                    arrayRemove(list, controller);
                    if (list.length === 0) {
                        delete object[property];
                    }
                }
            });
            var formDirectiveFactory = function(isNgForm) {
                return [ "$timeout", "$parse", function($timeout, $parse) {
                    var formDirective = {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        require: [ "form", "^^?form" ],
                        controller: FormController,
                        compile: function ngFormCompile(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : false;
                            return {
                                pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!("action" in attr)) {
                                        var handleFormSubmission = function(event) {
                                            scope.$apply(function() {
                                                controller.$commitViewValue();
                                                controller.$setSubmitted();
                                            });
                                            event.preventDefault();
                                        };
                                        formElement[0].addEventListener("submit", handleFormSubmission);
                                        formElement.on("$destroy", function() {
                                            $timeout(function() {
                                                formElement[0].removeEventListener("submit", handleFormSubmission);
                                            }, 0, false);
                                        });
                                    }
                                    var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                    parentFormCtrl.$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    if (nameAttr) {
                                        setter(scope, controller);
                                        attr.$observe(nameAttr, function(newValue) {
                                            if (controller.$name === newValue) return;
                                            setter(scope, undefined);
                                            controller.$$parentForm.$$renameControl(controller, newValue);
                                            setter = getSetter(controller.$name);
                                            setter(scope, controller);
                                        });
                                    }
                                    formElement.on("$destroy", function() {
                                        controller.$$parentForm.$removeControl(controller);
                                        setter(scope, undefined);
                                        extend(controller, nullFormCtrl);
                                    });
                                }
                            };
                        }
                    };
                    return formDirective;
                    function getSetter(expression) {
                        if (expression === "") {
                            return $parse('this[""]').assign;
                        }
                        return $parse(expression).assign || noop;
                    }
                } ];
            };
            var formDirective = formDirectiveFactory();
            var ngFormDirective = formDirectiveFactory(true);
            function setupValidity(instance) {
                instance.$$classCache = {};
                instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
            }
            function addSetValidityMethod(context) {
                var clazz = context.clazz, set = context.set, unset = context.unset;
                clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
                    if (isUndefined(state)) {
                        createAndSet(this, "$pending", validationErrorKey, controller);
                    } else {
                        unsetAndCleanup(this, "$pending", validationErrorKey, controller);
                    }
                    if (!isBoolean(state)) {
                        unset(this.$error, validationErrorKey, controller);
                        unset(this.$$success, validationErrorKey, controller);
                    } else {
                        if (state) {
                            unset(this.$error, validationErrorKey, controller);
                            set(this.$$success, validationErrorKey, controller);
                        } else {
                            set(this.$error, validationErrorKey, controller);
                            unset(this.$$success, validationErrorKey, controller);
                        }
                    }
                    if (this.$pending) {
                        cachedToggleClass(this, PENDING_CLASS, true);
                        this.$valid = this.$invalid = undefined;
                        toggleValidationCss(this, "", null);
                    } else {
                        cachedToggleClass(this, PENDING_CLASS, false);
                        this.$valid = isObjectEmpty(this.$error);
                        this.$invalid = !this.$valid;
                        toggleValidationCss(this, "", this.$valid);
                    }
                    var combinedState;
                    if (this.$pending && this.$pending[validationErrorKey]) {
                        combinedState = undefined;
                    } else if (this.$error[validationErrorKey]) {
                        combinedState = false;
                    } else if (this.$$success[validationErrorKey]) {
                        combinedState = true;
                    } else {
                        combinedState = null;
                    }
                    toggleValidationCss(this, validationErrorKey, combinedState);
                    this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
                };
                function createAndSet(ctrl, name, value, controller) {
                    if (!ctrl[name]) {
                        ctrl[name] = {};
                    }
                    set(ctrl[name], value, controller);
                }
                function unsetAndCleanup(ctrl, name, value, controller) {
                    if (ctrl[name]) {
                        unset(ctrl[name], value, controller);
                    }
                    if (isObjectEmpty(ctrl[name])) {
                        ctrl[name] = undefined;
                    }
                }
                function cachedToggleClass(ctrl, className, switchValue) {
                    if (switchValue && !ctrl.$$classCache[className]) {
                        ctrl.$$animate.addClass(ctrl.$$element, className);
                        ctrl.$$classCache[className] = true;
                    } else if (!switchValue && ctrl.$$classCache[className]) {
                        ctrl.$$animate.removeClass(ctrl.$$element, className);
                        ctrl.$$classCache[className] = false;
                    }
                }
                function toggleValidationCss(ctrl, validationErrorKey, isValid) {
                    validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "";
                    cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === true);
                    cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === false);
                }
            }
            function isObjectEmpty(obj) {
                if (obj) {
                    for (var prop in obj) {
                        if (obj.hasOwnProperty(prop)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
            var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
            var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
            var NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
            var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
            var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
            var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
            var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
            var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
            var PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";
            var PARTIAL_VALIDATION_TYPES = createMap();
            forEach("date,datetime-local,month,time,week".split(","), function(type) {
                PARTIAL_VALIDATION_TYPES[type] = true;
            });
            var inputType = {
                text: textInputType,
                date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
                "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
                time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
                week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
                month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
                number: numberInputType,
                url: urlInputType,
                email: emailInputType,
                radio: radioInputType,
                range: rangeInputType,
                checkbox: checkboxInputType,
                hidden: noop,
                button: noop,
                submit: noop,
                reset: noop,
                file: noop
            };
            function stringBasedInputType(ctrl) {
                ctrl.$formatters.push(function(value) {
                    return ctrl.$isEmpty(value) ? value : value.toString();
                });
            }
            function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                stringBasedInputType(ctrl);
            }
            function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                var type = lowercase(element[0].type);
                if (!$sniffer.android) {
                    var composing = false;
                    element.on("compositionstart", function() {
                        composing = true;
                    });
                    element.on("compositionend", function() {
                        composing = false;
                        listener();
                    });
                }
                var timeout;
                var listener = function(ev) {
                    if (timeout) {
                        $browser.defer.cancel(timeout);
                        timeout = null;
                    }
                    if (composing) return;
                    var value = element.val(), event = ev && ev.type;
                    if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
                        value = trim(value);
                    }
                    if (ctrl.$viewValue !== value || value === "" && ctrl.$$hasNativeValidators) {
                        ctrl.$setViewValue(value, event);
                    }
                };
                if ($sniffer.hasEvent("input")) {
                    element.on("input", listener);
                } else {
                    var deferListener = function(ev, input, origValue) {
                        if (!timeout) {
                            timeout = $browser.defer(function() {
                                timeout = null;
                                if (!input || input.value !== origValue) {
                                    listener(ev);
                                }
                            });
                        }
                    };
                    element.on("keydown", function(event) {
                        var key = event.keyCode;
                        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40) return;
                        deferListener(event, this, this.value);
                    });
                    if ($sniffer.hasEvent("paste")) {
                        element.on("paste cut", deferListener);
                    }
                }
                element.on("change", listener);
                if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
                    element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
                        if (!timeout) {
                            var validity = this[VALIDITY_STATE_PROPERTY];
                            var origBadInput = validity.badInput;
                            var origTypeMismatch = validity.typeMismatch;
                            timeout = $browser.defer(function() {
                                timeout = null;
                                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                                    listener(ev);
                                }
                            });
                        }
                    });
                }
                ctrl.$render = function() {
                    var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                    if (element.val() !== value) {
                        element.val(value);
                    }
                };
            }
            function weekParser(isoWeek, existingDate) {
                if (isDate(isoWeek)) {
                    return isoWeek;
                }
                if (isString(isoWeek)) {
                    WEEK_REGEXP.lastIndex = 0;
                    var parts = WEEK_REGEXP.exec(isoWeek);
                    if (parts) {
                        var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                        if (existingDate) {
                            hours = existingDate.getHours();
                            minutes = existingDate.getMinutes();
                            seconds = existingDate.getSeconds();
                            milliseconds = existingDate.getMilliseconds();
                        }
                        return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                    }
                }
                return NaN;
            }
            function createDateParser(regexp, mapping) {
                return function(iso, date) {
                    var parts, map;
                    if (isDate(iso)) {
                        return iso;
                    }
                    if (isString(iso)) {
                        if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
                            iso = iso.substring(1, iso.length - 1);
                        }
                        if (ISO_DATE_REGEXP.test(iso)) {
                            return new Date(iso);
                        }
                        regexp.lastIndex = 0;
                        parts = regexp.exec(iso);
                        if (parts) {
                            parts.shift();
                            if (date) {
                                map = {
                                    yyyy: date.getFullYear(),
                                    MM: date.getMonth() + 1,
                                    dd: date.getDate(),
                                    HH: date.getHours(),
                                    mm: date.getMinutes(),
                                    ss: date.getSeconds(),
                                    sss: date.getMilliseconds() / 1e3
                                };
                            } else {
                                map = {
                                    yyyy: 1970,
                                    MM: 1,
                                    dd: 1,
                                    HH: 0,
                                    mm: 0,
                                    ss: 0,
                                    sss: 0
                                };
                            }
                            forEach(parts, function(part, index) {
                                if (index < mapping.length) {
                                    map[mapping[index]] = +part;
                                }
                            });
                            return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1e3 || 0);
                        }
                    }
                    return NaN;
                };
            }
            function createDateInputType(type, regexp, parseDate, format) {
                return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
                    badInputChecker(scope, element, attr, ctrl);
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                    var timezone = ctrl && ctrl.$options.getOption("timezone");
                    var previousDate;
                    ctrl.$$parserName = type;
                    ctrl.$parsers.push(function(value) {
                        if (ctrl.$isEmpty(value)) return null;
                        if (regexp.test(value)) {
                            var parsedDate = parseDate(value, previousDate);
                            if (timezone) {
                                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                            }
                            return parsedDate;
                        }
                        return undefined;
                    });
                    ctrl.$formatters.push(function(value) {
                        if (value && !isDate(value)) {
                            throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                        }
                        if (isValidDate(value)) {
                            previousDate = value;
                            if (previousDate && timezone) {
                                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                            }
                            return $filter("date")(value, format, timezone);
                        } else {
                            previousDate = null;
                            return "";
                        }
                    });
                    if (isDefined(attr.min) || attr.ngMin) {
                        var minVal;
                        ctrl.$validators.min = function(value) {
                            return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                        };
                        attr.$observe("min", function(val) {
                            minVal = parseObservedDateValue(val);
                            ctrl.$validate();
                        });
                    }
                    if (isDefined(attr.max) || attr.ngMax) {
                        var maxVal;
                        ctrl.$validators.max = function(value) {
                            return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                        };
                        attr.$observe("max", function(val) {
                            maxVal = parseObservedDateValue(val);
                            ctrl.$validate();
                        });
                    }
                    function isValidDate(value) {
                        return value && !(value.getTime && value.getTime() !== value.getTime());
                    }
                    function parseObservedDateValue(val) {
                        return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
                    }
                };
            }
            function badInputChecker(scope, element, attr, ctrl) {
                var node = element[0];
                var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
                if (nativeValidation) {
                    ctrl.$parsers.push(function(value) {
                        var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                        return validity.badInput || validity.typeMismatch ? undefined : value;
                    });
                }
            }
            function numberFormatterParser(ctrl) {
                ctrl.$$parserName = "number";
                ctrl.$parsers.push(function(value) {
                    if (ctrl.$isEmpty(value)) return null;
                    if (NUMBER_REGEXP.test(value)) return parseFloat(value);
                    return undefined;
                });
                ctrl.$formatters.push(function(value) {
                    if (!ctrl.$isEmpty(value)) {
                        if (!isNumber(value)) {
                            throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                        }
                        value = value.toString();
                    }
                    return value;
                });
            }
            function parseNumberAttrVal(val) {
                if (isDefined(val) && !isNumber(val)) {
                    val = parseFloat(val);
                }
                return !isNumberNaN(val) ? val : undefined;
            }
            function isNumberInteger(num) {
                return (num | 0) === num;
            }
            function countDecimals(num) {
                var numString = num.toString();
                var decimalSymbolIndex = numString.indexOf(".");
                if (decimalSymbolIndex === -1) {
                    if (-1 < num && num < 1) {
                        var match = /e-(\d+)$/.exec(numString);
                        if (match) {
                            return Number(match[1]);
                        }
                    }
                    return 0;
                }
                return numString.length - decimalSymbolIndex - 1;
            }
            function isValidForStep(viewValue, stepBase, step) {
                var value = Number(viewValue);
                var isNonIntegerValue = !isNumberInteger(value);
                var isNonIntegerStepBase = !isNumberInteger(stepBase);
                var isNonIntegerStep = !isNumberInteger(step);
                if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
                    var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;
                    var stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;
                    var stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;
                    var decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals);
                    var multiplier = Math.pow(10, decimalCount);
                    value = value * multiplier;
                    stepBase = stepBase * multiplier;
                    step = step * multiplier;
                    if (isNonIntegerValue) value = Math.round(value);
                    if (isNonIntegerStepBase) stepBase = Math.round(stepBase);
                    if (isNonIntegerStep) step = Math.round(step);
                }
                return (value - stepBase) % step === 0;
            }
            function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                badInputChecker(scope, element, attr, ctrl);
                numberFormatterParser(ctrl);
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var minVal;
                var maxVal;
                if (isDefined(attr.min) || attr.ngMin) {
                    ctrl.$validators.min = function(value) {
                        return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
                    };
                    attr.$observe("min", function(val) {
                        minVal = parseNumberAttrVal(val);
                        ctrl.$validate();
                    });
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    ctrl.$validators.max = function(value) {
                        return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
                    };
                    attr.$observe("max", function(val) {
                        maxVal = parseNumberAttrVal(val);
                        ctrl.$validate();
                    });
                }
                if (isDefined(attr.step) || attr.ngStep) {
                    var stepVal;
                    ctrl.$validators.step = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
                    };
                    attr.$observe("step", function(val) {
                        stepVal = parseNumberAttrVal(val);
                        ctrl.$validate();
                    });
                }
            }
            function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                badInputChecker(scope, element, attr, ctrl);
                numberFormatterParser(ctrl);
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var supportsRange = ctrl.$$hasNativeValidators && element[0].type === "range", minVal = supportsRange ? 0 : undefined, maxVal = supportsRange ? 100 : undefined, stepVal = supportsRange ? 1 : undefined, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step);
                var originalRender = ctrl.$render;
                ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function rangeRender() {
                    originalRender();
                    ctrl.$setViewValue(element.val());
                } : originalRender;
                if (hasMinAttr) {
                    ctrl.$validators.min = supportsRange ? function noopMinValidator() {
                        return true;
                    } : function minValidator(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
                    };
                    setInitialValueAndObserver("min", minChange);
                }
                if (hasMaxAttr) {
                    ctrl.$validators.max = supportsRange ? function noopMaxValidator() {
                        return true;
                    } : function maxValidator(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
                    };
                    setInitialValueAndObserver("max", maxChange);
                }
                if (hasStepAttr) {
                    ctrl.$validators.step = supportsRange ? function nativeStepValidator() {
                        return !validity.stepMismatch;
                    } : function stepValidator(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
                    };
                    setInitialValueAndObserver("step", stepChange);
                }
                function setInitialValueAndObserver(htmlAttrName, changeFn) {
                    element.attr(htmlAttrName, attr[htmlAttrName]);
                    attr.$observe(htmlAttrName, changeFn);
                }
                function minChange(val) {
                    minVal = parseNumberAttrVal(val);
                    if (isNumberNaN(ctrl.$modelValue)) {
                        return;
                    }
                    if (supportsRange) {
                        var elVal = element.val();
                        if (minVal > elVal) {
                            elVal = minVal;
                            element.val(elVal);
                        }
                        ctrl.$setViewValue(elVal);
                    } else {
                        ctrl.$validate();
                    }
                }
                function maxChange(val) {
                    maxVal = parseNumberAttrVal(val);
                    if (isNumberNaN(ctrl.$modelValue)) {
                        return;
                    }
                    if (supportsRange) {
                        var elVal = element.val();
                        if (maxVal < elVal) {
                            element.val(maxVal);
                            elVal = maxVal < minVal ? minVal : maxVal;
                        }
                        ctrl.$setViewValue(elVal);
                    } else {
                        ctrl.$validate();
                    }
                }
                function stepChange(val) {
                    stepVal = parseNumberAttrVal(val);
                    if (isNumberNaN(ctrl.$modelValue)) {
                        return;
                    }
                    if (supportsRange && ctrl.$viewValue !== element.val()) {
                        ctrl.$setViewValue(element.val());
                    } else {
                        ctrl.$validate();
                    }
                }
            }
            function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                stringBasedInputType(ctrl);
                ctrl.$$parserName = "url";
                ctrl.$validators.url = function(modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
                };
            }
            function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                stringBasedInputType(ctrl);
                ctrl.$$parserName = "email";
                ctrl.$validators.email = function(modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
                };
            }
            function radioInputType(scope, element, attr, ctrl) {
                var doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";
                if (isUndefined(attr.name)) {
                    element.attr("name", nextUid());
                }
                var listener = function(ev) {
                    var value;
                    if (element[0].checked) {
                        value = attr.value;
                        if (doTrim) {
                            value = trim(value);
                        }
                        ctrl.$setViewValue(value, ev && ev.type);
                    }
                };
                element.on("click", listener);
                ctrl.$render = function() {
                    var value = attr.value;
                    if (doTrim) {
                        value = trim(value);
                    }
                    element[0].checked = value === ctrl.$viewValue;
                };
                attr.$observe("value", ctrl.$render);
            }
            function parseConstantExpr($parse, context, name, expression, fallback) {
                var parseFn;
                if (isDefined(expression)) {
                    parseFn = $parse(expression);
                    if (!parseFn.constant) {
                        throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw " + "`{1}`.", name, expression);
                    }
                    return parseFn(context);
                }
                return fallback;
            }
            function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, true);
                var falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, false);
                var listener = function(ev) {
                    ctrl.$setViewValue(element[0].checked, ev && ev.type);
                };
                element.on("click", listener);
                ctrl.$render = function() {
                    element[0].checked = ctrl.$viewValue;
                };
                ctrl.$isEmpty = function(value) {
                    return value === false;
                };
                ctrl.$formatters.push(function(value) {
                    return equals(value, trueValue);
                });
                ctrl.$parsers.push(function(value) {
                    return value ? trueValue : falseValue;
                });
            }
            var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: "E",
                    require: [ "?ngModel" ],
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            if (ctrls[0]) {
                                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                            }
                        }
                    }
                };
            } ];
            var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
            var ngValueDirective = function() {
                function updateElementValue(element, attr, value) {
                    var propValue = isDefined(value) ? value : msie === 9 ? "" : null;
                    element.prop("value", propValue);
                    attr.$set("value", value);
                }
                return {
                    restrict: "A",
                    priority: 100,
                    compile: function(tpl, tplAttr) {
                        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                            return function ngValueConstantLink(scope, elm, attr) {
                                var value = scope.$eval(attr.ngValue);
                                updateElementValue(elm, attr, value);
                            };
                        } else {
                            return function ngValueLink(scope, elm, attr) {
                                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                                    updateElementValue(elm, attr, value);
                                });
                            };
                        }
                    }
                };
            };
            var ngBindDirective = [ "$compile", function($compile) {
                return {
                    restrict: "AC",
                    compile: function ngBindCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBind);
                            element = element[0];
                            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                                element.textContent = stringify(value);
                            });
                        };
                    }
                };
            } ];
            var ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
                return {
                    compile: function ngBindTemplateCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindTemplateLink(scope, element, attr) {
                            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                            $compile.$$addBindingInfo(element, interpolateFn.expressions);
                            element = element[0];
                            attr.$observe("ngBindTemplate", function(value) {
                                element.textContent = isUndefined(value) ? "" : value;
                            });
                        };
                    }
                };
            } ];
            var ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
                return {
                    restrict: "A",
                    compile: function ngBindHtmlCompile(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
                            return $sce.valueOf(val);
                        });
                        $compile.$$addBindingClass(tElement);
                        return function ngBindHtmlLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBindHtml);
                            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                                var value = ngBindHtmlGetter(scope);
                                element.html($sce.getTrustedHtml(value) || "");
                            });
                        };
                    }
                };
            } ];
            var ngChangeDirective = valueFn({
                restrict: "A",
                require: "ngModel",
                link: function(scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push(function() {
                        scope.$eval(attr.ngChange);
                    });
                }
            });
            function classDirective(name, selector) {
                name = "ngClass" + name;
                var indexWatchExpression;
                return [ "$parse", function($parse) {
                    return {
                        restrict: "AC",
                        link: function(scope, element, attr) {
                            var expression = attr[name].trim();
                            var isOneTime = expression.charAt(0) === ":" && expression.charAt(1) === ":";
                            var watchInterceptor = isOneTime ? toFlatValue : toClassString;
                            var watchExpression = $parse(expression, watchInterceptor);
                            var watchAction = isOneTime ? ngClassOneTimeWatchAction : ngClassWatchAction;
                            var classCounts = element.data("$classCounts");
                            var oldModulo = true;
                            var oldClassString;
                            if (!classCounts) {
                                classCounts = createMap();
                                element.data("$classCounts", classCounts);
                            }
                            if (name !== "ngClass") {
                                if (!indexWatchExpression) {
                                    indexWatchExpression = $parse("$index", function moduloTwo($index) {
                                        return $index & 1;
                                    });
                                }
                                scope.$watch(indexWatchExpression, ngClassIndexWatchAction);
                            }
                            scope.$watch(watchExpression, watchAction, isOneTime);
                            function addClasses(classString) {
                                classString = digestClassCounts(split(classString), 1);
                                attr.$addClass(classString);
                            }
                            function removeClasses(classString) {
                                classString = digestClassCounts(split(classString), -1);
                                attr.$removeClass(classString);
                            }
                            function updateClasses(oldClassString, newClassString) {
                                var oldClassArray = split(oldClassString);
                                var newClassArray = split(newClassString);
                                var toRemoveArray = arrayDifference(oldClassArray, newClassArray);
                                var toAddArray = arrayDifference(newClassArray, oldClassArray);
                                var toRemoveString = digestClassCounts(toRemoveArray, -1);
                                var toAddString = digestClassCounts(toAddArray, 1);
                                attr.$addClass(toAddString);
                                attr.$removeClass(toRemoveString);
                            }
                            function digestClassCounts(classArray, count) {
                                var classesToUpdate = [];
                                forEach(classArray, function(className) {
                                    if (count > 0 || classCounts[className]) {
                                        classCounts[className] = (classCounts[className] || 0) + count;
                                        if (classCounts[className] === +(count > 0)) {
                                            classesToUpdate.push(className);
                                        }
                                    }
                                });
                                return classesToUpdate.join(" ");
                            }
                            function ngClassIndexWatchAction(newModulo) {
                                if (newModulo === selector) {
                                    addClasses(oldClassString);
                                } else {
                                    removeClasses(oldClassString);
                                }
                                oldModulo = newModulo;
                            }
                            function ngClassOneTimeWatchAction(newClassValue) {
                                var newClassString = toClassString(newClassValue);
                                if (newClassString !== oldClassString) {
                                    ngClassWatchAction(newClassString);
                                }
                            }
                            function ngClassWatchAction(newClassString) {
                                if (oldModulo === selector) {
                                    updateClasses(oldClassString, newClassString);
                                }
                                oldClassString = newClassString;
                            }
                        }
                    };
                } ];
                function arrayDifference(tokens1, tokens2) {
                    if (!tokens1 || !tokens1.length) return [];
                    if (!tokens2 || !tokens2.length) return tokens1;
                    var values = [];
                    outer: for (var i = 0; i < tokens1.length; i++) {
                        var token = tokens1[i];
                        for (var j = 0; j < tokens2.length; j++) {
                            if (token === tokens2[j]) continue outer;
                        }
                        values.push(token);
                    }
                    return values;
                }
                function split(classString) {
                    return classString && classString.split(" ");
                }
                function toClassString(classValue) {
                    var classString = classValue;
                    if (isArray(classValue)) {
                        classString = classValue.map(toClassString).join(" ");
                    } else if (isObject(classValue)) {
                        classString = Object.keys(classValue).filter(function(key) {
                            return classValue[key];
                        }).join(" ");
                    }
                    return classString;
                }
                function toFlatValue(classValue) {
                    var flatValue = classValue;
                    if (isArray(classValue)) {
                        flatValue = classValue.map(toFlatValue);
                    } else if (isObject(classValue)) {
                        var hasUndefined = false;
                        flatValue = Object.keys(classValue).filter(function(key) {
                            var value = classValue[key];
                            if (!hasUndefined && isUndefined(value)) {
                                hasUndefined = true;
                            }
                            return value;
                        });
                        if (hasUndefined) {
                            flatValue.push(undefined);
                        }
                    }
                    return flatValue;
                }
            }
            var ngClassDirective = classDirective("", true);
            var ngClassOddDirective = classDirective("Odd", 0);
            var ngClassEvenDirective = classDirective("Even", 1);
            var ngCloakDirective = ngDirective({
                compile: function(element, attr) {
                    attr.$set("ngCloak", undefined);
                    element.removeClass("ng-cloak");
                }
            });
            var ngControllerDirective = [ function() {
                return {
                    restrict: "A",
                    scope: true,
                    controller: "@",
                    priority: 500
                };
            } ];
            var ngEventDirectives = {};
            var forceAsyncEvents = {
                blur: true,
                focus: true
            };
            forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
                var directiveName = directiveNormalize("ng-" + eventName);
                ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
                    return {
                        restrict: "A",
                        compile: function($element, attr) {
                            var fn = $parse(attr[directiveName]);
                            return function ngEventHandler(scope, element) {
                                element.on(eventName, function(event) {
                                    var callback = function() {
                                        fn(scope, {
                                            $event: event
                                        });
                                    };
                                    if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                        scope.$evalAsync(callback);
                                    } else {
                                        scope.$apply(callback);
                                    }
                                });
                            };
                        }
                    };
                } ];
            });
            var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
                return {
                    multiElement: true,
                    transclude: "element",
                    priority: 600,
                    terminal: true,
                    restrict: "A",
                    $$tlb: true,
                    link: function($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                            if (value) {
                                if (!childScope) {
                                    $transclude(function(clone, newScope) {
                                        childScope = newScope;
                                        clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf);
                                        block = {
                                            clone: clone
                                        };
                                        $animate.enter(clone, $element.parent(), $element);
                                    });
                                }
                            } else {
                                if (previousElements) {
                                    previousElements.remove();
                                    previousElements = null;
                                }
                                if (childScope) {
                                    childScope.$destroy();
                                    childScope = null;
                                }
                                if (block) {
                                    previousElements = getBlockNodes(block.clone);
                                    $animate.leave(previousElements).done(function(response) {
                                        if (response !== false) previousElements = null;
                                    });
                                    block = null;
                                }
                            }
                        });
                    }
                };
            } ];
            var ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: true,
                    transclude: "element",
                    controller: angular.noop,
                    compile: function(element, attr) {
                        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                        return function(scope, $element, $attr, ctrl, $transclude) {
                            var changeCounter = 0, currentScope, previousElement, currentElement;
                            var cleanupLastIncludeContent = function() {
                                if (previousElement) {
                                    previousElement.remove();
                                    previousElement = null;
                                }
                                if (currentScope) {
                                    currentScope.$destroy();
                                    currentScope = null;
                                }
                                if (currentElement) {
                                    $animate.leave(currentElement).done(function(response) {
                                        if (response !== false) previousElement = null;
                                    });
                                    previousElement = currentElement;
                                    currentElement = null;
                                }
                            };
                            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                                var afterAnimation = function(response) {
                                    if (response !== false && isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                        $anchorScroll();
                                    }
                                };
                                var thisChangeId = ++changeCounter;
                                if (src) {
                                    $templateRequest(src, true).then(function(response) {
                                        if (scope.$$destroyed) return;
                                        if (thisChangeId !== changeCounter) return;
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, function(clone) {
                                            cleanupLastIncludeContent();
                                            $animate.enter(clone, null, $element).done(afterAnimation);
                                        });
                                        currentScope = newScope;
                                        currentElement = clone;
                                        currentScope.$emit("$includeContentLoaded", src);
                                        scope.$eval(onloadExp);
                                    }, function() {
                                        if (scope.$$destroyed) return;
                                        if (thisChangeId === changeCounter) {
                                            cleanupLastIncludeContent();
                                            scope.$emit("$includeContentError", src);
                                        }
                                    });
                                    scope.$emit("$includeContentRequested", src);
                                } else {
                                    cleanupLastIncludeContent();
                                    ctrl.template = null;
                                }
                            });
                        };
                    }
                };
            } ];
            var ngIncludeFillContentDirective = [ "$compile", function($compile) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    require: "ngInclude",
                    link: function(scope, $element, $attr, ctrl) {
                        if (toString.call($element[0]).match(/SVG/)) {
                            $element.empty();
                            $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                                $element.append(clone);
                            }, {
                                futureParentElement: $element
                            });
                            return;
                        }
                        $element.html(ctrl.template);
                        $compile($element.contents())(scope);
                    }
                };
            } ];
            var ngInitDirective = ngDirective({
                priority: 450,
                compile: function() {
                    return {
                        pre: function(scope, element, attrs) {
                            scope.$eval(attrs.ngInit);
                        }
                    };
                }
            });
            var ngListDirective = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    require: "ngModel",
                    link: function(scope, element, attr, ctrl) {
                        var ngList = attr.ngList || ", ";
                        var trimValues = attr.ngTrim !== "false";
                        var separator = trimValues ? trim(ngList) : ngList;
                        var parse = function(viewValue) {
                            if (isUndefined(viewValue)) return;
                            var list = [];
                            if (viewValue) {
                                forEach(viewValue.split(separator), function(value) {
                                    if (value) list.push(trimValues ? trim(value) : value);
                                });
                            }
                            return list;
                        };
                        ctrl.$parsers.push(parse);
                        ctrl.$formatters.push(function(value) {
                            if (isArray(value)) {
                                return value.join(ngList);
                            }
                            return undefined;
                        });
                        ctrl.$isEmpty = function(value) {
                            return !value || !value.length;
                        };
                    }
                };
            };
            var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty";
            var ngModelMinErr = minErr("ngModel");
            NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ];
            function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
                this.$viewValue = Number.NaN;
                this.$modelValue = Number.NaN;
                this.$$rawModelValue = undefined;
                this.$validators = {};
                this.$asyncValidators = {};
                this.$parsers = [];
                this.$formatters = [];
                this.$viewChangeListeners = [];
                this.$untouched = true;
                this.$touched = false;
                this.$pristine = true;
                this.$dirty = false;
                this.$valid = true;
                this.$invalid = false;
                this.$error = {};
                this.$$success = {};
                this.$pending = undefined;
                this.$name = $interpolate($attr.name || "", false)($scope);
                this.$$parentForm = nullFormCtrl;
                this.$options = defaultModelOptions;
                this.$$updateEvents = "";
                this.$$updateEventHandler = this.$$updateEventHandler.bind(this);
                this.$$parsedNgModel = $parse($attr.ngModel);
                this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;
                this.$$ngModelGet = this.$$parsedNgModel;
                this.$$ngModelSet = this.$$parsedNgModelAssign;
                this.$$pendingDebounce = null;
                this.$$parserValid = undefined;
                this.$$currentValidationRunId = 0;
                Object.defineProperty(this, "$$scope", {
                    value: $scope
                });
                this.$$attr = $attr;
                this.$$element = $element;
                this.$$animate = $animate;
                this.$$timeout = $timeout;
                this.$$parse = $parse;
                this.$$q = $q;
                this.$$exceptionHandler = $exceptionHandler;
                setupValidity(this);
                setupModelWatcher(this);
            }
            NgModelController.prototype = {
                $$initGetterSetters: function() {
                    if (this.$options.getOption("getterSetter")) {
                        var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                        this.$$ngModelGet = function($scope) {
                            var modelValue = this.$$parsedNgModel($scope);
                            if (isFunction(modelValue)) {
                                modelValue = invokeModelGetter($scope);
                            }
                            return modelValue;
                        };
                        this.$$ngModelSet = function($scope, newValue) {
                            if (isFunction(this.$$parsedNgModel($scope))) {
                                invokeModelSetter($scope, {
                                    $$$p: newValue
                                });
                            } else {
                                this.$$parsedNgModelAssign($scope, newValue);
                            }
                        };
                    } else if (!this.$$parsedNgModel.assign) {
                        throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
                    }
                },
                $render: noop,
                $isEmpty: function(value) {
                    return isUndefined(value) || value === "" || value === null || value !== value;
                },
                $$updateEmptyClasses: function(value) {
                    if (this.$isEmpty(value)) {
                        this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
                        this.$$animate.addClass(this.$$element, EMPTY_CLASS);
                    } else {
                        this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
                        this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
                    }
                },
                $setPristine: function() {
                    this.$dirty = false;
                    this.$pristine = true;
                    this.$$animate.removeClass(this.$$element, DIRTY_CLASS);
                    this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
                },
                $setDirty: function() {
                    this.$dirty = true;
                    this.$pristine = false;
                    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
                    this.$$animate.addClass(this.$$element, DIRTY_CLASS);
                    this.$$parentForm.$setDirty();
                },
                $setUntouched: function() {
                    this.$touched = false;
                    this.$untouched = true;
                    this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
                },
                $setTouched: function() {
                    this.$touched = true;
                    this.$untouched = false;
                    this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
                },
                $rollbackViewValue: function() {
                    this.$$timeout.cancel(this.$$pendingDebounce);
                    this.$viewValue = this.$$lastCommittedViewValue;
                    this.$render();
                },
                $validate: function() {
                    if (isNumberNaN(this.$modelValue)) {
                        return;
                    }
                    var viewValue = this.$$lastCommittedViewValue;
                    var modelValue = this.$$rawModelValue;
                    var prevValid = this.$valid;
                    var prevModelValue = this.$modelValue;
                    var allowInvalid = this.$options.getOption("allowInvalid");
                    var that = this;
                    this.$$runValidators(modelValue, viewValue, function(allValid) {
                        if (!allowInvalid && prevValid !== allValid) {
                            that.$modelValue = allValid ? modelValue : undefined;
                            if (that.$modelValue !== prevModelValue) {
                                that.$$writeModelToScope();
                            }
                        }
                    });
                },
                $$runValidators: function(modelValue, viewValue, doneCallback) {
                    this.$$currentValidationRunId++;
                    var localValidationRunId = this.$$currentValidationRunId;
                    var that = this;
                    if (!processParseErrors()) {
                        validationDone(false);
                        return;
                    }
                    if (!processSyncValidators()) {
                        validationDone(false);
                        return;
                    }
                    processAsyncValidators();
                    function processParseErrors() {
                        var errorKey = that.$$parserName || "parse";
                        if (isUndefined(that.$$parserValid)) {
                            setValidity(errorKey, null);
                        } else {
                            if (!that.$$parserValid) {
                                forEach(that.$validators, function(v, name) {
                                    setValidity(name, null);
                                });
                                forEach(that.$asyncValidators, function(v, name) {
                                    setValidity(name, null);
                                });
                            }
                            setValidity(errorKey, that.$$parserValid);
                            return that.$$parserValid;
                        }
                        return true;
                    }
                    function processSyncValidators() {
                        var syncValidatorsValid = true;
                        forEach(that.$validators, function(validator, name) {
                            var result = Boolean(validator(modelValue, viewValue));
                            syncValidatorsValid = syncValidatorsValid && result;
                            setValidity(name, result);
                        });
                        if (!syncValidatorsValid) {
                            forEach(that.$asyncValidators, function(v, name) {
                                setValidity(name, null);
                            });
                            return false;
                        }
                        return true;
                    }
                    function processAsyncValidators() {
                        var validatorPromises = [];
                        var allValid = true;
                        forEach(that.$asyncValidators, function(validator, name) {
                            var promise = validator(modelValue, viewValue);
                            if (!isPromiseLike(promise)) {
                                throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                            }
                            setValidity(name, undefined);
                            validatorPromises.push(promise.then(function() {
                                setValidity(name, true);
                            }, function() {
                                allValid = false;
                                setValidity(name, false);
                            }));
                        });
                        if (!validatorPromises.length) {
                            validationDone(true);
                        } else {
                            that.$$q.all(validatorPromises).then(function() {
                                validationDone(allValid);
                            }, noop);
                        }
                    }
                    function setValidity(name, isValid) {
                        if (localValidationRunId === that.$$currentValidationRunId) {
                            that.$setValidity(name, isValid);
                        }
                    }
                    function validationDone(allValid) {
                        if (localValidationRunId === that.$$currentValidationRunId) {
                            doneCallback(allValid);
                        }
                    }
                },
                $commitViewValue: function() {
                    var viewValue = this.$viewValue;
                    this.$$timeout.cancel(this.$$pendingDebounce);
                    if (this.$$lastCommittedViewValue === viewValue && (viewValue !== "" || !this.$$hasNativeValidators)) {
                        return;
                    }
                    this.$$updateEmptyClasses(viewValue);
                    this.$$lastCommittedViewValue = viewValue;
                    if (this.$pristine) {
                        this.$setDirty();
                    }
                    this.$$parseAndValidate();
                },
                $$parseAndValidate: function() {
                    var viewValue = this.$$lastCommittedViewValue;
                    var modelValue = viewValue;
                    var that = this;
                    this.$$parserValid = isUndefined(modelValue) ? undefined : true;
                    if (this.$$parserValid) {
                        for (var i = 0; i < this.$parsers.length; i++) {
                            modelValue = this.$parsers[i](modelValue);
                            if (isUndefined(modelValue)) {
                                this.$$parserValid = false;
                                break;
                            }
                        }
                    }
                    if (isNumberNaN(this.$modelValue)) {
                        this.$modelValue = this.$$ngModelGet(this.$$scope);
                    }
                    var prevModelValue = this.$modelValue;
                    var allowInvalid = this.$options.getOption("allowInvalid");
                    this.$$rawModelValue = modelValue;
                    if (allowInvalid) {
                        this.$modelValue = modelValue;
                        writeToModelIfNeeded();
                    }
                    this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                        if (!allowInvalid) {
                            that.$modelValue = allValid ? modelValue : undefined;
                            writeToModelIfNeeded();
                        }
                    });
                    function writeToModelIfNeeded() {
                        if (that.$modelValue !== prevModelValue) {
                            that.$$writeModelToScope();
                        }
                    }
                },
                $$writeModelToScope: function() {
                    this.$$ngModelSet(this.$$scope, this.$modelValue);
                    forEach(this.$viewChangeListeners, function(listener) {
                        try {
                            listener();
                        } catch (e) {
                            this.$$exceptionHandler(e);
                        }
                    }, this);
                },
                $setViewValue: function(value, trigger) {
                    this.$viewValue = value;
                    if (this.$options.getOption("updateOnDefault")) {
                        this.$$debounceViewValueCommit(trigger);
                    }
                },
                $$debounceViewValueCommit: function(trigger) {
                    var debounceDelay = this.$options.getOption("debounce");
                    if (isNumber(debounceDelay[trigger])) {
                        debounceDelay = debounceDelay[trigger];
                    } else if (isNumber(debounceDelay["default"])) {
                        debounceDelay = debounceDelay["default"];
                    }
                    this.$$timeout.cancel(this.$$pendingDebounce);
                    var that = this;
                    if (debounceDelay > 0) {
                        this.$$pendingDebounce = this.$$timeout(function() {
                            that.$commitViewValue();
                        }, debounceDelay);
                    } else if (this.$$scope.$root.$$phase) {
                        this.$commitViewValue();
                    } else {
                        this.$$scope.$apply(function() {
                            that.$commitViewValue();
                        });
                    }
                },
                $overrideModelOptions: function(options) {
                    this.$options = this.$options.createChild(options);
                    this.$$setUpdateOnEvents();
                },
                $processModelValue: function() {
                    var viewValue = this.$$format();
                    if (this.$viewValue !== viewValue) {
                        this.$$updateEmptyClasses(viewValue);
                        this.$viewValue = this.$$lastCommittedViewValue = viewValue;
                        this.$render();
                        this.$$runValidators(this.$modelValue, this.$viewValue, noop);
                    }
                },
                $$format: function() {
                    var formatters = this.$formatters, idx = formatters.length;
                    var viewValue = this.$modelValue;
                    while (idx--) {
                        viewValue = formatters[idx](viewValue);
                    }
                    return viewValue;
                },
                $$setModelValue: function(modelValue) {
                    this.$modelValue = this.$$rawModelValue = modelValue;
                    this.$$parserValid = undefined;
                    this.$processModelValue();
                },
                $$setUpdateOnEvents: function() {
                    if (this.$$updateEvents) {
                        this.$$element.off(this.$$updateEvents, this.$$updateEventHandler);
                    }
                    this.$$updateEvents = this.$options.getOption("updateOn");
                    if (this.$$updateEvents) {
                        this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
                    }
                },
                $$updateEventHandler: function(ev) {
                    this.$$debounceViewValueCommit(ev && ev.type);
                }
            };
            function setupModelWatcher(ctrl) {
                ctrl.$$scope.$watch(function ngModelWatch(scope) {
                    var modelValue = ctrl.$$ngModelGet(scope);
                    if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                        ctrl.$$setModelValue(modelValue);
                    }
                    return modelValue;
                });
            }
            addSetValidityMethod({
                clazz: NgModelController,
                set: function(object, property) {
                    object[property] = true;
                },
                unset: function(object, property) {
                    delete object[property];
                }
            });
            var ngModelDirective = [ "$rootScope", function($rootScope) {
                return {
                    restrict: "A",
                    require: [ "ngModel", "^?form", "^?ngModelOptions" ],
                    controller: NgModelController,
                    priority: 1,
                    compile: function ngModelCompile(element) {
                        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                        return {
                            pre: function ngModelPreLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                                if (optionsCtrl) {
                                    modelCtrl.$options = optionsCtrl.$options;
                                }
                                modelCtrl.$$initGetterSetters();
                                formCtrl.$addControl(modelCtrl);
                                attr.$observe("name", function(newValue) {
                                    if (modelCtrl.$name !== newValue) {
                                        modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                    }
                                });
                                scope.$on("$destroy", function() {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                });
                            },
                            post: function ngModelPostLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0];
                                modelCtrl.$$setUpdateOnEvents();
                                function setTouched() {
                                    modelCtrl.$setTouched();
                                }
                                element.on("blur", function() {
                                    if (modelCtrl.$touched) return;
                                    if ($rootScope.$$phase) {
                                        scope.$evalAsync(setTouched);
                                    } else {
                                        scope.$apply(setTouched);
                                    }
                                });
                            }
                        };
                    }
                };
            } ];
            var defaultModelOptions;
            var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
            function ModelOptions(options) {
                this.$$options = options;
            }
            ModelOptions.prototype = {
                getOption: function(name) {
                    return this.$$options[name];
                },
                createChild: function(options) {
                    var inheritAll = false;
                    options = extend({}, options);
                    forEach(options, function(option, key) {
                        if (option === "$inherit") {
                            if (key === "*") {
                                inheritAll = true;
                            } else {
                                options[key] = this.$$options[key];
                                if (key === "updateOn") {
                                    options.updateOnDefault = this.$$options.updateOnDefault;
                                }
                            }
                        } else {
                            if (key === "updateOn") {
                                options.updateOnDefault = false;
                                options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                                    options.updateOnDefault = true;
                                    return " ";
                                }));
                            }
                        }
                    }, this);
                    if (inheritAll) {
                        delete options["*"];
                        defaults(options, this.$$options);
                    }
                    defaults(options, defaultModelOptions.$$options);
                    return new ModelOptions(options);
                }
            };
            defaultModelOptions = new ModelOptions({
                updateOn: "",
                updateOnDefault: true,
                debounce: 0,
                getterSetter: false,
                allowInvalid: false,
                timezone: null
            });
            var ngModelOptionsDirective = function() {
                NgModelOptionsController.$inject = [ "$attrs", "$scope" ];
                function NgModelOptionsController($attrs, $scope) {
                    this.$$attrs = $attrs;
                    this.$$scope = $scope;
                }
                NgModelOptionsController.prototype = {
                    $onInit: function() {
                        var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions;
                        var modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                        this.$options = parentOptions.createChild(modelOptionsDefinition);
                    }
                };
                return {
                    restrict: "A",
                    priority: 10,
                    require: {
                        parentCtrl: "?^^ngModelOptions"
                    },
                    bindToController: true,
                    controller: NgModelOptionsController
                };
            };
            function defaults(dst, src) {
                forEach(src, function(value, key) {
                    if (!isDefined(dst[key])) {
                        dst[key] = value;
                    }
                });
            }
            var ngNonBindableDirective = ngDirective({
                terminal: true,
                priority: 1e3
            });
            var ngOptionsMinErr = minErr("ngOptions");
            var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
            var ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
                function parseOptionsExpression(optionsExp, selectElement, scope) {
                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                    if (!match) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    }
                    var valueName = match[5] || match[7];
                    var keyName = match[6];
                    var selectAs = / as /.test(match[0]) && match[1];
                    var trackBy = match[9];
                    var valueFn = $parse(match[2] ? match[1] : valueName);
                    var selectAsFn = selectAs && $parse(selectAs);
                    var viewValueFn = selectAsFn || valueFn;
                    var trackByFn = trackBy && $parse(trackBy);
                    var getTrackByValueFn = trackBy ? function(value, locals) {
                        return trackByFn(scope, locals);
                    } : function getHashOfValue(value) {
                        return hashKey(value);
                    };
                    var getTrackByValue = function(value, key) {
                        return getTrackByValueFn(value, getLocals(value, key));
                    };
                    var displayFn = $parse(match[2] || match[1]);
                    var groupByFn = $parse(match[3] || "");
                    var disableWhenFn = $parse(match[4] || "");
                    var valuesFn = $parse(match[8]);
                    var locals = {};
                    var getLocals = keyName ? function(value, key) {
                        locals[keyName] = key;
                        locals[valueName] = value;
                        return locals;
                    } : function(value) {
                        locals[valueName] = value;
                        return locals;
                    };
                    function Option(selectValue, viewValue, label, group, disabled) {
                        this.selectValue = selectValue;
                        this.viewValue = viewValue;
                        this.label = label;
                        this.group = group;
                        this.disabled = disabled;
                    }
                    function getOptionValuesKeys(optionValues) {
                        var optionValuesKeys;
                        if (!keyName && isArrayLike(optionValues)) {
                            optionValuesKeys = optionValues;
                        } else {
                            optionValuesKeys = [];
                            for (var itemKey in optionValues) {
                                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== "$") {
                                    optionValuesKeys.push(itemKey);
                                }
                            }
                        }
                        return optionValuesKeys;
                    }
                    return {
                        trackBy: trackBy,
                        getTrackByValue: getTrackByValue,
                        getWatchables: $parse(valuesFn, function(optionValues) {
                            var watchedArray = [];
                            optionValues = optionValues || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var selectValue = getTrackByValueFn(value, locals);
                                watchedArray.push(selectValue);
                                if (match[2] || match[1]) {
                                    var label = displayFn(scope, locals);
                                    watchedArray.push(label);
                                }
                                if (match[4]) {
                                    var disableWhen = disableWhenFn(scope, locals);
                                    watchedArray.push(disableWhen);
                                }
                            }
                            return watchedArray;
                        }),
                        getOptions: function() {
                            var optionItems = [];
                            var selectValueMap = {};
                            var optionValues = valuesFn(scope) || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var viewValue = viewValueFn(scope, locals);
                                var selectValue = getTrackByValueFn(viewValue, locals);
                                var label = displayFn(scope, locals);
                                var group = groupByFn(scope, locals);
                                var disabled = disableWhenFn(scope, locals);
                                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                optionItems.push(optionItem);
                                selectValueMap[selectValue] = optionItem;
                            }
                            return {
                                items: optionItems,
                                selectValueMap: selectValueMap,
                                getOptionFromViewValue: function(value) {
                                    return selectValueMap[getTrackByValue(value)];
                                },
                                getViewValueFromOption: function(option) {
                                    return trackBy ? copy(option.viewValue) : option.viewValue;
                                }
                            };
                        }
                    };
                }
                var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
                function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                    var selectCtrl = ctrls[0];
                    var ngModelCtrl = ctrls[1];
                    var multiple = attr.multiple;
                    for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                        if (children[i].value === "") {
                            selectCtrl.hasEmptyOption = true;
                            selectCtrl.emptyOption = children.eq(i);
                            break;
                        }
                    }
                    selectElement.empty();
                    var providedEmptyOption = !!selectCtrl.emptyOption;
                    var unknownOption = jqLite(optionTemplate.cloneNode(false));
                    unknownOption.val("?");
                    var options;
                    var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
                    var listFragment = $document[0].createDocumentFragment();
                    selectCtrl.generateUnknownOptionValue = function(val) {
                        return "?";
                    };
                    if (!multiple) {
                        selectCtrl.writeValue = function writeNgOptionsValue(value) {
                            if (!options) return;
                            var selectedOption = selectElement[0].options[selectElement[0].selectedIndex];
                            var option = options.getOptionFromViewValue(value);
                            if (selectedOption) selectedOption.removeAttribute("selected");
                            if (option) {
                                if (selectElement[0].value !== option.selectValue) {
                                    selectCtrl.removeUnknownOption();
                                    selectElement[0].value = option.selectValue;
                                    option.element.selected = true;
                                }
                                option.element.setAttribute("selected", "selected");
                            } else {
                                selectCtrl.selectUnknownOrEmptyOption(value);
                            }
                        };
                        selectCtrl.readValue = function readNgOptionsValue() {
                            var selectedOption = options.selectValueMap[selectElement.val()];
                            if (selectedOption && !selectedOption.disabled) {
                                selectCtrl.unselectEmptyOption();
                                selectCtrl.removeUnknownOption();
                                return options.getViewValueFromOption(selectedOption);
                            }
                            return null;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watch(function() {
                                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                            }, function() {
                                ngModelCtrl.$render();
                            });
                        }
                    } else {
                        selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
                            if (!options) return;
                            var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                            options.items.forEach(function(option) {
                                if (option.element.selected && !includes(selectedOptions, option)) {
                                    option.element.selected = false;
                                }
                            });
                        };
                        selectCtrl.readValue = function readNgOptionsMultiple() {
                            var selectedValues = selectElement.val() || [], selections = [];
                            forEach(selectedValues, function(value) {
                                var option = options.selectValueMap[value];
                                if (option && !option.disabled) selections.push(options.getViewValueFromOption(option));
                            });
                            return selections;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watchCollection(function() {
                                if (isArray(ngModelCtrl.$viewValue)) {
                                    return ngModelCtrl.$viewValue.map(function(value) {
                                        return ngOptions.getTrackByValue(value);
                                    });
                                }
                            }, function() {
                                ngModelCtrl.$render();
                            });
                        }
                    }
                    if (providedEmptyOption) {
                        $compile(selectCtrl.emptyOption)(scope);
                        selectElement.prepend(selectCtrl.emptyOption);
                        if (selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT) {
                            selectCtrl.hasEmptyOption = false;
                            selectCtrl.registerOption = function(optionScope, optionEl) {
                                if (optionEl.val() === "") {
                                    selectCtrl.hasEmptyOption = true;
                                    selectCtrl.emptyOption = optionEl;
                                    selectCtrl.emptyOption.removeClass("ng-scope");
                                    ngModelCtrl.$render();
                                    optionEl.on("$destroy", function() {
                                        var needsRerender = selectCtrl.$isEmptyOptionSelected();
                                        selectCtrl.hasEmptyOption = false;
                                        selectCtrl.emptyOption = undefined;
                                        if (needsRerender) ngModelCtrl.$render();
                                    });
                                }
                            };
                        } else {
                            selectCtrl.emptyOption.removeClass("ng-scope");
                        }
                    }
                    scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                    function addOptionElement(option, parent) {
                        var optionElement = optionTemplate.cloneNode(false);
                        parent.appendChild(optionElement);
                        updateOptionElement(option, optionElement);
                    }
                    function getAndUpdateSelectedOption(viewValue) {
                        var option = options.getOptionFromViewValue(viewValue);
                        var element = option && option.element;
                        if (element && !element.selected) element.selected = true;
                        return option;
                    }
                    function updateOptionElement(option, element) {
                        option.element = element;
                        element.disabled = option.disabled;
                        if (option.label !== element.label) {
                            element.label = option.label;
                            element.textContent = option.label;
                        }
                        element.value = option.selectValue;
                    }
                    function updateOptions() {
                        var previousValue = options && selectCtrl.readValue();
                        if (options) {
                            for (var i = options.items.length - 1; i >= 0; i--) {
                                var option = options.items[i];
                                if (isDefined(option.group)) {
                                    jqLiteRemove(option.element.parentNode);
                                } else {
                                    jqLiteRemove(option.element);
                                }
                            }
                        }
                        options = ngOptions.getOptions();
                        var groupElementMap = {};
                        options.items.forEach(function addOption(option) {
                            var groupElement;
                            if (isDefined(option.group)) {
                                groupElement = groupElementMap[option.group];
                                if (!groupElement) {
                                    groupElement = optGroupTemplate.cloneNode(false);
                                    listFragment.appendChild(groupElement);
                                    groupElement.label = option.group === null ? "null" : option.group;
                                    groupElementMap[option.group] = groupElement;
                                }
                                addOptionElement(option, groupElement);
                            } else {
                                addOptionElement(option, listFragment);
                            }
                        });
                        selectElement[0].appendChild(listFragment);
                        ngModelCtrl.$render();
                        if (!ngModelCtrl.$isEmpty(previousValue)) {
                            var nextValue = selectCtrl.readValue();
                            var isNotPrimitive = ngOptions.trackBy || multiple;
                            if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                                ngModelCtrl.$setViewValue(nextValue);
                                ngModelCtrl.$render();
                            }
                        }
                    }
                }
                return {
                    restrict: "A",
                    terminal: true,
                    require: [ "select", "ngModel" ],
                    link: {
                        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop;
                        },
                        post: ngOptionsPostLink
                    }
                };
            } ];
            var ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
                var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function(scope, element, attr) {
                        var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop, lastCount;
                        forEach(attr, function(expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName]);
                            }
                        });
                        forEach(whens, function(expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                        });
                        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                            var count = parseFloat(newVal);
                            var countIsNaN = isNumberNaN(count);
                            if (!countIsNaN && !(count in whens)) {
                                count = $locale.pluralCat(count - offset);
                            }
                            if (count !== lastCount && !(countIsNaN && isNumberNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                if (isUndefined(whenExpFn)) {
                                    if (newVal != null) {
                                        $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                                    }
                                    watchRemover = noop;
                                    updateElementText();
                                } else {
                                    watchRemover = scope.$watch(whenExpFn, updateElementText);
                                }
                                lastCount = count;
                            }
                        });
                        function updateElementText(newText) {
                            element.text(newText || "");
                        }
                    }
                };
            } ];
            var ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
                var NG_REMOVED = "$$NG_REMOVED";
                var ngRepeatMinErr = minErr("ngRepeat");
                var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                    scope[valueIdentifier] = value;
                    if (keyIdentifier) scope[keyIdentifier] = key;
                    scope.$index = index;
                    scope.$first = index === 0;
                    scope.$last = index === arrayLength - 1;
                    scope.$middle = !(scope.$first || scope.$last);
                    scope.$odd = !(scope.$even = (index & 1) === 0);
                };
                var getBlockStart = function(block) {
                    return block.clone[0];
                };
                var getBlockEnd = function(block) {
                    return block.clone[block.clone.length - 1];
                };
                return {
                    restrict: "A",
                    multiElement: true,
                    transclude: "element",
                    priority: 1e3,
                    terminal: true,
                    $$tlb: true,
                    compile: function ngRepeatCompile($element, $attr) {
                        var expression = $attr.ngRepeat;
                        var ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression);
                        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) {
                            throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        }
                        var lhs = match[1];
                        var rhs = match[2];
                        var aliasAs = match[3];
                        var trackByExp = match[4];
                        match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
                        if (!match) {
                            throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        }
                        var valueIdentifier = match[3] || match[1];
                        var keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                            throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                        }
                        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                        var hashFnLocals = {
                            $id: hashKey
                        };
                        if (trackByExp) {
                            trackByExpGetter = $parse(trackByExp);
                        } else {
                            trackByIdArrayFn = function(key, value) {
                                return hashKey(value);
                            };
                            trackByIdObjFn = function(key) {
                                return key;
                            };
                        }
                        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                            if (trackByExpGetter) {
                                trackByIdExpFn = function(key, value, index) {
                                    if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
                                    hashFnLocals[valueIdentifier] = value;
                                    hashFnLocals.$index = index;
                                    return trackByExpGetter($scope, hashFnLocals);
                                };
                            }
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                                var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                                if (aliasAs) {
                                    $scope[aliasAs] = collection;
                                }
                                if (isArrayLike(collection)) {
                                    collectionKeys = collection;
                                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                } else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                                    collectionKeys = [];
                                    for (var itemKey in collection) {
                                        if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== "$") {
                                            collectionKeys.push(itemKey);
                                        }
                                    }
                                }
                                collectionLength = collectionKeys.length;
                                nextBlockOrder = new Array(collectionLength);
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    trackById = trackByIdFn(key, value, index);
                                    if (lastBlockMap[trackById]) {
                                        block = lastBlockMap[trackById];
                                        delete lastBlockMap[trackById];
                                        nextBlockMap[trackById] = block;
                                        nextBlockOrder[index] = block;
                                    } else if (nextBlockMap[trackById]) {
                                        forEach(nextBlockOrder, function(block) {
                                            if (block && block.scope) lastBlockMap[block.id] = block;
                                        });
                                        throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                    } else {
                                        nextBlockOrder[index] = {
                                            id: trackById,
                                            scope: undefined,
                                            clone: undefined
                                        };
                                        nextBlockMap[trackById] = true;
                                    }
                                }
                                for (var blockKey in lastBlockMap) {
                                    block = lastBlockMap[blockKey];
                                    elementsToRemove = getBlockNodes(block.clone);
                                    $animate.leave(elementsToRemove);
                                    if (elementsToRemove[0].parentNode) {
                                        for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                            elementsToRemove[index][NG_REMOVED] = true;
                                        }
                                    }
                                    block.scope.$destroy();
                                }
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    block = nextBlockOrder[index];
                                    if (block.scope) {
                                        nextNode = previousNode;
                                        do {
                                            nextNode = nextNode.nextSibling;
                                        } while (nextNode && nextNode[NG_REMOVED]);
                                        if (getBlockStart(block) !== nextNode) {
                                            $animate.move(getBlockNodes(block.clone), null, previousNode);
                                        }
                                        previousNode = getBlockEnd(block);
                                        updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                    } else {
                                        $transclude(function ngRepeatTransclude(clone, scope) {
                                            block.scope = scope;
                                            var endNode = ngRepeatEndComment.cloneNode(false);
                                            clone[clone.length++] = endNode;
                                            $animate.enter(clone, null, previousNode);
                                            previousNode = endNode;
                                            block.clone = clone;
                                            nextBlockMap[block.id] = block;
                                            updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                        });
                                    }
                                }
                                lastBlockMap = nextBlockMap;
                            });
                        };
                    }
                };
            } ];
            var NG_HIDE_CLASS = "ng-hide";
            var NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";
            var ngShowDirective = [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: true,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                            $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                                tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                            });
                        });
                    }
                };
            } ];
            var ngHideDirective = [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: true,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                            $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                                tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                            });
                        });
                    }
                };
            } ];
            var ngStyleDirective = ngDirective(function(scope, element, attr) {
                scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
                    if (oldStyles && newStyles !== oldStyles) {
                        forEach(oldStyles, function(val, style) {
                            element.css(style, "");
                        });
                    }
                    if (newStyles) element.css(newStyles);
                }, true);
            });
            var ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
                return {
                    require: "ngSwitch",
                    controller: [ "$scope", function NgSwitchController() {
                        this.cases = {};
                    } ],
                    link: function(scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                        var spliceFactory = function(array, index) {
                            return function(response) {
                                if (response !== false) array.splice(index, 1);
                            };
                        };
                        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                            var i, ii;
                            while (previousLeaveAnimations.length) {
                                $animate.cancel(previousLeaveAnimations.pop());
                            }
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy();
                                var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                                runner.done(spliceFactory(previousLeaveAnimations, i));
                            }
                            selectedElements.length = 0;
                            selectedScopes.length = 0;
                            if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                                forEach(selectedTranscludes, function(selectedTransclude) {
                                    selectedTransclude.transclude(function(caseElement, selectedScope) {
                                        selectedScopes.push(selectedScope);
                                        var anchor = selectedTransclude.element;
                                        caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                        var block = {
                                            clone: caseElement
                                        };
                                        selectedElements.push(block);
                                        $animate.enter(caseElement, anchor.parent(), anchor);
                                    });
                                });
                            }
                        });
                    }
                };
            } ];
            var ngSwitchWhenDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: true,
                link: function(scope, element, attrs, ctrl, $transclude) {
                    var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                        return array[index - 1] !== element;
                    });
                    forEach(cases, function(whenCase) {
                        ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [];
                        ctrl.cases["!" + whenCase].push({
                            transclude: $transclude,
                            element: element
                        });
                    });
                }
            });
            var ngSwitchDefaultDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: true,
                link: function(scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["?"] = ctrl.cases["?"] || [];
                    ctrl.cases["?"].push({
                        transclude: $transclude,
                        element: element
                    });
                }
            });
            var ngTranscludeMinErr = minErr("ngTransclude");
            var ngTranscludeDirective = [ "$compile", function($compile) {
                return {
                    restrict: "EAC",
                    terminal: true,
                    compile: function ngTranscludeCompile(tElement) {
                        var fallbackLinkFn = $compile(tElement.contents());
                        tElement.empty();
                        return function ngTranscludePostLink($scope, $element, $attrs, controller, $transclude) {
                            if (!$transclude) {
                                throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element));
                            }
                            if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                                $attrs.ngTransclude = "";
                            }
                            var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                            $transclude(ngTranscludeCloneAttachFn, null, slotName);
                            if (slotName && !$transclude.isSlotFilled(slotName)) {
                                useFallbackContent();
                            }
                            function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                                if (clone.length && notWhitespace(clone)) {
                                    $element.append(clone);
                                } else {
                                    useFallbackContent();
                                    transcludedScope.$destroy();
                                }
                            }
                            function useFallbackContent() {
                                fallbackLinkFn($scope, function(clone) {
                                    $element.append(clone);
                                });
                            }
                            function notWhitespace(nodes) {
                                for (var i = 0, ii = nodes.length; i < ii; i++) {
                                    var node = nodes[i];
                                    if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) {
                                        return true;
                                    }
                                }
                            }
                        };
                    }
                };
            } ];
            var scriptDirective = [ "$templateCache", function($templateCache) {
                return {
                    restrict: "E",
                    terminal: true,
                    compile: function(element, attr) {
                        if (attr.type === "text/ng-template") {
                            var templateUrl = attr.id, text = element[0].text;
                            $templateCache.put(templateUrl, text);
                        }
                    }
                };
            } ];
            var noopNgModelController = {
                $setViewValue: noop,
                $render: noop
            };
            function setOptionSelectedStatus(optionEl, value) {
                optionEl.prop("selected", value);
                optionEl.attr("selected", value);
            }
            var SelectController = [ "$element", "$scope", function($element, $scope) {
                var self = this, optionsMap = new NgMap();
                self.selectValueMap = {};
                self.ngModelCtrl = noopNgModelController;
                self.multiple = false;
                self.unknownOption = jqLite(window.document.createElement("option"));
                self.hasEmptyOption = false;
                self.emptyOption = undefined;
                self.renderUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal);
                    $element.prepend(self.unknownOption);
                    setOptionSelectedStatus(self.unknownOption, true);
                    $element.val(unknownVal);
                };
                self.updateUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal);
                    setOptionSelectedStatus(self.unknownOption, true);
                    $element.val(unknownVal);
                };
                self.generateUnknownOptionValue = function(val) {
                    return "? " + hashKey(val) + " ?";
                };
                self.removeUnknownOption = function() {
                    if (self.unknownOption.parent()) self.unknownOption.remove();
                };
                self.selectEmptyOption = function() {
                    if (self.emptyOption) {
                        $element.val("");
                        setOptionSelectedStatus(self.emptyOption, true);
                    }
                };
                self.unselectEmptyOption = function() {
                    if (self.hasEmptyOption) {
                        setOptionSelectedStatus(self.emptyOption, false);
                    }
                };
                $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
                self.readValue = function readSingleValue() {
                    var val = $element.val();
                    var realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
                    if (self.hasOption(realVal)) {
                        return realVal;
                    }
                    return null;
                };
                self.writeValue = function writeSingleValue(value) {
                    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
                    if (currentlySelectedOption) setOptionSelectedStatus(jqLite(currentlySelectedOption), false);
                    if (self.hasOption(value)) {
                        self.removeUnknownOption();
                        var hashedVal = hashKey(value);
                        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                        var selectedOption = $element[0].options[$element[0].selectedIndex];
                        setOptionSelectedStatus(jqLite(selectedOption), true);
                    } else {
                        self.selectUnknownOrEmptyOption(value);
                    }
                };
                self.addOption = function(value, element) {
                    if (element[0].nodeType === NODE_TYPE_COMMENT) return;
                    assertNotHasOwnProperty(value, '"option value"');
                    if (value === "") {
                        self.hasEmptyOption = true;
                        self.emptyOption = element;
                    }
                    var count = optionsMap.get(value) || 0;
                    optionsMap.set(value, count + 1);
                    scheduleRender();
                };
                self.removeOption = function(value) {
                    var count = optionsMap.get(value);
                    if (count) {
                        if (count === 1) {
                            optionsMap.delete(value);
                            if (value === "") {
                                self.hasEmptyOption = false;
                                self.emptyOption = undefined;
                            }
                        } else {
                            optionsMap.set(value, count - 1);
                        }
                    }
                };
                self.hasOption = function(value) {
                    return !!optionsMap.get(value);
                };
                self.$hasEmptyOption = function() {
                    return self.hasEmptyOption;
                };
                self.$isUnknownOptionSelected = function() {
                    return $element[0].options[0] === self.unknownOption[0];
                };
                self.$isEmptyOptionSelected = function() {
                    return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];
                };
                self.selectUnknownOrEmptyOption = function(value) {
                    if (value == null && self.emptyOption) {
                        self.removeUnknownOption();
                        self.selectEmptyOption();
                    } else if (self.unknownOption.parent().length) {
                        self.updateUnknownOption(value);
                    } else {
                        self.renderUnknownOption(value);
                    }
                };
                var renderScheduled = false;
                function scheduleRender() {
                    if (renderScheduled) return;
                    renderScheduled = true;
                    $scope.$$postDigest(function() {
                        renderScheduled = false;
                        self.ngModelCtrl.$render();
                    });
                }
                var updateScheduled = false;
                function scheduleViewValueUpdate(renderAfter) {
                    if (updateScheduled) return;
                    updateScheduled = true;
                    $scope.$$postDigest(function() {
                        if ($scope.$$destroyed) return;
                        updateScheduled = false;
                        self.ngModelCtrl.$setViewValue(self.readValue());
                        if (renderAfter) self.ngModelCtrl.$render();
                    });
                }
                self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    if (optionAttrs.$attr.ngValue) {
                        var oldVal, hashedVal = NaN;
                        optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                            var removal;
                            var previouslySelected = optionElement.prop("selected");
                            if (isDefined(hashedVal)) {
                                self.removeOption(oldVal);
                                delete self.selectValueMap[hashedVal];
                                removal = true;
                            }
                            hashedVal = hashKey(newVal);
                            oldVal = newVal;
                            self.selectValueMap[hashedVal] = newVal;
                            self.addOption(newVal, optionElement);
                            optionElement.attr("value", hashedVal);
                            if (removal && previouslySelected) {
                                scheduleViewValueUpdate();
                            }
                        });
                    } else if (interpolateValueFn) {
                        optionAttrs.$observe("value", function valueAttributeObserveAction(newVal) {
                            self.readValue();
                            var removal;
                            var previouslySelected = optionElement.prop("selected");
                            if (isDefined(oldVal)) {
                                self.removeOption(oldVal);
                                removal = true;
                            }
                            oldVal = newVal;
                            self.addOption(newVal, optionElement);
                            if (removal && previouslySelected) {
                                scheduleViewValueUpdate();
                            }
                        });
                    } else if (interpolateTextFn) {
                        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                            optionAttrs.$set("value", newVal);
                            var previouslySelected = optionElement.prop("selected");
                            if (oldVal !== newVal) {
                                self.removeOption(oldVal);
                            }
                            self.addOption(newVal, optionElement);
                            if (oldVal && previouslySelected) {
                                scheduleViewValueUpdate();
                            }
                        });
                    } else {
                        self.addOption(optionAttrs.value, optionElement);
                    }
                    optionAttrs.$observe("disabled", function(newVal) {
                        if (newVal === "true" || newVal && optionElement.prop("selected")) {
                            if (self.multiple) {
                                scheduleViewValueUpdate(true);
                            } else {
                                self.ngModelCtrl.$setViewValue(null);
                                self.ngModelCtrl.$render();
                            }
                        }
                    });
                    optionElement.on("$destroy", function() {
                        var currentValue = self.readValue();
                        var removeValue = optionAttrs.value;
                        self.removeOption(removeValue);
                        scheduleRender();
                        if (self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) {
                            scheduleViewValueUpdate(true);
                        }
                    });
                };
            } ];
            var selectDirective = function() {
                return {
                    restrict: "E",
                    require: [ "select", "?ngModel" ],
                    controller: SelectController,
                    priority: 1,
                    link: {
                        pre: selectPreLink,
                        post: selectPostLink
                    }
                };
                function selectPreLink(scope, element, attr, ctrls) {
                    var selectCtrl = ctrls[0];
                    var ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) {
                        selectCtrl.registerOption = noop;
                        return;
                    }
                    selectCtrl.ngModelCtrl = ngModelCtrl;
                    element.on("change", function() {
                        selectCtrl.removeUnknownOption();
                        scope.$apply(function() {
                            ngModelCtrl.$setViewValue(selectCtrl.readValue());
                        });
                    });
                    if (attr.multiple) {
                        selectCtrl.multiple = true;
                        selectCtrl.readValue = function readMultipleValue() {
                            var array = [];
                            forEach(element.find("option"), function(option) {
                                if (option.selected && !option.disabled) {
                                    var val = option.value;
                                    array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                                }
                            });
                            return array;
                        };
                        selectCtrl.writeValue = function writeMultipleValue(value) {
                            forEach(element.find("option"), function(option) {
                                var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                                var currentlySelected = option.selected;
                                if (shouldBeSelected !== currentlySelected) {
                                    setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                                }
                            });
                        };
                        var lastView, lastViewRef = NaN;
                        scope.$watch(function selectMultipleWatch() {
                            if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                                lastView = shallowCopy(ngModelCtrl.$viewValue);
                                ngModelCtrl.$render();
                            }
                            lastViewRef = ngModelCtrl.$viewValue;
                        });
                        ngModelCtrl.$isEmpty = function(value) {
                            return !value || value.length === 0;
                        };
                    }
                }
                function selectPostLink(scope, element, attrs, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) return;
                    var selectCtrl = ctrls[0];
                    ngModelCtrl.$render = function() {
                        selectCtrl.writeValue(ngModelCtrl.$viewValue);
                    };
                }
            };
            var optionDirective = [ "$interpolate", function($interpolate) {
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function(element, attr) {
                        var interpolateValueFn, interpolateTextFn;
                        if (isDefined(attr.ngValue)) {} else if (isDefined(attr.value)) {
                            interpolateValueFn = $interpolate(attr.value, true);
                        } else {
                            interpolateTextFn = $interpolate(element.text(), true);
                            if (!interpolateTextFn) {
                                attr.$set("value", element.text());
                            }
                        }
                        return function(scope, element, attr) {
                            var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                            if (selectCtrl) {
                                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                            }
                        };
                    }
                };
            } ];
            var requiredDirective = function() {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (!ctrl) return;
                        attr.required = true;
                        ctrl.$validators.required = function(modelValue, viewValue) {
                            return !attr.required || !ctrl.$isEmpty(viewValue);
                        };
                        attr.$observe("required", function() {
                            ctrl.$validate();
                        });
                    }
                };
            };
            var patternDirective = function() {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (!ctrl) return;
                        var regexp, patternExp = attr.ngPattern || attr.pattern;
                        attr.$observe("pattern", function(regex) {
                            if (isString(regex) && regex.length > 0) {
                                regex = new RegExp("^" + regex + "$");
                            }
                            if (regex && !regex.test) {
                                throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                            }
                            regexp = regex || undefined;
                            ctrl.$validate();
                        });
                        ctrl.$validators.pattern = function(modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                        };
                    }
                };
            };
            var maxlengthDirective = function() {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (!ctrl) return;
                        var maxlength = -1;
                        attr.$observe("maxlength", function(value) {
                            var intVal = toInt(value);
                            maxlength = isNumberNaN(intVal) ? -1 : intVal;
                            ctrl.$validate();
                        });
                        ctrl.$validators.maxlength = function(modelValue, viewValue) {
                            return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                        };
                    }
                };
            };
            var minlengthDirective = function() {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (!ctrl) return;
                        var minlength = 0;
                        attr.$observe("minlength", function(value) {
                            minlength = toInt(value) || 0;
                            ctrl.$validate();
                        });
                        ctrl.$validators.minlength = function(modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                        };
                    }
                };
            };
            if (window.angular.bootstrap) {
                if (window.console) {
                    console.log("WARNING: Tried to load angular more than once.");
                }
                return;
            }
            bindJQuery();
            publishExternalAPI(angular);
            angular.module("ngLocale", [], [ "$provide", function($provide) {
                var PLURAL_CATEGORY = {
                    ZERO: "zero",
                    ONE: "one",
                    TWO: "two",
                    FEW: "few",
                    MANY: "many",
                    OTHER: "other"
                };
                function getDecimals(n) {
                    n = n + "";
                    var i = n.indexOf(".");
                    return i == -1 ? 0 : n.length - i - 1;
                }
                function getVF(n, opt_precision) {
                    var v = opt_precision;
                    if (undefined === v) {
                        v = Math.min(getDecimals(n), 3);
                    }
                    var base = Math.pow(10, v);
                    var f = (n * base | 0) % base;
                    return {
                        v: v,
                        f: f
                    };
                }
                $provide.value("$locale", {
                    DATETIME_FORMATS: {
                        AMPMS: [ "AM", "PM" ],
                        DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                        ERANAMES: [ "Before Christ", "Anno Domini" ],
                        ERAS: [ "BC", "AD" ],
                        FIRSTDAYOFWEEK: 6,
                        MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                        SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                        STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        WEEKENDRANGE: [ 5, 6 ],
                        fullDate: "EEEE, MMMM d, y",
                        longDate: "MMMM d, y",
                        medium: "MMM d, y h:mm:ss a",
                        mediumDate: "MMM d, y",
                        mediumTime: "h:mm:ss a",
                        short: "M/d/yy h:mm a",
                        shortDate: "M/d/yy",
                        shortTime: "h:mm a"
                    },
                    NUMBER_FORMATS: {
                        CURRENCY_SYM: "$",
                        DECIMAL_SEP: ".",
                        GROUP_SEP: ",",
                        PATTERNS: [ {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 3,
                            minFrac: 0,
                            minInt: 1,
                            negPre: "-",
                            negSuf: "",
                            posPre: "",
                            posSuf: ""
                        }, {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 2,
                            minFrac: 2,
                            minInt: 1,
                            negPre: "-¤",
                            negSuf: "",
                            posPre: "¤",
                            posSuf: ""
                        } ]
                    },
                    id: "en-us",
                    localeID: "en_US",
                    pluralCat: function(n, opt_precision) {
                        var i = n | 0;
                        var vf = getVF(n, opt_precision);
                        if (i == 1 && vf.v == 0) {
                            return PLURAL_CATEGORY.ONE;
                        }
                        return PLURAL_CATEGORY.OTHER;
                    }
                });
            } ]);
            jqLite(function() {
                angularInit(window.document, bootstrap);
            });
        })(window);
        !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
    }, {} ],
    108: [ function(require, module, exports) {
        require("./angular");
        module.exports = angular;
    }, {
        "./angular": 107
    } ],
    109: [ function(require, module, exports) {
        (function(root, factory) {
            "use strict";
            if (typeof define === "function" && define.amd) {
                define([ "angular" ], factory);
            } else if (root.hasOwnProperty("angular")) {
                factory(root.angular);
            } else if (typeof exports === "object") {
                module.exports = factory(require("angular"));
            }
        })(this, function(angular) {
            "use strict";
            angular = angular && angular.module ? angular : window.angular;
            function isStorageSupported($window, storageType) {
                var supported;
                try {
                    supported = $window[storageType];
                } catch (err) {
                    supported = false;
                }
                if (supported) {
                    var key = "__" + Math.round(Math.random() * 1e7);
                    try {
                        $window[storageType].setItem(key, key);
                        $window[storageType].removeItem(key, key);
                    } catch (err) {
                        supported = false;
                    }
                }
                return supported;
            }
            return angular.module("ngStorage", []).provider("$localStorage", _storageProvider("localStorage")).provider("$sessionStorage", _storageProvider("sessionStorage"));
            function _storageProvider(storageType) {
                var providerWebStorage = isStorageSupported(window, storageType);
                return function() {
                    var storageKeyPrefix = "ngStorage-";
                    this.setKeyPrefix = function(prefix) {
                        if (typeof prefix !== "string") {
                            throw new TypeError("[ngStorage] - " + storageType + "Provider.setKeyPrefix() expects a String.");
                        }
                        storageKeyPrefix = prefix;
                    };
                    var serializer = angular.toJson;
                    var deserializer = angular.fromJson;
                    this.setSerializer = function(s) {
                        if (typeof s !== "function") {
                            throw new TypeError("[ngStorage] - " + storageType + "Provider.setSerializer expects a function.");
                        }
                        serializer = s;
                    };
                    this.setDeserializer = function(d) {
                        if (typeof d !== "function") {
                            throw new TypeError("[ngStorage] - " + storageType + "Provider.setDeserializer expects a function.");
                        }
                        deserializer = d;
                    };
                    this.supported = function() {
                        return !!providerWebStorage;
                    };
                    this.get = function(key) {
                        return providerWebStorage && deserializer(providerWebStorage.getItem(storageKeyPrefix + key));
                    };
                    this.set = function(key, value) {
                        return providerWebStorage && providerWebStorage.setItem(storageKeyPrefix + key, serializer(value));
                    };
                    this.remove = function(key) {
                        providerWebStorage && providerWebStorage.removeItem(storageKeyPrefix + key);
                    };
                    this.$get = [ "$rootScope", "$window", "$log", "$timeout", "$document", function($rootScope, $window, $log, $timeout, $document) {
                        var prefixLength = storageKeyPrefix.length;
                        var isSupported = isStorageSupported($window, storageType), webStorage = isSupported || ($log.warn("This browser does not support Web Storage!"), 
                        {
                            setItem: angular.noop,
                            getItem: angular.noop,
                            removeItem: angular.noop
                        }), $storage = {
                            $default: function(items) {
                                for (var k in items) {
                                    angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]));
                                }
                                $storage.$sync();
                                return $storage;
                            },
                            $reset: function(items) {
                                for (var k in $storage) {
                                    "$" === k[0] || delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k);
                                }
                                return $storage.$default(items);
                            },
                            $sync: function() {
                                for (var i = 0, l = webStorage.length, k; i < l; i++) {
                                    (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));
                                }
                            },
                            $apply: function() {
                                var temp$storage;
                                _debounce = null;
                                if (!angular.equals($storage, _last$storage)) {
                                    temp$storage = angular.copy(_last$storage);
                                    angular.forEach($storage, function(v, k) {
                                        if (angular.isDefined(v) && "$" !== k[0]) {
                                            webStorage.setItem(storageKeyPrefix + k, serializer(v));
                                            delete temp$storage[k];
                                        }
                                    });
                                    for (var k in temp$storage) {
                                        webStorage.removeItem(storageKeyPrefix + k);
                                    }
                                    _last$storage = angular.copy($storage);
                                }
                            },
                            $supported: function() {
                                return !!isSupported;
                            }
                        }, _last$storage, _debounce;
                        $storage.$sync();
                        _last$storage = angular.copy($storage);
                        $rootScope.$watch(function() {
                            _debounce || (_debounce = $timeout($storage.$apply, 100, false));
                        });
                        $window.addEventListener && $window.addEventListener("storage", function(event) {
                            if (!event.key) {
                                return;
                            }
                            var doc = $document[0];
                            if ((!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength)) {
                                event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];
                                _last$storage = angular.copy($storage);
                                $rootScope.$apply();
                            }
                        });
                        $window.addEventListener && $window.addEventListener("beforeunload", function() {
                            $storage.$apply();
                        });
                        return $storage;
                    } ];
                };
            }
        });
    }, {
        angular: 108
    } ]
}, {}, [ 1 ]);
